Creating node project
1. Create package.json
      >npm init -y 

2. npm cache clean --force
   npm config set strict-ssl=false
   npm install
   npm i --save-dev nodemon
   npm i --save express

3. "scripts": {
    "start": "nodemon app.js"
  },

4. Create and write code inside app.js

5. >npm start


Blog article

1. First is to set up the server
    >npm init -y 
Which will provide basic package.json 

2. Next we install our dependency like express(used to create the server),mongoose is for database and ejs is for different views
    >npm i express mongoose ejs

3. Next we install dev dependencies
     >npm i --save-dev nodemon
Nodemon is going to allow us to automatically refresh our webpage every single time we make a change to our actual files in package.json and in order to run nodemon we create script in package.json 
"scripts": {
     "devStart" : "nodemon server.js"
 }

Now we create server.js and we run 
   >npm run devStart 
so this file server.js is going to run everytime when we make change and click save we see its gonna refresh 

4. Next we create server, so we get express from the library we just installed 
     const express = require('express')

We also get our app variable and that just comes from calling express and call it as a function 
     const app = express()
Now start the appl in port 5000
     app.listen(5000)

Now go to browser and run localhost:5000, we can see our appl loading and returns "Cannot get /" since we dont have route 

   - Now we create route using app.get("/") which is our main route and this is going to take req and res, for now we send user with response as simple text
     app.get('/', (req, res) => {
           res.send("Hello world")
     }) 
When we refresh the browser, we can see "Hello world"

   - Instead of printing text we want to print HTML page for that we first need to set our view engine, so we use app.set() and set the engine as ejs because we will writing all views using ejs and then our view engine will convert ejs code to HTML
      app.set('view engine', 'ejs')   

5. Create new folder called "views/articles" and inside that create index.ejs
   Inside type ! and click tab button, it will provide html boilerplate code, inside change the title and give some text

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Blog</title>
</head>
<body>
    <h1>This is HTML</h1>
</body>
</html>

So in server instead of sending text, we call render() which access views folder and pass the file we want (ie) index 

app.get('/', (req, res) => {
    res.render('articles/index')
}) 

When we save and refresh the browser, we can see "This is html"

6. Now we have bunch of different routes so we need to create new route, so we create routes folder where all of our different routes are going to get stored 

-Create articles.js and put all of the routes directly related to the article, so we first setup express 
    const express = require('express')
-Next we want to get our router from express and call as function which is going to give us a router that we can use to create views and using router.get('/') like that. But we need to tell the appl to use this router and in order to do that we need to exports this router 

const router = express.Router()
module.exports = router

So whenever we require this file we can actually read in this router, so if we go into our server.js we can just require this router which access articles from router
    const articleRouter = require('./routes/articles')
Now we have articlesouter which represents articles.js is now we have access to it in server.js file and tell our appl to use this router by app.use() and pass to articleRouter and also tell where our articleRouter to be based on,  because if we look our appl everything is /articles. So every route we create in this articleRouter is going to add at end of /articles 
    app.use('/articles', articleRouter)

- Now in article.js, we create route called "/" and we want to pass it in our request and response. For now we just send text called "In articles"
   router.get('/',(req, res) => {
      res.send('In articles')
   }) 
 
Now when we run localhost:5000/articles, now it will display "In articles"

7. In server.js, we are already rendering index, now we want to pass all of our articles to index page. In order to do that we just pass an object to our render as key value pairs and this will be avaliable in index.ejs
     res.render('articles/index', {articles:articles})  

   In index.ejs, we can render out that articles using javascript variables from Nodejs and print   
      <h1><%= articles %></h1>

   But as of now we dont have any articles, so we create variable called articles which is an array which needs title, date and description for each articles  
     let articles=[{
          title: 'Test Article',
          createdAt: new Date(),
          description: 'Test description'
     },
     {
          title: 'Test Article1',
          createdAt: new Date(),
          description: 'Test description1'
     }]

8. Next step we make index.ejs more clean using bootstrap

<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/css/bootstrap.min.css" integrity="sha384-Gn5384xqQ1aoWXA+058RXPxPg6fy4IWvTNh0E263XmFcJlSAwiGgFAW/dAiS6JXm" crossorigin="anonymous"> 

<div class="container">
  <h1 class="mb-4">Blog Articles</h1>
  <a href="/articles/new" class="btn btn-success">New Article</a>

<% articles.forEach(article => { %>
   <div class="card mt-4">
       <div class="card-body">
          <h4 class="card-title"><%= article.title %></h4>
          <div class="card-subtitle text-muted mb-2">
              <%= article.createdAt.toLocaleDateString() %>
          </div>
          <div class="card-text mb-2"><%= article.description %></div>
       </div>
   </div>
<% }) %>
</div>

Now when we save and run localhost:5000, it will display both article one by one 

9. Next we create new article route when we click New Article button. So inside article.js we create a route called "/new" and render a page inside articles/new 

router.get('/new', (req, res) => {
    res.render('articles/new')
})

10. Create new.ejs inside articles folder 

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/css/bootstrap.min.css" integrity="sha384-Gn5384xqQ1aoWXA+058RXPxPg6fy4IWvTNh0E263XmFcJlSAwiGgFAW/dAiS6JXm" crossorigin="anonymous">
    <title>Blog</title>
</head>
<body>
    <div class="container">
        New Article page
    </div>
</body>
</html>

When we run and click "New Article" button, it prints "New Article Page"

11. Create form_fields.ejs inside articles folder. 
<div class="form-group">
    <label for="title">Title</label>
    <input required  type="text" name="title" id="title" class="form-control">
  </div>
  <div class="form-group">
    <label for="description">Description</label>
    <textarea name="description" id="description" class="form-control"></textarea>
  </div>
  <div class="form-group">
    <label for="markdown">Markdown</label>
    <textarea required name="markdown" id="markdown" class="form-control"></textarea>
  </div>
  
  <a href="/" class="btn btn-secondary">Cancel</a>
  <button type="submit" class="btn btn-primary">Save</button>

12. Since "New Article" and "Edit" button is going to have same fields, instead of creating twice, we create single form_fields.ejs and include in other program. 
    Now we include in new.ejs using 

<div class="container">
            <h1 class="mb-4">New Article</h1>
        
            <form action="/articles" method="POST">
              <%- include('_form_fields') %>
            </form>
    </div>

When we run and click "New Articles" button it will go to new.ejs and render the form fields.

13. Now define route for "/articles" with POST request in articles.js, to save this articles to our database, so we need to hookup database to our appl.
   In server.js we will call mongoose library and using this we can connect to database 
   const mongoose = require('mongoose')
   mongoose.connect('mongodb://localhost/blog',{useNewUrlParser:true, useUnifiedTopology: true})

14. Create model where we store our articles, so create models folder, inside that create article.js
    First we import mongoose, next we create schema which contains all of the different columns our article has like title, description, markDown and createdAt , for each property we specify type and required. 
    const mongoose = require('mongoose')
    const articleSchema = new mongoose.Schema({
  title: {
    type: String,
    required: true
  },
  description: {
    type: String
  },
  markdown: {
    type: String,
    required: true
  },
  createdAt: {
    type: Date,
    default: Date.now
  }
})

In order to use this articleSchema, we need to export using mongoose.model() and we need to specify the model name (ie) Article and schema name called articleSchema

module.exports = mongoose.model('Article', articleSchema)

Now we have table in our database called Article with all of these columns specified 

15. Now we import articleSchema in articles.js using
        const Article = require('./../models/article')

Now we create new Article inside POST request and pass the different options, and in order to access the options from our form inside our post request, we need to tell express how to access them so in Server.js we want to tell our app to use
      app.use(express.urlencoded({extended:false})) 
which is used to access all of the different parameters from article form inside article route using "req.body.title" etc. Finally call article.save() to store the data and this is asynchronous function so we set this up inside our own async function and await article.save which is going to save our new article and return article with id. Then we redirect to particlar article based on id and if any error then it render new article page 

router.post('/', async(req,res) => {
   const article=new Article({
        title: req.body.title,
        description: req.body.description,
        markdown:req.body.markdown
   })
   try {
       article = await article.save()
       res.redirect(`/articles/${article.id}`)
   } catch(e) {
       res.render('articles/new', {article:article})
   }
})        

Now create route for page with particular article id
router.get('/:id', (req,res) => {

})

Now we save and run the appl and enter title, description after that if we click save button everything will be clear out

16. In order to prepopulate with the values of article, whatever the article we pass inside catch block to articles/new, we can use that article inside form_fields.ejs as  value attribute to prepopulate the values

 <input required value="<%= article.title %>" type="text" name="title" id="title" class="form-control">

<textarea name="description" id="description" class="form-control"><%= article.description %></textarea>

 <textarea  name="markdown" id="markdown" class="form-control"><%= article.markdown %></textarea>

When we run and input elements in title,description and click Save button, the data will be prepopulated but when we click Cancel button it will show an error, since we didnt pass article to "articles/new" request

17. So in article.js for "/new" request we pass the article 
router.get('/new', (req, res) => {
    res.render('articles/new',{article: new Article()})
})
When we run the appl and if we click "Cancel" button it will go to previous page

18.Now we create route "/:id" for newly created article, now we get article passed on id and render that article to new page called "articles/show" and pass the article which is newly created by querying our database by using findById() which is async function and we use await to make sure we way for this article. Before render this article we actually check whether article==null and if we cannot find article we redirect to home page 

router.get('/:id',async (req,res) => {
  const article = await Article.findById(req.params.id)
  if(article == null) res.redirect('/')
  res.render('articles/show',{article:article})
})

19. Now create show.ejs in articles folder


What is NodeJS?
     NodeJS is a runtime env for executing JS outside the browser, till 2009 JS can only be executed in the browser. The inventor of node Ryan Dahl introduce a new concept (ie) executing javascript program outside of the browser on any machine
      Till the node was released JS can only be executed on browsers, the browsers convert the JS code into low level machine code so the machine can understand it. There are different engines embedded into browsers to convert JS code into machine language, for example Microsoft Edge uses Chakra, Mozilla firefox uses Spider Monkey, Chrome uses V8 engine. Both ur browser and node run on v8 JS runtime engine 
    So Ryan Dahl comes with an idea to execute JS program outside of browser, so it took Google V8 engine and embedded it in C++ program and called that program as Node, v8 engine takes ur JS code and converted into faster machine code, so we can build
   1. Easy, fast and scalable appl
   2. Nodejs is open source cross platform runtime env which is written in JS, so until node was released if u wanted to be a fullstack developer we need to be good in atleast 2 languages JS on frontend and PHP or Ruby on backend. With Nodejs we can use JS also on server side 
   3. It has largest ecosystem of open source libraries, it has more than 3M open source libraries available to use
   4. Node also can use in prototyping and Agile development. Node also used in largest companies like Uber, Paypal, ebay and NASA etc
   5. Nodejs uses event driven, non blocking IO that makes it lightweight, efficient and highly scalable appl that run across distributed devices 


What is Node Js?
    - NodeJs is an env to run JS outside the browser (ie) it is JS runtime, it is not a lang or framework, so instead of JS running in browser env, it actually running on ur machine as service by using V8 JS engine which is same engine that Google Chrome uses
    - It is created in 2009 and it is built on top of Chrome's v8 JS engine, written in C++, as we know every browser has an engine, a tool that compiles our code down to machine code. And chrome uses one by the name of v8
    - Big community since it tremendously saves time on feature development 
    - We can develop both frontend and backend using JS

Why NodeJS?
    - Node is extremely fast efficient and also highly scalable because it is event driven and runs on a single loop  and it is non blocking 
    - Node is often used with frontend frameworks like react,vue and angular because it allows you to use the same lang on both sides 

Non blocking I/O
     - Node is non blocking and its async, it works on a single thread and uses non blocking io calls. Something like PHP is usually sync and it runs on multiple threads so every time a request is made it spawns a new thread and these threads takes up system memory and waits for one process to complete before starting the next
     - Node is non blocking and its async, it works on a single thread and this thread can literally support many connections which are held in event loop and this optimizes throughput and scalability in appl with many io operations   

Browser JS                                  NodeJS
1. DOM					1. No DOM
   - When we work with NodeJs we dont have access to browser API's so there is no DOM, no geolocation  

2. Interactive apps                     2. Server side apps
   - Unlike browser apps that are interactive for example user clicks the button or toggles the nav and that sort of thing with node we build server side apps. Our node app will consist of pure logic without the graphical interface

3. Window                             3. No window
     - On browser app we have many things available on window object, so no window object available in Node so we wont write any document methods in node 

4. No filesystem                      4. Filesystem
       - Unlike browser we can access file system (ie) info about OS, respond to network quests etc

5. Fragmentation                       5. Version
     - Node is based on versions, so unlike browser apps which depend on the user's browser. Our node app depends only on nodejs version it was built in (ie) if we build a browser app and if our users browser does not support a specific feature, it is our responsbility to fix it otherwise our app will have some bugs. But when we build node app there is no  rule that we need to upgrade to newer version 

6. ES6 modules                       6. Common JS
     - unlike browsers our modules are optional, in nodejs we have access to modules by default. Nodejs uses common js library for the modules 

Best types of projects for Node
    1. REST API & Microservices
    2. Real time services - Chat,Live updates
    3. Blogs, Shopping carts, Social Networks
    4. Anything that is not CPU intensive

https://github.com/john-smilga/node-express-course

NodeJS installation
1. Install node from nodejs.org/en/ - 14LTS or 15 current
    Always use LTS(Long term support) for prod since it provides long term support

2. >node --version

How to get node to evaluate our code?
    - Using 2 ways
     1. REPL(Read Eval Print Loop)
         - Open node terminal
         >node
           - Now we enter into REPL command 
         > const name="sam"
         > name
              - prints "sam"
     2. CLI - running our app code in node
        - Create a folder "node" and open in VS CODE
        - Create file app.js

const amount =12
if(amount < 10) {
    console.log('small amount')
} else {
    console.log('Large amount')
}
console.log('First node appl!!!')
   
    - To run the appl
   >node app.js

Global variables in node
    We have different global variables like
1. __dirname - path to current directory
2. __filename - file name
3. require -  which is a function to use modules 
4. module - gives info abt the current module
5. process - info about env where the program is being executed 
  We also have setInterval and setTimeout methods 

globals.js: 
console.log(__dirname)
setInterval(() => {
  console.log('hello world')
}, 1000)

>node globals.js
    - Now it will print hello world for every 1sec

Modules in Node
    - Consider we create app.js where we invoke sayHi()

const john='john'
const peter='peter'

const sayHi=(name) => {
     console.log('Hello there ${name}')
}

sayHi('Jam')
sayHi(john)
sayHi(peter)

>node app.js

It makes sense if the names would be separate, as well as functions or future functions that we create would be in separate files and access them all throughout the appland that is exactly wht modules allows to do 
   So modules are encapsulated code which shares only minimum code. Node uses CommonJS library underhood so every file in node is a module 

1. Create names.js, so if we want to access this module throughout the appl then we need to export it 
// local
const secret = 'SUPER SECRET'
// share
const john = 'john'
const peter = 'peter'

module.exports = { john, peter }

2. Create utils.js
const sayHi = (name) => {
  console.log(`Hello there ${name}`)
}
module.exports = sayHi

3. In app.js we need to access them using require 

const names = require('./names') //always start with ./
const sayHi = require('./utils')

sayHi('susan')
sayHi(names.john)
sayHi(names.peter)

>node app.js

4. Create alternate.js
      - We create items and object called person
module.exports.items = ['item1', 'item2']
const person = {
  name: 'bob',
}

module.exports.singlePerson = person

5. Now we call alternate.js inside app.js

const names = require('./names') //always start with ./
const sayHi = require('./utils')
const data = require('./alternate')
console.log(data)
sayHi('susan')
sayHi(names.john)
sayHi(names.peter)

>node app.js

6. Create another.js with some basic functionality

const num1 = 5
const num2 = 10

function addValues() {
  console.log(`the sum is : ${num1 + num2}`)
}

addValues()

7. Now call this js file inside app.js

const names = require('./names') //always start with ./
const sayHi = require('./utils')
const data = require('./alternate')
require('./another')

>node app.js
    - It prints the output of another.js, so if we set any function inside the module and we invoke that function, it will be execute eventhough we didnt assign to variable and when we import any module using require() it actually invoke the reason is because another.js is not just exported on its own, when the node exports it actually wraps it in the function 

Built in modules
1. OS
2. PATH
3. FS
4. HTTP

1. OS modules
      - provides with properties and methods for interacting with OS as well as server

const os = require('os')

// info about current user
const user = os.userInfo()
console.log(user)

// method returns the system uptime in seconds
console.log(`The System Uptime is ${os.uptime()} seconds`)

const currentOS = {
  name: os.type(),
  release: os.release(),
  totalMem: os.totalmem(),
  freeMem: os.freemem(),
}
console.log(currentOS)

Path module
   - which allows to interact with file paths 

const path = require('path')

console.log(path.sep) //retuns platform specific separator, in this case it returns /


//joins sequence of path segments using platform specific separator and returns normalized resulting path. Create "content" folder, inside that create "subfolder" folder and inside that create test.txt file with some content 
const filePath = path.join('/content/', 'subfolder', 'test.txt')   
console.log(filePath)  /content/subfolder/test.txt

const base = path.basename(filePath)  //returns file name
console.log(base)  //test.txt

//resolve() returns absolute path
const absolute = path.resolve(__dirname, 'content', 'subfolder', 'test.txt')
console.log(absolute)

File System module
   - used to interact with file system, we have 2 types when it comes to file module (ie) we can do async non blocking or sync blocking 

fs_sync.js

const { readFileSync, writeFileSync } = require('fs')
console.log('start')

//create first.txt and second.txt with some content inside content folder
//readFileSync is used to read file with 2 parameters, we need to provide a path to that specific file and what is the encoding so the node knows how to decode the files 
const first = readFileSync('./content/first.txt', 'utf8')
const second = readFileSync('./content/second.txt', 'utf8')

//writeFileSync is used to write to file, where we provide two args, one is filename if the file is not there node will create that file and if it is already existing it will override and second arg is the value that we want to pass. In case if we want to append the data into file then we pass an object with propertyname as flag and value as "a"
writeFileSync(
  './content/result-sync.txt',
  `Here is the result : ${first}, ${second}`,
  { flag: 'a' }
)
console.log('done with this task')
console.log('starting the next one')
 

fs_async.js - readFile and writeFile for async one, we need to provide callback which will be run once our functionality is completed 

const { readFile, writeFile } = require('fs')

console.log('start')

//In readFile() we pass file path to be read and then callback function which takes 2 arguments err and result 
readFile('./content/first.txt', 'utf8', (err, result) => {
  if (err) {
    console.log(err)
    return
  }
  const first = result
  readFile('./content/second.txt', 'utf8', (err, result) => {
    if (err) {
      console.log(err)
      return
    }
    const second = result
    writeFile(
      './content/result-async.txt',
      `Here is the result : ${first}, ${second}`,
      (err, result) => {
        if (err) {
          console.log(err)
          return
        }
        console.log('done with this task')
      }
    )
  })
})
console.log('starting next task')

Callback are little messy so alternatives are using promises or async await 

HTTP module
    - used to setup our web server and setting up the api. Later we use an abstraction on top of the http module which is Express 

http.js

const http = require('http')

//We use createServer() with callback function, in that callback function we have 2 parameters and both are objects, the first parameter represents the incoming request and response is whate we are sending back. Finally we use listen() where our server is going to listen to a port number
   Next we have res.write() to write the response and once we want to end the request we use res.end()

const server = http.createServer((req, res) => {
    console.log(req)
    res.write('Welcome to web page')
    res.end()
})

server.listen(5000)

>node http.js
    
Run localhost:5000 in browser to see the output and in console we see many properties of req object, we need to use "url" property to return the endpoint the client is requesting 

const server = http.createServer((req, res) => {
    if (req.url === '/') {
    res.end('Welcome to our home page')
  } else if (req.url === '/about') {
    res.end('Here is our short history')
  } else {
    res.end(`
    <h1>Oops!</h1>
    <p>We can't seem to find the page you are looking for</p>
    <a href="/">back home</a>
    `)
  }
})

NPM 
   - Consider we are building an app with some slider, at this point we have 2 options either build it own ur own or search google and copy paste someones solution. Someone somewhere already faced issue in developing the slider so they have finally created and shared thier code.
    Now with the help of one command we can just add it to our project because when we install node we automatically also install npm which enables us to do 3 things
   1. reuse our own code in other projects
   2. use code written by other developers 
   3. share our own solutions with other developers 

>npm --v

We can install package as local dependency so we use that package only in that particular project 
   >npm i <packagename>

We can install dependency as globally and use it in other projects too
   >npm install -g <packagename>

package.jsp - manifest file which stores important info about project/package - 3 ways to create
   1. manual approach 
   2. npm init (step by step,press enter to skip)
   3. npm init -y (everything default)

Step 1:  >npm init -y
   - Creates package.json

Why package.json?
    If we install the package, then it will stored inside the file as dependency inside package.json

Step 2: >npm i lodash
     - lodash is utility library which will be installed in dependencies section in package.json file 
     - node-modules folder in which all the dependency will be stored 
     - >npm i bootstrap
      Now when we install bootstrap package then we can see jquery as well as popper.js also installed as dependency 

app.js

const _ = require('lodash')

const items = [1, [2, [3, [4]]]]
const newItems = _.flattenDeep(items)
console.log(newItems)

Sharing code
   - We share the code into Github repo without node_modules 
   - First we create .gitignore file and define 
        /node_modules
so it wont push this folder inside github 

>git init
>git add .
>git commit -m "Initial message"
>git remote add origin "giturl"
>git push -u origin master 

   - Next someone can download the code from github and they can run 
   >npm install 
so npm will check for dependencies that we have in package.json and automatically setup the node-modules folder 

   - Nodemon is not used in production but in dev env we use nodemon to restart the appl so we add in dev dependencies. We also add testing,linting, formatting packages etc to dev dependencies
      > npm i nodemon --save-dev 
So while sharing the code we just share the dependencies that app is using not the one we used while developed the app

    - Now we change in scripts to run the appl
"scripts" : {
    "start": "nodemon app.js"
 }
    - Now instead of running "node app.js" we can run as
     > npm start 

package-lock.json
   - If we see dependencies we have versions, and some of the dependencies have dependencies on their own, for example person who gets ur project you probably want them to have the same exact setup, so if version changes for some dependency then ur project becomes obsolete so we may get some bugs since version is changing
   - So package-lock.json will contain specific version for all the packages, not only for dependencies but also for the package that dependency is using 
    Now as far as this version we have 3 values, the first number is major change so when this changes that means ther are some breaking changes, second one is minor one so it is backward compatible and last one is just a patch for bug fix


Event loop
    - It allows nodejs to perform nonblocking input and output operations inspite of JS is single threaded by offloading operations to the system kernel whenever possible 

1. Javascript is sync and single threaded

console.log("first task")
console.time()
for(let i=0;i<10000000;i++) {
  const h3=document.querySelector('h3')
  h3.textContent='Hey everyone is waiting'
}
console.timeEnd()
console.log("Next Task")

JS reads everything line by line

2. offload something to browser

console.log("First task")
setTimeout(() => {
   console.log("second task")
}, 0)

console.log("next task")

Here we can offload the task to the browser and only when the task is done then we execute the callback 

   Consider we have an app, it has users and the user is requesting something from the appl and as the requests are coming in, the event loop is responsible for avoiding this type of scenarios. Lets imagine all the users requests are coming in but one user decides that his request thereis going to be time consuming database call,so we need to perform something that takes a long time. So in this case the event loop just registers the callback, so it registers what need to be done when the task is complete because if the event loop wouldnt do that, then we have scenario where the requests are coming in and because user1 is requesting something that takes a long time, the rest of the users would have to wait and its not that actual operation takes long time, its just the fact that we are wasting our time on waiting for that operation to  be done and only then we serve the other users 
    But event loop registers the callback and only when the operation is complete it executes 

1. readFile.js - async version of read file 

const { readFile, writeFile } = require('fs')

console.log('started a first task')
// CHECK FILE PATH!!!!
readFile('./content/first.txt', 'utf8', (err, result) => {
  if (err) {
    console.log(err)
    return
  }
  console.log(result)
  console.log('completed first task')
})
console.log('starting next task')

>node read-file.js
started a first task
starting next task
Hello from file
completed first task

readFile() is async, so event loop will offload this in file system,so we start reading the file then offload the response and only when u get back the result then run the callback, so whether the response is error or success only then we invoke the callback 

2. setTimeout.js

// started operating system process
console.log('first')
setTimeout(() => {
  console.log('second')
}, 0)
console.log('third')
// completed and exited operating system process

Since setTimeout() is async so they get offloaded 

3. setInterval() is async and the difference between setTimeout and setInterval is setInterval runs in those increment in this case 2sec, so every 2sec event loop will invoke callback  

setInterval(() => {
  console.log('hello world')
}, 2000)
console.log(`I will run first`)
// process stays alive unless
// Kill Process CONTROL + C
// unexpected error

4. server.js

const http = require('http')

const server = http.createServer((req, res) => {
  console.log('request event')
  res.end('Hello World')
})

server.listen(5000, () => {
  console.log('Server listening on port : 5000....')
})

So when we run localhost:5000, whenever request comes it will invoke callback and prints "request event" in console, here listen() is async and when we set it up, event loop is waiting for those requests to come in and once they come we run our callback 

Asynchronous patterns in Nodejs
      In file system we discuss about sync and async, while async one is great since we are not blocking the event loop, the problem is if we use callback approach it is messy since we nesting one callback into another 

1. Block.js

const http = require('http')

const server = http.createServer((req, res) => {
  if (req.url === '/') {
    res.end('Home Page')
  }
  if (req.url === '/about') {
    // blocking code
    for (let i = 0; i < 1000; i++) {
      for (let j = 0; j < 1000; j++) {
        console.log(`${i} ${j}`)
      }
    }
    res.end('About Page')
  }
  res.end('Error Page')
})

server.listen(5000, () => {
  console.log('Server listening on port : 5000....')
})

Incase we kept some blocking code (ie) nested for loop, so if the user navigate to "/about" it gets blocked since we need to wait for some time to complete the loop and if we run other request also it will be blocked, so only loop is finished it will be execute other request, so ur code is messy 

2. example.js

const { readFile } = require('fs')

readFile('./content/first.txt','utf8',(err,data) => {
    if(err) {
       return
    } else {
       console.log(data)
    }
})

Here it prints the data from the file, but the problem starts if we want to perform multiple actions, so if we want to read two files and write into one, so the better soltion is turning the above code into promises and setup async await 

Create getText() which takes path, since we want to read two files and write into one, which returns Promise an dinside promise return another callback function, inside which we pass 2 more function called resolve and reject 

const { readFile } = require('fs')

const getText = (path) => {
   return new Promise((resolve, reject) => {
     readFile(path, 'utf8', (err, data) => {
       if (err) {
         reject(err)
       } else {
         resolve(data)
       }
     })
  })
 }
getText('./content/first.txt')
   .then((result) => console.log(result))
   .catch((err) => console.log(err))

Once we have turned out into a promise technically we are not out of woods because if we want to read 2 files and write into one and if we want to do all of that async its still going to be messy by using promises, so better solution to use async await then we can wait until promise is settled.
   Now use a wrapping function to return as promise by using util module

const { readFile, writeFile } = require('fs') 
const util = require('util')
const readFilePromise = util.promisify(readFile)
const writeFilePromise = util.promisify(writeFile)

const start = async () => {
  try {
    const first = await readFilePromise('./content/first.txt', 'utf8')
    const second = await readFilePromise('./content/second.txt', 'utf8')
    await writeFilePromise(
      './content/result-mind-grenade.txt',
      `THIS IS AWESOME : ${first} ${second}`,
      { flag: 'a' }
    )
    console.log(first, second)
  } catch (error) {
    console.log(error)
  }
}

start()

Now in order to make it simple, we can make fs module to return promises by using 

const { readFile, writeFile } = require('fs').promises 

const start = async () => {
  try {
    const first = await readFile('./content/first.txt', 'utf8')
    const second = await readFile('./content/second.txt', 'utf8')
    await writeFile(
      './content/result-mind-grenade.txt',
      `THIS IS AWESOME : ${first} ${second}`,
      { flag: 'a' }
    )
    console.log(first, second)
  } catch (error) {
    console.log(error)
  }
}

start()


Events in NodeJS
    When working with browser JS apps, a big part of our work is to handle events, for example user clicks a button, users hovers over the link etc. Essentially as outr prg executes at least in part it is controlled by events so that style of programming is actually called event driven programming
    Event driven programming is heavily used in nodejs (ie) we listen for specific events and register functions that will execute in response to those events, so once our event takes place callback function is called

Nodes Event loop
     - It is single threaded and events are run asynchronously 
     - When an event is triggered a callback fires so this way the system dosent have to run a process and wait for it to end and then run the next like in many sync appl
     - Event Emitter class is used to bind events and listeners 

event-emitter.js

//create variable EventEmitter which is essentially a class which requires events module
const EventEmitter = require('events')

//create custom event by creating instance of EventEmitter 
const customEmitter = new EventEmitter()

//we have many methods for this object like on - listen for an event, emit - emit an event 

//we use on() which passes string (ie) name of the event and 2nd args as callback function
customEmitter.on('response', () => {
  console.log('Data received')
})

//Next we emit the event using emit() with event name
customEmitter.emit('response')

>node event-emitter.js
Data received

2. event-emitter1.js - We can emit the same event multiple times and do some other logic

const EventEmitter = require('events')
const customEmitter = new EventEmitter()

customEmitter.on('response', () => {
  console.log('Data received')
})

customEmitter.on('response', () => {
  console.log('some other logic here')
})
customEmitter.emit('response')


3. event-emitter2.js - order of methods is important, first we listen to event then emit the event 

const EventEmitter = require('events')
const customEmitter = new EventEmitter()

customEmitter.on('response', () => {
  console.log('Data received')
})

customEmitter.emit('response')

customEmitter.on('response', () => {
  console.log('some other logic here')
})

>node event-emitter3.js
Data received

4. event-emitter4.js - we can pass the arguments when we emitting the event 

const EventEmitter = require('events')
const customEmitter = new EventEmitter()

customEmitter.on('response', (name, id) => {
  console.log(`data recieved user ${name} with id:${id}`)
})

customEmitter.on('response', () => {
  console.log('some other logic here')
})

customEmitter.emit('response', 'john', 34)

5. request-event.js

const http = require('http')

//creating server using callback function
// const server = http.createServer((req, res) => {
//   res.end('Welcome')
// })

// Using Event Emitter API
const server = http.createServer()
// emits request event
// subcribe to it / listen for it / respond to it
server.on('request', (req, res) => {
  res.end('Welcome')
})

server.listen(5000)

Streams
   - used to read and write sequentially, basically when we want to handle and manipulate streaming data, for example continuous source or big file, streams come into picture
   - 4 types of streams
     1. writeable - used to write data sequentially
     2. Readable - used to read data sequentially
     3. Duplex - used to both read and write data sequentially 
     4. Transform - where data can be modified when reading or writing 

   - Streams extend EventEmitters class which simply means that we can use events like data on streams 
   - A good usecase of using Streams when we are reading files, when we use sync or async approach we are reading the whole file and assign to variable, but if we have a big file first we use all that memory and second as the file size gets bigger eventually the variables are not going to be good enough so we get error that size is too big, so the solution would be stream option 

1. create-big-file.js
We create a big file, for every iteration we create big text with flag append and adding "Hello world"

const { writeFileSync } = require('fs')
for (let i = 0; i < 10000; i++) {
  writeFileSync('./content/big.txt', `hello world ${i}\n`, { flag: 'a' })
}

>node create-big-file.js

Once we got big file, we use streams to read it

2. Stream.js

const { createReadStream } = require('fs')
const stream = createReadStream('./content/big.txt')

// default 64kb
// last buffer - remainder
// highWaterMark - control size
// const stream = createReadStream('./content/big.txt', { highWaterMark: 90000 }) - when we go for this we can see 2 console log, one 90 bytes and other is remainder 
// const stream = createReadStream('../content/big.txt', { encoding: 'utf8' }) - when we set encoding we get original text 

stream.on('data', (result) => {
  console.log(result)
})
stream.on('error', (err) => console.log(err))

>node Stream.js

Here we are reading data in chunks and by default that chunk is 64kb and everytime we console log we see that we have 64 and eventually we have the remainder, so instead of reading everything and placing that in variable we are doing that in chunks

3. big-file.js
       - Now we create very big file 

const { writeFileSync } = require('fs')
for (let i = 0; i < 1000000; i++) {
  writeFileSync('./content/big.txt', `hello world ${i}\n`, { flag: 'a' })
}

>node big-file.js

2. http-stream.js
      - Creating a http server and we use the readFileSync() and looking for big.txt with encoding utf-8 

var http = require('http')
var fs = require('fs')

http
  .createServer(function (req, res) {
     const text = fs.readFileSync('./content/big.txt', 'utf8')
     res.end(text)
})
.listen(5000)

>node http-stream.js and run locakhost:5000
      - Now we can see bunch of "Hello World", but the problem goto Inspect - Network - Refresh the page we can see the request was successful but size is high which is very difficult for all ur users because we are sending large chunks of data
       Click localhost - Headers - Content-length - we can see 1.8mbs, once we refractor to readStream() which sends the data in chunks 


http-stream1.js

var http = require('http')
var fs = require('fs')

http
  .createServer(function (req, res) {
    // const text = fs.readFileSync('./content/big.txt', 'utf8')
    // res.end(text)
    const fileStream = fs.createReadStream('./content/big.txt', 'utf8')

//we have access to events using on()
    fileStream.on('open', () => {
      fileStream.pipe(res) //this method will pushing fron read stream into write stream (ie) if we can read data in chunks we can also write data in chunks 
    })
    fileStream.on('error', (err) => {
      res.end(err)
    })
  })
  .listen(5000)

>node http-stream1.js and run locakhost:5000
      - Now we can see bunch of "Hello World", goto Inspect - Network - Click localhost - Headers - we cant see content-length instead we can see our response headers are chunked , so instead of sending our file in one large instance we can sending back in chunks 


HTTP messages
     Everytime we opens a browser and we type the url (ie) web address, we actually performing a request to server which is responsible for serving those resources. For example when you look for google.com, u r looking for server that has those resources and then that server sends you back the response which is done using HTTP protocol and they are called HTTP messages, so the user sends hhtp request message and then the server sends http response message 
    Both request and response have a start line, optional headers and optional body. So request messages are what the user is sending (ie) open a browser to search the web or ur web appl. Next we have to set proper server that sends a correct response 

Express JS

1. https://github.com/john-smilga/node-express-course

2. Create the project 

3. >npm start 

4. http-basic.js
        - create server using basic http module

const http = require('http')

const server = http.createServer((req, res) => {
  // console.log(req.method)
  const url = req.url
  // home page
  if (url === '/') {
    res.writeHead(200, { 'content-type': 'text/html' })
    res.write('<h1>home page</h1>')
    res.end()
  }
  // about page
  else if (url === '/about') {
    res.writeHead(200, { 'content-type': 'text/html' })
    res.write('<h1>about page</h1>')
    res.end()
  }
  // 404
  else {
    res.writeHead(404, { 'content-type': 'text/html' })
    res.write('<h1>page not found</h1>')
    res.end()
  }
})

server.listen(5000)

2. http-app.js
         - Instead of setting the contents, if we want any files to be invoked and to implement css, logo and logic using js for the same html files

const http = require('http')
const { readFileSync } = require('fs')

// get all files
const homePage = readFileSync('./navbar-app/index.html')
const homeStyles = readFileSync('./navbar-app/styles.css')
const homeImage = readFileSync('./navbar-app/logo.svg')
const homeLogic = readFileSync('./navbar-app/browser-app.js')

const server = http.createServer((req, res) => {
  // console.log(req.method)
  const url = req.url
  console.log(url)
  // home page
  if (url === '/') {
    res.writeHead(200, { 'content-type': 'text/html' })
    res.write(homePage)
    res.end()
  }
  // about page
  else if (url === '/about') {
    res.writeHead(200, { 'content-type': 'text/html' })
    res.write('<h1>about page</h1>')
    res.end()
  }
  // styles
  else if (url === '/styles.css') {
    res.writeHead(200, { 'content-type': 'text/css' })
    res.write(homeStyles)
    res.end()
  }
  // image/logo
  else if (url === '/logo.svg') {
    res.writeHead(200, { 'content-type': 'image/svg+xml' })
    res.write(homeImage)
    res.end()
  }
  // logic
  else if (url === '/browser-app.js') {
    res.writeHead(200, { 'content-type': 'text/javascript' })
    res.write(homeLogic)
    res.end()
  }
  // 404
  else {
    res.writeHead(404, { 'content-type': 'text/html' })
    res.write('<h1>page not found</h1>')
    res.end()
  }
})

server.listen(5000)


Express JS
    - It is minimal and flexible nodejs web app framework  designed to make developing websites or webapps or apis much faster and easier 
    - Express is a server side or back end framework, it can be used in combination with those frameworks to build full stack appl. Many times we build out API with Express so that it takes requests from the front end and then it serves back data usually in JSON format 
    - We can also render views with express using either just plain HTML or using template engine like Handlebars or Pug

>npm install express@4.17.1 --save

Basic Server syntax:
const express = require("express");
//Initialize express
const app=express();

//create ur endpoints
app.get("/", function(req,res) {
     res.send("Hello");
}

//listen on port
app.listen(5000);

   - So within the route u can fetch data from database like MongoDB, Postgress, MySQL etc where u can load pages, return JSON data, full access to request and response object. The request object represents the HTTP request properties like URL parameters, query strings, data send within body, HTTP headers 
   - Response object represents HTTP response and used to send back ur JSON date and render a template
   - We dont want to put all files in one file, Express has router so we can store routes in separate files and export it 


Express Middlewares
   - Middleware functions are functions that have access to request and response object. Express has built in middleware as well as comes form 3rd party packages.
   - Execute any code
   - Make changes to the request and response
   - End response cycle
   - Call next middleware in the stack

    
3.express-basic.js
     - It is very less code than using builtin http module

const express = require('express')
const app = express()

app.get('/', (req, res) => {
  console.log('user hit the resource')
  res.status(200).send('Home Page')
})

app.get('/about', (req, res) => {
  res.status(200).send('About Page')
})

app.all('*', (req, res) => {
  res.status(404).send('<h1>resource not found</h1>')
})

app.listen(5000, () => {
  console.log('server is listening on port 5000...')
})

// app.get
// app.post
// app.put
// app.delete
// app.all - it works with all of them mainly used to display error pages
// app.use - responsible for middleware 
// app.listen


4. express-app.js
      - When we give get request we need to send back "index.html" for that we use sendFile() comes with express. We need to provide absolute path so we need to use "path" module with path.resolve()
        
const express = require('express')
const path = require('path')

const app = express()

app.get('/', (req, res) => {
  res.sendFile(path.resolve(__dirname, './navbar-app/index.html'))
})

app.all('*', (req, res) => {
  res.status(404).send('resource not found')
})

app.listen(5000, () => {
  console.log('server is listening on port 5000....')
})

>npm start and run localhost:5000/ again we get index.html without any css, logos etc

   So in express we can define use() and point to folder called public or navbar-app also. Now copy css,logo and js file into public folder

const express = require('express')
const path = require('path')

const app = express()

// setup static and middleware
app.use(express.static('./public'))

app.get('/', (req, res) => {
  res.sendFile(path.resolve(__dirname, './navbar-app/index.html'))
})

app.all('*', (req, res) => {
  res.status(404).send('resource not found')
})

app.listen(5000, () => {
  console.log('server is listening on port 5000....')
}) 


>npm start and run localhost:5000/ again we get complete index.html with all css, logos etc

So any static asset where the server dosent need to change it, we place it in folder like public or static, so express will take care of them, it will set up path, mime types, status code 
  
5. all-static.js
       - Here even index.html is consider as static asset, so even we can move it inside public folder. So inder.html is always going to be root so when user hits the server, by default server will serve index.html

const express = require('express')
const path = require('path')

const app = express()

// setup static and middleware
app.use(express.static('./public'))

app.all('*', (req, res) => {
  res.status(404).send('resource not found')
})

app.listen(5000, () => {
  console.log('server is listening on port 5000....')
})

>npm start and run localhost:5000/ again we get complete index.html with all css, logos etc


Express JS - API vs SSR
     When it comes to express we use to set up API or templates with Server Side Rendering
     In express or http case when we talk about api, we mean setting up an HTTP interface to interact with our data, now data is sent using json and in order to send back our response we use res.json() which sets proper content type and stringify our data 
     Next we have Server Side Rendering where we will setup templates and send back entire html,css,js using res.render()

API                                       SSR
1. API - JSON                      1. SSR - Template
2. Send data                       2. Send template
3. res.json()                      3. res.render()


6. basic-json.js

const express = require('express')
const app = express()
app.get('/', (req, res) => {
  res.json([{name:'john'},{name:'Jim'}])
})

app.listen(5000, () => {
  console.log('Server is listening on port 5000....')
})

Now it will fecth all info as json when we run localhost:5000/

data.js
const products = [
  {
    id: 1,
    name: 'albany sofa',
    image:
      'https://dl.airtable.com/.attachments/6ac7f7b55d505057317534722e5a9f03/9183491e/product-3.jpg',
    price: 39.95,
    desc: `I'm baby direct trade farm-to-table hell of, YOLO readymade raw denim venmo whatever organic gluten-free kitsch schlitz irony af flexitarian.`,
  },
  {
    id: 2,
    name: 'entertainment center',
    image:
      'https://dl.airtable.com/.attachments/da5e17fd71f50578d525dd5f596e407e/d5e88ac8/product-2.jpg',
    price: 29.98,
    desc: `I'm baby direct trade farm-to-table hell of, YOLO readymade raw denim venmo whatever organic gluten-free kitsch schlitz irony af flexitarian.`,
  },
  {
    id: 3,
    name: 'albany sectional',
    image:
      'https://dl.airtable.com/.attachments/05ecddf7ac8d581ecc3f7922415e7907/a4242abc/product-1.jpeg',
    price: 10.99,
    desc: `I'm baby direct trade farm-to-table hell of, YOLO readymade raw denim venmo whatever organic gluten-free kitsch schlitz irony af flexitarian.`,
  },
  {
    id: 4,
    name: 'leather sofa',
    image:
      'https://dl.airtable.com/.attachments/3245c726ee77d73702ba8c3310639727/f000842b/product-5.jpg',
    price: 9.99,
    desc: `I'm baby direct trade farm-to-table hell of, YOLO readymade raw denim venmo whatever organic gluten-free kitsch schlitz irony af flexitarian.`,
  },
]
module.exports = { products }

We have data.js is simple file with some array of products and peoples, then exports those arrays

const express = require('express')
const app = express()
app.get('/', (req, res) => {
  res.json(products)
})

app.listen(5000, () => {
  console.log('Server is listening on port 5000....')
})


7.params-query.js

const express = require('express')
const app = express()
const { products } = require('./data')

app.get('/', (req, res) => {
  res.send('<h1> Home Page</h1><a href="/api/products">Products</a>')
})
app.get('/api/products', (req, res) => {
  const newProducts = products.map((product) => {
    const { id, name, image } = product
    return { id, name, image }
  })

  res.json(newProducts)
})

app.listen(5000, () => {
  console.log('Server is listening on port 5000....')
})

When we click "Products" link, it has to fetch all products from data.js file. Here when we requesting bunch of data we are not always returning everything for one specific product, so we want to send back some minimal response.
   So here we iterate over product using map() and remove the description from product array 

To fetch single product based on id:

app.get('/api/products/:productID', (req, res) => {
  // console.log(req)
  // console.log(req.params) //returns all parameters 
  const { productID } = req.params

//route parameter will always return as string
  const singleProduct = products.find(
    (product) => product.id === Number(productID)
  )
  if (!singleProduct) {
    return res.status(404).send('Product Does Not Exist')
  }

  return res.json(singleProduct)
})

So when we use route parameters think of them as placeholders where user provides data and using req and req.params we can access that data 

Search and Sort the data:
   Whatever we are passing as query parameter we can get using req.query

app.get('/api/v1/query', (req, res) => {
  // console.log(req.query)
  const { search, limit } = req.query //storing query parameter in search and limit variable
  let sortedProducts = [...products]  //imported the product and assigned

//retrieve the data based on search value
  if (search) {
    sortedProducts = sortedProducts.filter((product) => {
      return product.name.startsWith(search)
    })
  }

//limit the values
  if (limit) {
    sortedProducts = sortedProducts.slice(0, Number(limit))
  }

//If search criteria dosent match, then we are not sending 404 error status, instead we send the product dosent match or we can send json object with success key and empty array as value
  if (sortedProducts.length < 1) {
    // res.status(200).send('no products matched your search');
    return res.status(200).json({ success: true, data: [] })
  }
  res.status(200).json(sortedProducts)
})

Run as localhost:5000/api/v1/query?search=a&limit=2
    Now we filter the products starts with "a" and printing only 2 values


Middleware in ExpressJS
     - Middleware are functions that execute during the request to the server. Each middleware function has access to request and response objects 

1. middleware-basic.js
     - Middleware sits inbetween request and response
     - we have "/" and "/about" routes, we just want to log the method that the user is using the url. So if we go with logger and setup that functionality in home page we also have to do that in about page also.
     - Each time when we run localhost:5000/, it will print method, url and time. But the problem is if we need same functionality in "about" route then we have to paste the same code in all route 

const express = require('express')
const app = express()

app.get('/', logger, (req, res) => {
  const method=req.method
  const url=req.url
  const time=new Date().getFullYear()
  console.log(method,url,time)
  res.send('Home')
})
app.get('/about', logger, (req, res) => {
  res.send('About')
})

app.listen(5000, () => {
  console.log('Server is listening on port 5000....')
})

The better solution is if we setup function and in that function we have all this logic and then we can attach it to all routes. So in between the route and callback functon we can define the middleware and express will pass req, res and next to middleware function 
   - When we work with middleware then u must pass it on to a next middleware unless u r terminating the whole cycle by sending back the response using next()

const express = require('express')
const app = express()

//  req => middleware => res

const logger = (req, res, next) => {
  const method = req.method
  const url = req.url
  const time = new Date().getFullYear()
  console.log(method, url, time)
  next()
}

app.get('/', logger, (req, res) => {
  res.send('Home')
})
app.get('/about', logger, (req, res) => {
  res.send('About')
})

app.listen(5000, () => {
  console.log('Server is listening on port 5000....')
})

2. Instead of defining logger middleware in js prg, we can define logger function separately 
   If we have 50 routes, instead of adding logger middleware in each route manually, so we can have a method that could adds middleware function to add any route 

- Create logger.js and export it 

const logger = (req, res, next) => {
  const method = req.method
  const url = req.url
  const time = new Date().getFullYear()
  console.log(method, url, time)
  next()
}
module.exports=logger

2. Create authorize.js and export it

const authorize = (req,res,next) => {
      console.log("authorize")
      next()
}
module.exports=authorize


3. express-app.js
       - import the logger so that we can access the middleware from outside
       - Instead of defining the middleware manually in each route, we can use app.use() to define the middleware in all route
       - Here order also matters, where we define app.use() below what routes are there it will be applicable to those routes only
       - If u need to apply the middleware only to particular routes we can give as 
           app.use("/api",logger)
       - To access multiple middleware we can simply use an array and they will be executed in the order of placing in array  

const express = require('express')
const app = express()
const logger = require('./logger')
const authorize = require('./authorize')
//  req => middleware => res
app.use([logger, authorize])
// api/home/about/products
app.get('/', (req, res) => {
  res.send('Home')
})
app.get('/about', (req, res) => {
  res.send('About')
})
app.get('/api/products', (req, res) => {
  res.send('Products')
})
app.get('/api/items', (req, res) => {
  console.log(req.user)
  res.send('Items')
})

app.listen(5000, () => {
  console.log('Server is listening on port 5000....')
})


3. Now to authorize the user using query string 
          If user provides a query string in url then we will send back the resource that the user is requesting and if user dosent provide the query string then we send 401 error
          Even we can access certain properties from middleware to any routes

authorize.js

const authorize = (req,res,next) => {
      const { user } = req.query
      if(user === 'john') {
          req.user={ name: 'john', id: 3}
          next()
      } else  {
          res.status(401).send('Unauthorized')
      }
}
module.exports=authorize

middlware-options.js

const express = require('express')
const app = express()

const logger = require('./logger')
const authorize = require('./authorize')

app.use([logger, authorize])

app.get('/api/items', (req, res) => {
  console.log(req.user)
  res.send('Items')
})

app.listen(5000, () => {
  console.log('Server is listening on port 5000....')
})

Now run as localhost:5000/api/items?user=john, it will print the values from authorized middleware
    If we run localhost:5000/ without query string it will print as Unauthorized


4. Express is used 
      - to access our own middleware like logger, authorize etc
        app.use([logger, authorize])
      - Express also provides with inbuilt middleware called static where it is use to access static files in public folder
        app.use(express.static('./public'))
      - Express also provides to access 3rd party middleware
      - We have to install 3rd party middleware like morgan. 
            >npm in morgan
and use into the program
      - Here we use only morgan for all routes 

middleware-options.js

const express = require('express')
const app = express()
const morgan = require('morgan')

app.use(morgan('tiny'))

app.get('/', (req, res) => {
  res.send('Home')
})
app.get('/about', (req, res) => {
  res.send('About')
})
app.get('/api/products', (req, res) => {
  res.send('Products')
})
app.get('/api/items', (req, res) => {
  console.log(req.user)
  res.send('Items')
})

app.listen(5000, () => {
  console.log('Server is listening on port 5000....')
})

So when we run any request it will provide the total ms to execute that request 


GET Http methods

const express = require('express')
const app = express()
let { people } = require('./data')

app.get('/api/people', (req, res) => {
  res.status(200).json({ success: true, data: people })
})

Run localhost:5000/api/people - it will display all peoples in json format

POST http method - to insert data 

1. create methods-public with all html forms and css files

const express = require('express')
const app = express()
let { people } = require('./data')

// static assets
app.use(express.static('./methods-public'))
// to access form data we have express middleware urlencoded and using req.body we can access form body 
app.use(express.urlencoded({ extended: false }))

app.post('/login', (req, res) => {
  const { name } = req.body
  if (name) {
    return res.status(200).send(`Welcome ${name}`)
  }

  res.status(401).send('Please Provide Credentials')
})

Run localhost:5000/index.html, it will provide with form and click submit means it call "/login" and prints name if not it provide 401 message 


Express Router
     If we have more routes and more functionality then app.js will become more busy, so we can use express router where we can grouo those routes together and then as far as the functionality will set them as separate controllers 

router-app.js - configures all routes

const express = require('express')
const app = express()

const people = require('./routes/people')
const auth = require('./routes/auth')

// static assets
app.use(express.static('./methods-public'))
// parse form data
app.use(express.urlencoded({ extended: false }))
// parse json
app.use(express.json())

app.use('/api/people', people)
app.use('/login', auth)

app.listen(5000, () => {
  console.log('Server is listening on port 5000....')
})

router-people.js - configure all routing for people

const express = require('express')
const router = express.Router()

const {
  getPeople,
  createPerson,
  createPersonPostman,
  updatePerson,
  deletePerson,
} = require('../controllers/people')

// router.get('/', getPeople)
// router.post('/', createPerson)
// router.post('/postman', createPersonPostman)
// router.put('/:id', updatePerson)
// router.delete('/:id', deletePerson)

router.route('/').get(getPeople).post(createPerson)
router.route('/postman').post(createPersonPostman)
router.route('/:id').put(updatePerson).delete(deletePerson)

module.exports = router

router-auth.js - For login purpose

const express = require('express')
const router = express.Router()

router.post('/', (req, res) => {
  const { name } = req.body
  if (name) {
    return res.status(200).send(`Welcome ${name}`)
  }

  res.status(401).send('Please Provide Credentials')
})

module.exports = router

router-controller.js - all logic for routes

let { people } = require('../data')

const getPeople = (req, res) => {
  res.status(200).json({ success: true, data: people })
}

const createPerson = (req, res) => {
  const { name } = req.body
  if (!name) {
    return res
      .status(400)
      .json({ success: false, msg: 'please provide name value' })
  }
  res.status(201).send({ success: true, person: name })
}

const createPersonPostman = (req, res) => {
  const { name } = req.body
  if (!name) {
    return res
      .status(400)
      .json({ success: false, msg: 'please provide name value' })
  }
  res.status(201).send({ success: true, data: [...people, name] })
}

const updatePerson = (req, res) => {
  const { id } = req.params
  const { name } = req.body

  const person = people.find((person) => person.id === Number(id))

  if (!person) {
    return res
      .status(404)
      .json({ success: false, msg: `no person with id ${id}` })
  }
  const newPeople = people.map((person) => {
    if (person.id === Number(id)) {
      person.name = name
    }
    return person
  })
  res.status(200).json({ success: true, data: newPeople })
}

const deletePerson = (req, res) => {
  const person = people.find((person) => person.id === Number(req.params.id))
  if (!person) {
    return res
      .status(404)
      .json({ success: false, msg: `no person with id ${req.params.id}` })
  }
  const newPeople = people.filter(
    (person) => person.id !== Number(req.params.id)
  )
  return res.status(200).json({ success: true, data: newPeople })
}

module.exports = {
  getPeople,
  createPerson,
  createPersonPostman,
  updatePerson,
  deletePerson,
}


Express Project 
1. Create Express1 folder

2. Create package.json - >npm init -y

3. Install express - >npm i express

4. Create index.js

const express = require('express');
const app = express();

app.get('/', (req, res) =>
  res.send("<h1>Hello world</h1>");
);

const PORT = process.env.PORT || 5000; //when we deploy it wont run on 5000, it will have port no in env variable, so we heck that first if not available it will execute in 5000
app.listen(PORT, () => console.log(`Server started on port ${PORT}`));

>node index.js and run localhost:5000/

5. Eachtime we dont want to restart the server when we make change so we install Nodemon
   >npm i nodemon --save-dev

6. In package.json configure it 

"scripts" : {
    "start": "node index.js",
    "dev" : "nodemon index.js"
}

>npm run dev

7. Now bring path module to deal with file paths in index.js. Now we load html file using sendFile() and we use path.join() and get current dir using __dirname and goto folder called "public" and load "index.html" 

const express = require('express');
const path = require('path');
const app = express();

app.get('/', (req, res) =>
  res.sendFile(path.join(__dirname,'public','index.html'));
);

const PORT = process.env.PORT || 5000; 
app.listen(PORT, () => console.log(`Server started on port ${PORT}`));

8. Create "public" folder and create "index.html"

<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <link rel="stylesheet" href="css/style.css" />
    <title>My Website</title>
  </head>
  <body>
    <h1>My Website</h1>
  </body>
</html>

run localhost:5000/ it will print "My Website"

9. If we want just static server that serves just HTML, CSS, images etc, then Express actually comes with middleware called "express.static()"

const express = require('express');
const path = require('path');
const app = express();

app.use(express.static(path.join(__dirname, 'public')));

const PORT = process.env.PORT || 5000; 
app.listen(PORT, () => console.log(`Server started on port ${PORT}`));

run localhost:5000/ it will print "My Website"

10. Create Members.js

const members = [
  {
    id: 1,
    name: 'John Doe',
    email: 'john@gmail.com',
    status: 'active'
  },
  {
    id: 2,
    name: 'Bob Williams',
    email: 'bob@gmail.com',
    status: 'inactive'
  },
  {
    id: 3,
    name: 'Shannon Jackson',
    email: 'shannon@gmail.com',
    status: 'active'
  }
];
module.exports = members;

11. Now we create route "/api/members" which returns members object as json format in index.js

const express = require('express');
const path = require('path');
const app = express();
const members = require('./Members');

app.get('/api/members', (req,res) => {
    res.json(members);
});

app.use(express.static(path.join(__dirname, 'public')));

const PORT = process.env.PORT || 5000; 
app.listen(PORT, () => console.log(`Server started on port ${PORT}`));

run localhost:5000/api/members in postman it will print members in json format

12. Create a logging middleware in logger.js inside middleware folder which prints complete url and also datetime formatted, for that we use 3rd party middleware called "moment" which deal with date formatting
    >npm install moment

const moment = require('moment');

const logger=(req,res,next) => {
    console.log(
    `${req.protocol}://${req.get('host')}${
      req.originalUrl
    }: ${moment().format()}`
  );
    next();
};

module.exports=logger

13. In index.js use

const logger = require('./middleware/logger');
app.use(logger);

run localhost:5000/api/members in postman it will print members in json format and look console we can see url with formatted date will be printed for each request 

14. Now we create route to get single member based on id

app.get('/api/members/:id', (req,res) => {
   const found=members.some(member => member.is === parseInt(req.params.id)); //some() checks condition and return struw or false
   
   if(found) {
      res.json(members.filter(member => member.is === parseInt(req.params.id)));
   } else {
       res.status(400).json({msg: `No member with id of ${req.params.id}` });
   }
});

Run localhost:5000/api/members/1, it will print member with id=1, and if no id is there it will print the "No member with id of 6"

15. Having all routes in index.js file is messy so we use router that comes with Express to put all of our routes in single file.
    Create folder "routes/api" and inside create members.js and copy both the routes inside this file

const express = require('express');
const router = express.Router();
const members = require('../../Members');

router.get('/api/members', (req,res) => {
    res.json(members);
});

router.get('/api/members/:id', (req,res) => {
   const found=members.some(member => member.is === parseInt(req.params.id));

   if(found) {
      res.json(members.filter(member => member.is === parseInt(req.params.id)));
   } else {
       res.status(400).json({msg: `No member with id of ${req.params.id}` });
   }
});

module.exports=router;

16. In order to work, we go to index.js

const express = require('express');
const path = require('path');
const logger = require('./middleware/logger');
const app = express();

app.use(logger);

app.use(express.static(path.join(__dirname, 'public')));

app.use('/api/members', require('./routes/api/members'));

const PORT = process.env.PORT || 5000; 
app.listen(PORT, () => console.log(`Server started on port ${PORT}`));

17. Since we gave "/api/members" in index.js, there is no need to provide in members.js

const express = require('express');
const router = express.Router();
const members = require('../../Members');

router.get('/', (req,res) => {
    res.json(members);
});

router.get('/:id', (req,res) => {
   const found=members.some(member => member.is === parseInt(req.params.id));

   if(found) {
      res.json(members.filter(member => member.is === parseInt(req.params.id)));
   } else {
       res.status(400).json({msg: `No member with id of ${req.params.id}` });
   }
});

module.exports=router;

Run localhost:5000/api/members/1, it will print member with id=1, and if no id is there it will print the "No member with id of 6"

18. Now we create new member using post request, for that we need to install body parser package but in newest version of express, it is included in express we just have to initialize in index.js 

app.use(express.json());
app.use(express.urlencoded({ extended: false }));

19. To dealing with id in each member object, we create some random id using uuid
   >npm install uuid

20. In members.js, we import it using and we generate randomid using v4() 

const uuid = require('uuid');

router.post('/', (req, res) => {
  const newMember = {
    id: uuid.v4(),
    name: req.body.name,
    email:req.body.email.
    status: 'active'
  };

  if (!newMember.name || !newMember.email) {
    return res.status(400).json({ msg: 'Please include a name and email' });
  }

  members.push(newMember);
  res.json(members);
});

Run localhost:5000/api/members in Post request - Body - raw -Json

{
   "name":"Ram",
   "email":"ram@gmail.com"
}

It will return all members in json format 

21. In members.js, next we update the member based on id

router.put('/:id', (req,res) => {
    const found=members.some(member => member.is === parseInt(req.params.id));

  if(found) {
    const updMember=req.body;
    members.forEach(member => {
       if(member.id === parseInt(req.params.id)) {
          member.name=updMember.name ? updMember.name : member.name;
          member.email=updMember.email ? updMember.email : member.email;
          res.json({ msg: 'Member Updated',member});
     }
});
 } else {
     res.status(400).json({ msg:`No member with the id of ${req.params.id}` });
}
});

Run localhost:5000/api/members/1 in Put request - Body - raw -Json

{
   "email":"ram@gmail.com"
}

It will return all members in json format with updated data for id=1

22. In members.js, we need to delete the member based on id

router.delete('/:id', (req,res) => {
   const found=members.some(member => member.is === parseInt(req.params.id));

   if(found) {
      res.json({
         msg: 'Member deleted',
         members:members.filter(member => member.is === parseInt(req.params.id))
    });
   } else {
       res.status(400).json({msg: `No member with id of ${req.params.id}` });
   }
});

Run localhost:5000/api/members/1 in DELETE request, it will delete member with id=1 and displays other members 

23. Now we move to rendering template using template engines called handlebars
   >npm install express-handlebars

In index.js,we configure 

const exphbs = require('express-handlebars');

To use handlebars we need to add middlewares

app.engine('handlebars', exphbs({ defaultLayout:'main'}));
app.set('view engine', 'handlebars');

24. Create views folder inside it main.handlebars and index.handlebars

https://github.com/bradtraversy/express_crash_course/tree/master/views

25. In order to render this page for "/" route 

app.get('/', (req, res) =>
  res.render('index', {
    title: 'Member App',
    members
  })
);


Node Programs: https://github.com/bradtraversy/node_crash_course/blob/master/person.js

1. Create person.js 

const person = {
      name: 'John',
      age: 30
}

mode.exports=person

2. Create index.js

const person=require('./person');

console.log(person);
console.log(person.name);

>node index

3. We can create as class also, so in Person.js

class Person {
  constructor(name, age) {
    this.name = name;
    this.age = age;
  }

  greeting() {
    console.log(`My name is ${this.name} and I am ${this.age}`);
  }
}

module.exports = Person;

This file is just getting run directly like this but actually when u include a module like this, it is wrapped in module called wrapper function 
   
// Module Wrapper Function
function (exports, require, module, __filename, __dirname) {

}

4. In index.js 

const person=require('./person');
const person1=new Person('John',35);
person1.greeting();

>node index

Path module
    The path module provides utilities for working with file and directory paths.

path_demo.js

const path = require('path');

// Base file name
console.log(path.basename(__filename)); //path_demo.js

// Directory name
console.log(path.dirname(__filename));

// File extension
console.log(path.extname(__filename));

// Create path object
console.log(path.parse(__filename));
console.log(path.parse(__filename).base);

// Concatenate paths
console.log(path.join(__dirname, 'test', 'hello.html'));



// More examples


// get the path delimiter base on the current OS Environment
const platSpec = path.delimiter;

console.log(platSpec);


// ge the path format on POSIX : / and Windows : \
// more info : https://nodejs.org/dist/latest-v11.x/docs/api/path.html#path_path_format_pathobject
const pathformat = path.format({
  dir: pathjoin,
  root: pathjoin,
  base: pathjoin,
  name: pathjoin,
  ext: pathjoin,
});

console.log(pathformat);


// get the parent folder director
const parentDir = path.dirname(__dirname);

console.log(parentDir);

2. fs_demo.js

const fs = require('fs');
const path = require('path');

// Create folder
// fs.mkdir(path.join(__dirname, '/test'), {}, err => {
//   if (err) throw err;
//   console.log('Folder created...');
// });

// Create and write to file
// fs.writeFile(
//   path.join(__dirname, '/test', 'hello.txt'),
//   'Hello World!',
//   err => {
//     if (err) throw err;
//     console.log('File written to...');

//     // File append
//     fs.appendFile(
//       path.join(__dirname, '/test', 'hello.txt'),
//       ' I love Node.js',
//       err => {
//         if (err) throw err;
//         console.log('File written to...');
//       }
//     );
//   }
// );

// Read file
// fs.readFile(path.join(__dirname, '/test', 'hello.txt'), 'utf8', (err, data) => {
//   if (err) throw err;
//   console.log(data);
// });

// Rename file
fs.rename(
  path.join(__dirname, '/test', 'hello.txt'),
  path.join(__dirname, '/test', 'helloworld.txt'),
  err => {
    if (err) throw err;
    console.log('File renamed...');
  }
);

3. os_demo.js

const os = require('os');

// Platform
console.log(os.platform());

// CPU Arch
console.log(os.arch());

// CPU Core Info
console.log(os.cpus());

// Free memory
console.log(os.freemem());

// Total memory
console.log(os.totalmem());

// Home dir
console.log(os.homedir());

// Uptime
console.log(os.uptime());

4. url_demo.js

const url = require('url');
// const URL = require('url').URL;
/* NOTE: if you are using v6 (LTS), line 1 gives errors,
*  if you get an error saying, TypeError: URL is not a constructor, 
*  comment line 1, and uncomment line 2 */

const myUrl = new URL('http://mywebsite.com/hello.html?id=100&status=active');

// Serialized URL
console.log(myUrl.href);
console.log(myUrl.toString());

// Host (root domain)
console.log(myUrl.host);

// Hostname (does not get port)
console.log(myUrl.hostname);

// Pathname
console.log(myUrl.pathname);

// Serialized query
console.log(myUrl.search);

// Params object
console.log(myUrl.searchParams);

// Add param
myUrl.searchParams.append('abc', '123');
console.log(myUrl.searchParams);

// Loop through params
myUrl.searchParams.forEach((value, name) => console.log(`${name}: ${value}`));

5. Event_demo.js

Much of the Node.js core API is built around an idiomatic asynchronous event-driven architecture in which certain kinds of objects (called "emitters") emit named events that cause Function objects ("listeners") to be called.
    We can create an event emitter class and then we can emit events and have listeners that listen for those events and then do something when they are fired

const EventEmitter = require('events');

// Create class
class MyEmitter extends EventEmitter {}

// Init object
const myEmitter = new MyEmitter();

// Event listener
myEmitter.on('event', () => console.log('Event Fired!'));

// Init event
myEmitter.emit('event');
myEmitter.emit('event');
myEmitter.emit('event');
myEmitter.emit('event');

6. Event emitter by creating a logger:

const EventEmitter = require('events');
const uuid = require('uuid'); //create random id 

class Logger extends EventEmitter {
  log(msg) {
    // Call event
    this.emit('message', { id: uuid.v4(), msg });
  }
}

// module.exports = Logger;

const logger = new Logger();

logger.on('message', data => console.log('Called Listener', data));

logger.log('Hello World');
logger.log('Hi');
logger.log('Hello');

7. http_demo.js

const http = require('http');

// Create server object
const server=http
  .createServer((req, res) => {
    // Write response
    res.write('Hello World');
    res.end();
  })
  
const PORT=process.env.PORT || 5000; //First it will check in env variable if not it will run in 5000
server.listen(PORT, () => console.log('Server running...'));


View Encapsulation in Angular - https://www.youtube.com/watch?v=X-1TBjBx6pc

     In OOPS, Encapsulation simply means hiding data and behaviour from outside world 
     - Whenever we create a component, for that component we specify the selector, view template and styleurl or styles property to specify some css style for that view template 
     -So whatever CSS style we specify using styleUrls or styles property, that css style only gets applied to that particular view template and not applied to view template of any other component
     - View Encapsulation is a concept or behaviour in angular, where component CSS styles are encapsulated into the components view and do not affect the rest of the application 
     - Now we have 3 components app,comp1,comp2 and each of these 3 components has button element
     - CSS elements has been applied only to button elt of app component, but comp1 and comp2 are child component of this app component and inside comp1, comp2 also we have button elements but this css style which we have specified on this button elemt has only been applied to the button elt of app component and not to the button elt of comp1 and comp2 and this is called view encapsulation in angular
     - When we specify css style, the css styles has global scope, css rules applies to the entire document, u cannot apply rules to the part of the document. But in case of angular apps the components coexist with other components, so it is important to ensure that css styles specified in one component does not override the css rules in another component and to achieve this we use view encapsulation 
      - 3 types of view encapsulation
1. ViewEncapsulation.Emulated (default)
         In this angular adds some unique html attributes to the component css style and also to html elements in order to achieve view encapsulation, so for each component there will be unique attribute which will be added to each html element in that component 
       When we inspect the page, in app component html on each of these html element there is a unique attribute which has been used, but we didnt specify these attributes explicitly, this has been added automatically by angular to each of the html elements of this app component, the value of this attribute is same for each of these elements in app component 
      If we goto comp1 component we can notice that for each element of the comp1 component another unique attribute has been added and this attrbute value is different from the attribute value of html elements of app component. In comp2 component also on each of the html elements of this comp2 component, a unique attribute has been added and this attribute is different from the attribute of comp1 component as well as app component 
     When we specified some style for button element in app component.css which has unique attribute, so it has not been applied simply on the button elt, it has been applied on the button elt which has unique attribute which we are seeing for the html elts of app component and using this unique attribute angular achieves view encapsulation in emulated type
    Now click on app component button, in the down we can see button element style with unique attribute for app component. Now if we change the value of the attribute to different value of attribute used on comp1 component and press enter, then button style will be applied on comp1 component.
    This is how angular achieves emulated view encapsulation by adding a unique attribute on each element of given component 

2. ViewEncapsulation.None
      In app.component.ts file under @Component decorator we are specifying encapsulation property as none
      encapsulation: ViewEncapsulation.None
     When we use none, no view encapsulation will be used that means whatever css style specified for the button element that will be applied to all the button elemts of child component as well, at this time no unique attributes will be used 
     Now we can notice that css style will be applied for all buttons and unique attribute is removed from each of these html elements 

3. ViewEncapsulation.Shadowdom 
      Now we remove css style for button elt from app.component.css and going to add it in styles.css file so it will applied globally which means it will applied to all the components and all the html elts 
      Now in comp2.component.ts file we add encapsulation property under component decorator 
      encapsulation: ViewEncapsulation.ShadowDom
      Here we can notice that css style for the button elt has been applied on app component as well as comp1 component but not on comp2 component because when we use shadowDom view encapsulation property for a component, then that component creates its own dom and broser keeps shadow dom separate from main dom and rendering of shadow dom and main dom happens separately so thats why style of shadow dom stay private and it does not get affected by main dom 

Change Detection
    - Means updating the DOM whenever data is changed
    - In default strategy whenever any data is changed, Angular will run change detector to update the DOM
    - In onPush strategy, Angular will only run change detector only when new reference is passed to @input data 


Change Detection Strategy in Angular
        - It is strategy which angular uses to detect the changes in the dom, so whenever you are rendering in the page that is happening due to change detection strategy. In case of 2way binding if u add ngModel and if u add interpolation of the same variable whichever we added in ngModel, once u change on input field that interpolation value is changing itself, so angular is rendering that one and that is possible due to change detection strategy 
        - Two change detection strategy - default and onPush
        - default means it will going to check always, so when any change on ur dom or any change on ur model or any change in the event will going to trigger a change detection default 
        - onPush means on trigger so you will ask angular, I will going to let you know when to check for any change in dom, so that it will check and render ur dom 
       Suppose we have parent and in the parent we are changing some values, and parent is not dependent at all with ur childs. Suppose we have parent and they have multiple childs and subchilds like tree of components as we have change detection strategy as default, so whenever we change something in parent ur change detection strategy will be going to run for all ur child components which will affect appl performance, if u r like doing a lot of data operation on any change detection, to solve that problem we have onPush strategy 
    So whenever we trigger you will just check for change but what angular have implemented is if you have any changes in ur input then it will going to rerun your change detection or any event handler run in that component we are also going to trigger ur change detection. We have change detection reference by using which we can ask angular to run change detection in our particular component 

1. Created 2 component parent and child

2. In app component we call parent component and inside parent component we call child component. It prints
     Parent works
     Child works

3. Whenever changes like an event is triggered or a promise or observable then zone.js will trigger the detection strategy 
    Whenever u change something on ngModel or promise or observable then it will work because angular use default change deduction strategy but if want to use ur own change deduction strategy then we can use onPush. 
    If we use onPush angular will not detect any observables events or promises that u have to tell angular that we are using observable then u need to change in view

4. In app.component.html we create input field

5. In parent.component.html, we invoke a function called triggerParent() and create in parent.component.ts
   In child.component.html, we invoke a function called triggerChild() and create in child.component.ts
   When we run it will print triggerParent and triggerChild, this is way default strategy will be working

6. If we change our ngModel in input field which is 2way binding then also it trigger this method, but we are not using any of parent and child data then also it will trigger this kind of event here, so this is default one, the angular will use default change detection strategy. So whenever we change any ngModel then it will trigger any event which are registered on parent and child 
    To disable this we use onPush change detection strategy where we tell when you should rerender the view 

7. In parent.component.ts, we use change detection property under @Component decorator 
    changeDetection:ChangeDetectionStrategy.OnPush

Now if we change any data in input field then it dosent event trigger, it does trigger for first time because we are initiating the class but if we change ngModel it dosent trigger.

8. So inside parent if we use any async call using setTimeout(), so after 2sec we want to print something on view.
   We declare parentFood as empty array and inside setTimeOut() we initialize value of parentFood as 'test' and after 2sec the value will be changing from empty to 'test'

parentFood : string[] = [];

setTimeout(() => {
      this.parentFood = ['test'];
    }, 2000);

So after 2sec parentFood variable will be changed to 'test'

9. Now we print that in parent.component.html as  
      {{ parentFood }}

But after 2sec it wont print the value, but if u comment changeDetection property then after 2sec it will print the value because default is whenever we change ngModel also going to print this function and also async call will be working in the component because in default angular detect these changes and it will show it in a view
   But if we use onPush strategy then angular disable that and dosent know any data or any model or any class variable its been changed 

10. So we have to do them manually, for that we inject ChangeDetectorRef in constructor 
   If we use ChangeDetectorRef and tell when data is loaded we have to change in view then we use markForCheck()
   
constructor(private cd: ChangeDetectorRef) { }

 ngOnInit(): void {
    setTimeout(() => {
      this.parentFood = ['test'];
      this.cd.markForCheck();
    }, 2000);
  }

When we run and whenever data is changed, it prints test. But it dosent trigger any of event if we change any ngModel 

11. If we disable 

changeDetection:ChangeDetectionStrategy.OnPush   and
this.cd.markForCheck();

then if we change any model its gonna trying to trigger as well 

12. But if we use ChangeDetectorRef we can use detach(), it is exactly same as change detection strategy onpush, so if we change ngModel and dosent give me setTimeout async call and dosent refresh view 

constructor(private cd: ChangeDetectorRef) {
    this.cd.detach();
   }

Now when we run we cant see 'test' and it wont trigger anything if ngModel changes

13. Now we need to change in view so we will tell them using detectChanges()

ngOnInit(): void {
    setTimeout(() => {
      this.parentFood = ['test'];
      //this.cd.markForCheck();
      this.cd.detectChanges();
    }, 2000);
  }

Now when we call detectChanges(), we can see it will print 'test' but when we change anything in ngModel it will not trigger any of event 

14. If we do reattach(), it will reattach the standard version which angular provides. When we use reattach is whenever we get some kind of data like an input data from app.component 
    Now we check if we have value then we detach, incase no value it will reattach


CRUD application using Node and Express
1. Create crud_app folder 
2. Create server.js file inside crud_app folder. This file allow us to start the server 

3. Initialize this project as npm package 
crud_app> npm init
   which creates package.json and initialize this project as npm package 

4. Install some external module into this project like 
   express - used to rapidly develop the node appl
   morgan - used to log a message every time when we make a request 
   nodemon - allows to restart the server automatically when we make changes in the project 
   ejs - It is the template engine which used to create dynamic html 
   body-parser - allows us to serialize the data and access the form data using body property 
   dotenv - allows you to separate the secret from ur source code, this is useful in collaborative env where u may not want to share ur db login credential with other people, instead we can share the source code while allowinh other people to create their own dotenv file 
    mongoose - using this module we are going to connect this project with mongodb database 
    axios - this library makes it easy to make a request in express appl

>npm i express morgan nodemon ejs body-parser dotenv mongoose axios

In case any error while installing, 
npm config set strict-ssl false
npm set registry=https://registry.npmjs.org/


Now in package.json we can see all modules are installed. So in package.json instead of 
   "start":"node server.js" we give "nodemon server.js"

Which allow to restart the server whenever we make the changes 

5. So when we make project in node or express appl we should have a project structure 
   - assets folder inside crud_app folder where all asset of ur project is located. Inside assets folder we create css,js,img folder which contains all css, js and images related to this project 
   - views folder inside crud_app folder which contains all html files, here we use ejs(embedded javascript) template engine to create dynamic html and this is default folder of view engine of express
   - server folder inside crud_app folder which contains all server side code, for example inside this folder we create our services, model, mongodb connection and etc
    Inside server folder we create few folder because we are following MVC pattern of appl. So MVC is appl design pattern which separates the appl data and business logic from the presentation, so we create model and controller folder inside server folder 
    Inside model folder we are working with mongodb data where we perform the data validation, processing data, creating mongo scheme etc. Inside the controller we deal with user request for resources from the server, so here we create different functions that send the resources to the user 
    - Inside server folder we create another folder called database, it is always best practice to separate ur code so we can maintain it very easily
    - Inside server folder we create another folder called routes, where we create different routes
    - Inside server folder we create another folder called services

6. Once project structure is ready, we create our HTTP server in server.js 

- First we require express module  
const express = require('express');

- Next we create app, so we initialize app variable  as express appl 
  const app=express();

- Next we create default route, so here when url match to the root route we will execute the callback method. So we call arrow function of ES6 and we send response, then we listen the server on port 3000 with callback func as 2nd argument and we use console.log

app.get('/',(req,res)=> {
      res.send("Crud application");
})
app.listen(3000,()=>{ console.log(`Server is running on http://localhost:${3000}`)}); 
    
7. Now we start the server by running
> npm start 
which runs nodemon server.js and start HTTP server and display message called `Server is running on http://localhost:3000
   When we click on http://localhost:3000 and open the appl in browser

Once ur server is started, we make some changes in HTTP request, now we create a variable called PORT where we store all details inside .env file, and if the variable of .env file is not available then we pass the default value 8080, and instead of hardcode the value we pass this variable 

const PORT=process.env.PORT || 8080 

app.listen(3000,()=>{ console.log(`Server is running on http://localhost:${PORT}`)});

Once saved we can see in terminal the server is started on port 8080

8. Now we create .env file and create a variable inside it and specify value to it.
    Create config.env file inside project, inside this we create port variable

PORT=3000

Once we save the file, still in terminal we can see the server starts in port no 8080, so we need to specify the path of config file and we need to inform the express server to use the variable of .env file 
    So first we need dotenv module using require(), and before PORT variable we call config() where we specify the path of config file 

const dotenv = require('dotenv');
dotenv.config( { path : 'config.env'} )

Once we saved, now we can see the server will started on port 3000. So dotenv module is allow to separate ur secret from ur source code, this is very useful when u work with collaborative env. So when u want to share ur code with other people so instead of sharing ur credential we can share the source code, while allowing other people to create their own .env file 

9. Now we add morgan module which allows us to log a request on the console whenever we make request  

const morgan = require('morgan');
  - Now specify morgan module and inside it call tiny token
app.use(morgan('tiny'));

Once we refresh the browser we can notice that this will print the type of request, the path and response millisecond  

10. Now we add body parser module 

const bodyparser = require("body-parser");

// parse request to body-parser
app.use(bodyparser.urlencoded({ extended : true}))
   - so this will parse the request of the content type from url encoded, so once you link the body parser 

11. Now we set the view engine, here we use ejs(embedded javascript) 

app.set("view engine", "ejs")

If we create all ur ejs file inside views folder then we dont have to specify the folder name to ejs template engine, but if we change this views folder, for example if we create ejs folder inside views folder and put all ejs file inside that folder then we need to inform express to set that folder as default view engine folder, so to do that we have to call and we need to call path module of node

const path = require('path'); //it is inbuild in                                  node appl

app.set("views", path.resolve(__dirname, "views/ejs"))  

12. Next we are going to load all assets by using middleware method called use(). First we specify the virtual path for these assets, then we call static() of express and call path.resolve() with __dirname which return current project dir name and the folder location

app.use('/css', express.static(path.resolve(__dirname, "assets/css")))
app.use('/img', express.static(path.resolve(__dirname, "assets/img")))
app.use('/js', express.static(path.resolve(__dirname, "assets/js")))

13. Next we create views for our express appl, we have already set view engine as ejs for this appl

- create index.ejs inside views folder 
1. Create simple HTML5 template, type ! and then press tab, it will create simple html5 snippet  
     Now we create header with id=header, so type header#header and press tab, it will create header tag. Inside the header we create nav and inside nav we create <div> tag with class container, so we give .container and press tab. 
     Inside <div> tag, create another <div> with class text-center, so give .text-center and press tab. Inside <div> tag, we create <a> tag to specify link

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Crud Application</title>
</head>
<body>
    <!-- Header -->
         <header id="header">
             <nav>
                 <div class="container">
                     <div class="text-center">
                         <a href="/" class="nav-brand text-dark">User Management System</a>
                     </div>
                 </div>
             </nav>
         </header>
    <!-- /Header -->
</body>
</html>

- Now if we run "npm start", the server will be started but still it display response as Crud Application, but we want to return the response of this html file, so inside app.get() we call res.render() which allow us to render html file 

app.get('/',(req,res)=> {
    res.render('index');
})

No need to provide extension, because we have already provided the view engine as ejs.

Now save and refresh the browser we can see the output from index.ejs file 


14. Now we put this index.ejs content in separate header and footer file so we can manage it easily
    Create include folder inside views folder, inside include folder we create new file called _header.ejs with underscore to indicate this is the partial file of index.ejs

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Crud Application</title>
</head>
<body>
    <!-- Header -->
         <header id="header">
             <nav>
                 <div class="container">
                     <div class="text-center">
                         <a href="/" class="nav-brand text-dark">User Management System</a>
                     </div>
                 </div>
             </nav>
         </header>
    <!-- /Header -->

   - Create another _footer.ejs file inside include folder and paste
     
     </body>
   </html>
 
   - Now in indes.ejs we include both these files by using include()


<!-- include header -->
<%- include('include/_header') %>
<!-- /include header -->

<!-- include footer -->
<%- include('include/_footer') %>
<!-- /include footer -->

Now if we save we can see server is not restarted, because the nodemon is only restart when you make changes in the js files, so we need to inform nodemon to restart the server whenever we make changes inside ejs files, but instead of informing nodemon to restart the server everytime when we make the changes inside ejs file. So we create a demo html file and use live server extension of VS code 
    
- Create demo.html for design purpose(copy paste code from header.ejs and footer.ejs) file inside views folder and use live server extension of VS code editor so we can easily save the changes and restart the server 
   Click Extension on VS code - Search for Live server and install it 
    Using this live server this will launch development local server with live reload, so when we make any changes inside html file, this will automatically reflect on live server we dont have to restart the server every time when we make changes 
   Now right click on index.html and open with live server

15. Now we can create main section of our web page. In order to display icons,  we copy url in <head> tag 

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Crud Application</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.1/css/all.min.css" integrity="sha512-+4zCK9k+qNFUR5X+cKL9EIR+ZOhtIloNl9GIKS57V1MyNsYpYcUrUeQc9vNfzsWfV28IaLL3i96P9sdNyeRssA==" crossorigin="anonymous" />
</head>
<body>
    <!-- Header -->
         <header id="header">
             <nav>
                 <div class="container">
                     <div class="text-center">
                         <a href="/" class="nav-brand text-dark">User Management System</a>
                     </div>
                 </div>
             </nav>
         </header>
    <!-- /Header -->
    <!-- Main site-->
    <main id="site-main">
        <div class="container">
            <div class="box-nav d-flex justify-between">
                <a href="/add-user" class="border-shadow">
                    <span class="text-gradient">New User <i class="fas fa-user"></i></span>
                </a>
            </div>

            <!-- form handling -->
            <form action="/" method="POST">
                <table class="table">
                    <thead class="thead-dark">
                        <tr>
                            <th>ID</th>
                            <th>Name</th>
                            <th>@Email</th>
                            <th>Gender</th>
                            <th>Status</th>
                            <th>Action</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>1</td>
                            <td>Ram</td>
                            <td>ram@gmail.com</td>
                            <td>Male</td>
                            <td>Active</td>
                            <td>
                                <a href="#" class="btn border-shadow update">
                                    <span class="text-gradient"><i class="fas fa-pencil-alt"></i></span>
                                </a>
                                <a class="btn border-shadow delete">
                                    <span class="text-gradient"><i class="fas fa-times"></i></span>
                                </a>
                            </td>
                        </tr>
                    </tbody>
                </table>
            </form>
        </div>
    </main>
    <!-- /Main site -->
</body>
</html>

16. Now we style the webpage by creating styles in style.css, so we add 
<link rel="stylesheet" href="../assets/css/style.css"> 

17. When we click on new user, we want to navigate user to the new form where the client can specify their username, email, gender and status 
    Inside views folder we create add_user.html, copy paste content from index.html and create form for adding new user 

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Crud Application</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.1/css/all.min.css" integrity="sha512-+4zCK9k+qNFUR5X+cKL9EIR+ZOhtIloNl9GIKS57V1MyNsYpYcUrUeQc9vNfzsWfV28IaLL3i96P9sdNyeRssA==" crossorigin="anonymous" />
    <link rel="stylesheet" href="../assets/css/style.css"> 
</head>
<body>
    <!-- Header -->
         <header id="header">
             <nav>
                 <div class="container">
                     <div class="text-center">
                         <a href="/" class="nav-brand text-dark">User Management System</a>
                     </div>
                 </div>
             </nav>
         </header>
    <!-- /Header -->
    <!-- Main site-->
    <main id="site-main">
        <div class="container">
            <div class="box-nav d-flex justify-between">
                <div class="filter">
                    <a href="/"><i class="fas fa-angle-double-left"></i> All Users</a>
                </div>
             </div>
             <div class="form-title text-center">
                 <h2 class="text-dark">New User</h2>
                 <span class="text-light">Use the below form to create a new account</span>
             </div>

            <!-- form handling -->
 <form  method="POST" id="add_user">
    <div class="new_user">
        <div class="form-group">
            <label for="name" class="text-light">Name</label>
            <input type="hidden" name="id" value="">
            <input type="text" name="name" value="" placeholder="Mark Stoenis">
        </div>
        <div class="form-group">
            <label for="Email" class="text-light">Email</label>
            <input type="text" name="email" value="" placeholder="example@gmail.com">
        </div>
        <div class="form-group">
            <label for="gender" class="text-light">Gender</label>
            <div class="radio inline">
                <input type="radio" id="radio-2" name="gender" value="Male" >
                <label for="radio-2" class="radio-label">Male</label>
            </div>
            <div class="radio inline">
                <input type="radio" id="radio-3" name="gender" value="Female" >
                <label for="radio-3" class="radio-label">Female</label>
            </div>
        </div>

        <div class="form-group">
            <label for="gender" class="text-light">Status</label>
            <div class="radio inline">
                <input type="radio" id="radio-4" name="status" value="Active" >
                <label for="radio-4" class="radio-label">Active</label>
            </div>
            <div class="radio inline">
                <input type="radio" id="radio-5" name="status" value="Inactive" >
                <label for="radio-5" class="radio-label">Inactive</label>
            </div>
        </div>

        <div class="form-group">
            <button type="submit" class="btn text-dark update">Save</button>
        </div>

    </div>
</form>
        </div>
    </main>
    <!-- /Main site -->
</body>
</html>

open the file in live server and see the changes 

18. Now we will see how to convert html template to ejs template engine 

- From index.html copy "Main site" and paste between header and footer section of index.ejs
- Cut <tr> part from <tbody> of index.ejs and put into separate file called _show.ejs inside include folder and call 
                 <tbody>
                    <%- include('include/_show') %>
                </tbody>
Now start the server, still we can see the style is not applied, so we add <link> in header.ejs file also

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.1/css/all.min.css" integrity="sha512-+4zCK9k+qNFUR5X+cKL9EIR+ZOhtIloNl9GIKS57V1MyNsYpYcUrUeQc9vNfzsWfV28IaLL3i96P9sdNyeRssA==" crossorigin="anonymous" />
    <link rel="stylesheet" href="../assets/css/style.css">

Now we can see the styles are applied to the webpage when we start the server

19. Now if we click on New User, we want to navigate to add_user form, now we create new file called add_user.ejs inside views folder

- Copy and paste main section from add_user.html  inside add_user.ejs along with header and footer section

- Now we put form handling part of add-user.ejs in separate partial file called _form.ejs inside include folder 
- Now we include _form.ejs inside add_user.ejs
        <%- include('include/_form') %>

20. Next we create route for '/add-user' in server.js

app.get('/add-user',(req,res)=> {
    res.render('add_user');
 })

Now save and run the project, when we click New User button it will go to add-user page. When we click All Users, it will navigate to the root route of the website 

21. When we click Edit button, we need to navigate to update page of the website 
   - Inside views folder, create update_user.ejs, copy paste all code of add_user.ejs inside this file along with _form.ejs
   - When we click Edit button we have to go to update_user, so we give action for edit button in _show.ejs

<a href="/update-user" class="btn border-shadow update">
            <span class="text-gradient"><i class="fas fa-pencil-alt"></i></span>
        </a>

    - Now we provide the route for update_user.ejs in server.js
app.get('/update-user',(req,res)=> {
    res.render('update_user');
})

22. Now we can delete index.html and add_user.html

23. Next we are working on server side of the project, so in server.js we have routes and we are going to separate this routes from server.js file and create a dedicated router file
    - Create route.js inside routes folder, cut all routes from server.js and paste inside route.js and import express module inside route.js
    Here we are not going to create 
       const app=express();
because this stmt will create a new app, so instead of creating new app we call method of express called Router() which allows us to create different router in separate file. Finally we export this route so it can use in server.js

const express=require('express');
const route=express.Router();

route.get('/',(req,res)=> {
    res.render('index');
})
 
route.get('/add-user',(req,res)=> {
     res.render('add_user');
 })
 
route.get('/update-user',(req,res)=> {
     res.render('update_user');
})

module.exports=route

 - Now we import this file in server.js 
app.use('/', require('./server/routes/route'))
   So we call app.use(), specify the root path along with location of route.js

Save and check whether the appl is working fine

24. In route.js, instead of creating callback functions inside parenthesis of get(), we separate the callback function so we can maintain it
    - Inside services folder, we create new file called render.js which allow us to render different files using routes
    So here we create export keyword with a callback function so that it can use in other files and inside this function we can call res.render("index") 
    exports.homeRoutes = (req, res) => {
        res.render("index");
    }
  Now in route.js, instead of calling callback function, we call render.js so first we import this file and call inside get()
     const services=require('../services/render');
     route.get('/',services.homeRoutes);
  Similarly call for other routes also

render.js

exports.homeRoutes = (req, res) => {
    res.render('index');
}

exports.add_user = (req, res) => {
    res.render('add_user');
}

exports.update_user = (req, res) => {
    res.render('update_user');
}

route.js
const express=require('express');
const route=express.Router();

const services=require('../services/render');

route.get('/',services.homeRoutes)
route.get('/add-user',services.add_user)
route.get('/update-user',services.update_user)

module.exports=route

Now save all pages and check whether the app is working
    
25. Now we see how to connect mongodb to the project, when we are working on big project we are not going to store all the data in the localhost because if harddisk crash we could lost all the data, so instead of storing all these data inside hard disk we will store it on cloud 
     In MongoDB, we have Mongodb Atlas where we can store all ur data 
   Click Start Free
  - We can see MongoDB Atlas where we can store ur data on cloud database, it is fully managed cloud database developed by the same people that build mongodb. So we register and create new account in mongodb 
   Username: senthil1418@gmail.com
   Pwd: Birthday1980!@
   - Once signed in, we can create new project and new cluster, cluster is going to manage all ur cloud data 
    Click New Project 
    Project Name: CRUD - Click Next - Click Create project 
    Build a database - Click Free under shared - we use cloud Provider as AWS - Click Create Cluster 
    How would like to authenticate the connection?
       username: senthil
       Password: abcd123
    Click Create User
    Click Add my current IP address - Edit the Ip address as 127.0.0.1 - Click Upload entry
    Click Finish and Close 
    Click Database access from Security - we can see the admin user who can access all db
    Click Network Access - Click Edit - Click Allow access from anywhere 
    Click Database on right side menu
    Click Connect - to connect this db to our appl
    Choose Connect ur appl - We can see connection string through which we can connect this appl with our project 
    Copy that connection string - Click close


26. In config.env file, we create a new variable 

MONGO_URI=mongodb+srv://senthil:<password>@cluster0.r3kbkxw.mongodb.net/<dbname>?retryWrites=true&w=majority 

Provide the password and db name before ?retry

MONGO_URI=mongodb+srv://senthil:abcd123@cluster0.r3kbkxw.mongodb.net/users?retryWrites=true&w=majority 

27. Inside database folder, create new file called connection.js 
    First we require mongoose module to connect with database, now create a function called connectDB, here we create async function using async and await
    Now we call connect() of mongoose and provide mongo url provided in config.env, in the second arg we provide some properties which is going to stop warnings in the console when we use mongodb connection 



const mongoose = require('mongoose');

const connectDB = async () => {
    try{
        // mongodb connection string
        const con = await mongoose.connect(process.env.MONGO_URI, {
            useNewUrlParser: true,
            useUnifiedTopology: true
        })

        console.log(`MongoDB connected : ${con.connection.host}`);
    }catch(err){
        console.log(err);
        process.exit(1);
    }
}

module.exports = connectDB

28. Now call this connectDb in server.js

const connectDB = require('./server/database/connection');

// mongodb connection
connectDB();   

When we save, we can see server will be started and on console we can see MongoDB connected which is database hostname and from this we can successfully connected to mongodb

29. Inside model folder we create mongodb scheme called model.js
     First we require mongoose module, and we create mongoose schema with name and its properties. Finally we call method of mongoose called model() and inside this model we specify the document name called userdb along with schema. Finally export the model 

const mongoose = require('mongoose');

var schema = new mongoose.Schema({
    name : {
        type : String,
        required: true
    },
    email : {
        type: String,
        required: true,
        unique: true
    },
    gender : String,
    status : String
})

const Userdb = mongoose.model('userdb', schema);

module.exports = Userdb;

30. Now we create controller using with we make select, update, delete and create records 
    Create controller.js inside Controller folder, inside this first we need model.js file to use schema inside controller 
    var Userdb = require('../model/model');

   - First we want to store user into db, so we create
  
var Userdb = require('../model/model');

// create and save new user
exports.create = (req,res)=>{
    // validate request - if user makes post req with empty body 
    if(!req.body){
        res.status(400).send({ message : "Content can not be emtpy!"});
        return;
    }

    //all the form data is stored in body of req obj and using
    //body we can access all form data 
    // new user
    const user = new Userdb({
        name : req.body.name,
        email : req.body.email,
        gender: req.body.gender,
        status : req.body.status
    })

    // save user in the database
    user
        .save(user)  //save data in mongodb, then call promise to return data to user, if there is any error we call catch block 
        .then(data => {
            //res.send(data)
            res.redirect('/add-user');
        })
        .catch(err =>{
            res.status(500).send({
                message : err.message || "Some error occurred while creating a create operation"
            });
        });

}

   - Next route.js we need this controller so we need
   const controller = require('../controller/controller');
  - Now we create route for storing the data
   route.post('/api/users', controller.create);
  So when we request path '/api/users' we call create() in controller 
  - Next we create next set of path
route.get('/api/users', controller.find);
route.put('/api/users/:id', controller.update);
route.delete('/api/users/:id', controller.delete);
 
31. Start node appl, >npm start

In postman, we check the request with POST request, http://localhost:3000/api/users
    In Body - x-www-form-encoded - Under Key - value
name - Ram
email - ram@gmail.com
gender - Male
status - Active
   Click Send

Goto mongodb - Click Browse Collection - Now we can see the data which we inserted in postman

32. Update the record in mongodb
       - When we click edit icon, we want to display all details and display on the webpage 
         In render.js, we call axios to fetch the data based on particular id and render that userdata to variable called user and now we print those info in update_user.ejs as user.name, user.gender etc
       - Now after updating when we click save button the data have to be updated
       But in update_user.ejs we dont have any action attribute to this form, so in index.js we are going to access the update form. So when we click on submit button, we call function with event parameter, and next call event.preventDefault() which is going to change the default behaviour of this form (ie) default behaviour of the form is to render on the browser when u click on submit button but this stmt will stop that default behaviour 
       Next we get all data from submitted form by calling serializeArray() which return a serialize array of the data, so when we submit the data we get all the data into variable called unindexed_array.
       Next we call map() with unindexed_array and call a function(n,i), so the first arg n will return all the data from this array. Inside this map() we create new array and store all the value into it. Next we pass this data to the put request and update this record using ajax concept


Event loop
    - It is one of the most import aspect to understand about nodejs because it explain how nodejs can be async and have non-blocking io
    The nodejs javascript code runs on a single thread or single process, there is just one thing happening at a time, theere is event loop for every browsers to make every process isolated and avoid a webpage with infinite loops or heavy processing to block ur entire browser

index.js
     1. First we create constant variable and specify arrow function to it, inside arrow function we specify console.log() and print the output. Arrow function are introduce in ES6 as a new syntax for writing JS functions 
     const bar=()=>console.log("bar")
     2. Next we create another arrow function with different name to it
     const baz=()=>console.log("baz")
     3. Next we create another arrow function foo(), inside that we call console.log("foo") and then call bar() and then baz() function
     const foo=()=>{
          console.log("foo")
          bar()
          baz()
     }
     4. Next we call foo() function
        foo()

When we execute the file, we get output as foo,bar,baz. So when we run this code first foo() function is called, inside foo() we have console.log("foo"), then we call bar() and then baz()
    Here all these functions execute one by one from top to bottom, this is called as call stack, so callstack will take the function and execute it, so when we execute this file a call stack will put these function in a row or queue and then execute it one by one. The event loop continuously check the callstack to see if there is any function that needs to run, while doing so it adds any function call it finds to the callstack and execute each one in order.
     The callstack iteration start from calling foo(), so this will first call foo(), then bar(), then baz() function and print the output, this will happen until the callstack is empty, but sometimes node prgs are not that simple 
     A node prg would have a function that would delay the execution process. The above example is normal, here javascript just find things and execute it, run them in order, but what if we add a function that execute after 1sec or more.
     
const bar=()=>console.log("bar")
const baz=()=>console.log("baz")

const foo=()=>{
          console.log("foo")
          setTimeout(bar,1000) //it will execute bar() after 1sec
          baz()
}

foo()

When we execute we have foo, baz, bar. So the callstack is going to execute this bar() at the end of this appl, so when prg is run foo() is called, inside foo() we have console.log(), then setTimeout which call bar() after 1sec.
    The callstack will first execute this foo() function, inside foo() it will execute setTimeout() function which have a timer so it will execute after 1sec, so the callstack will move to the next function and execute it and at the end the callstack will execute the function that is causing delay. So when setTimeout() method is called, a nodejs start a timer and once the timer expires (ie) 1sec, the callback function (ie) bar() is put in the message queue so when the process of the function is finished the callstack will pull this function from the message queue and execute it 
      So if ur deploy ur appl, we dont want to create a function that delays the execution which may add error in ur code like undefined object or undefined function. To save this problem nodes provide promises, promises is a way to execute a result of async function as soon as possible rather than being put at the end of the callstack, so everytime if the function makes delay it execute at the end of the program, to solve this problem we have promises 

Callback
    In event loop we understand any function that making delay in the execution will execute at the end of the appl, now to solve this problem we have promises and also we have callbacks. Promises and callbacks allow us to solve the problem and make the code async
    Callback is a function that is passed into another function as an argument to be executed later. If we try to execute a long running operation within a single threaded event loop, the process is blocked this is technically bad because the process stop processing other events while waiting for ur operation to complete 
     Callbacks are used in 2 different ways (ie) in sync and async function

Sync function using callback 

function getMessage() {
    console.log("Get Message");
}
function displayMessage() {
    console.log("Display Message");
}
getMessage()
displayMessage()

When we execute we get result as "Get Message, Display Message", so callstack will execute getMessage() function first and then execute this displayMessage() function and both of them executed immediately. In certain situations some code is not executed immediately, for example if we assume that this getMessage() function perform an api call where we have to send a request to the server and wait for the response, in that case this function makes delay and the callstack will execute this function at the end of the appl  

For example:

function getMessage() {
  setTimeout(()=> {
    console.log("Get Message");
  },1000)
}
function displayMessage() {
    console.log("Display Message");
}
getMessage()
displayMessage()

When we execute this file we can see "DisplayMessage", so getMessage() function is making delay in the execution and JS will put this function in the end of callstack. In case if we want to execute getMessage() in the beginning instead of displayMessage() then we use async Javascript 
    So we want to execute getMessage() function before displayMessage(), in that case we can use callback. In setTimeout() we use callback, as we said callback is a function that pass into another function as an argument, so setTimeout is a function and as an argument we pass a callback function 
    Now we want to execute displayMessage() after getMessage(), we want to execute this displayMessage() in the call stack at the end, in that case we can use async JS with callbacks 
    So in getMessage() function we simply pass 2 parameters, first is message and second is callback function. In console.log() we simply call the parameter and down we call callback(), so when we call getMessage() first we have to call message and then call another function as an argument

function getMessage(msg,callback) {
 setTimeout(() => {
    console.log(msg);
    callback()
 },1000)
}
function displayMessage() {
    console.log("Display Message");
}
getMessage("Get Message",displayMessage)

When we execute this file, we get "Get Message" as first result then "Display Message" after 1sec. So if we dont want to specify the function reference as 2nd argument then we can create arrow function as well  

getMessage("Get Message",()=>console.log("Display Message"))


Promises
    - Another way to create async code in JS is using Promises. Promises are introduced in ECMAScript 15 
    - Promises is a way to execute the result of an async function as soon as possible rather than at the end of callstack 
    - Promises is a class so we need to create an instance of the class and then initialize it with a function and then specify function as first parameter
   1. First we create an instance of promise with function as 1st arg which takes resolve and request as argument. Using resolve and reject we can communicate back to the caller, what the resulting promise state was and wht to do with it 
    In the body of function, we call setTimeout() and inside this function we call callback function with timer where we execute promise after 1sec

let promise=new Promise(function(resolve,reject){
   setTimeout(()=>resolve("Run before"),1000)
});

promise.then(
    result => {
       console.log(result)
    },
    error => console.log(error)
)

Now we call promise.then(), inside we call the result and error.

So here we created variable called promise and specify the instance of Promise class. The Promise class have a constructor as an function, the function have two arg called resolve and reject, using resolve we can return successful result and using reject we can return the error message. Here we call setTimeout() and return "Run before" after 1sec, we used resolve as an function and return the result, this function will return the result once the process is finished. So when setTimeout function finish the process, resolve will return the result to then() method, then() method have 2 arg called result and error. Using result we can get the resolved messages and using reject we can get error messages. So when we call reject inside setTimeout then it will return error data, when we call resolve it will return result data 
     Promises will execute 1st argument when promises return resolve and if promises return reject, then() will return 2nd argument 

let promise=new Promise(function(resolve,reject){
   setTimeout(()=>reject(new Error("whoops")),1000)
});

promise.then(
    result => {
       console.log(result)
    },
    error => console.log(error)
)

Now it will return error msg, since promise returns reject 

Example:
let promise=new Promise(function(resolve,reject){
   setTimeout(()=>resolve("Run before"),1000)
});

promise.then(
    result => {
       console.log(result)
       GetAfter()
    },
    error => console.log(error)
)

function GetAfter() {
   console.log("Print after")
}

Promises make this code as asynchronous, so when we execute the program a new Promise instance is created, once Promise is initialized with this resolve and then() function will execute 1st argument and prints "Run Before" and "Print After" after 1sec 

Async and await
     We use callbacks and promises for creating async code. In ECMAScript 17 async javascript is even simpler with async and await function. Async functions are combination of promises and generators and basically they are higher level abstraction. They hide all the unnecessary code of promises
     Async and await build on promies, but why do we need async and await when we have promises. When promises were introduced in ECMAScript 15 they were meant to solve a problem with async code, but after 2 yrs a new ECMAScript17 release and there it was clear that promises could not be the final solution 
    Promises are introduces to solve the famous callback hill problems, but they introduced complexity on their own, this is why async functions were introduced, they make the code to look like sync, but its async and non blocking behind the scene
    
Example
     We create a function called Clown() which return a Promise, since async and await are built on promises. This promise will takes a function with 2 states (ie) resolve and reject, but here we just return resolve since we want to return successful result and using arrow function we return it 
     Inside we call setTimeout(), inside that we pass a callback function, inside callback function we call resolve and return a "Success". So when we have successful result, promise is going to return the resolve result. We also specify timer as  2000 to make this function delay by 2sec 
     Next we create one more function msg() and inside it, we create const variable msg and call Clown() function. Finally we call msg() function

function Clown() {
   return new Promise(resolve => {
       setTimeout(()=>{
          resolve("Hello")
       },2000)
   })
}
function msg() {
    const msg=Clown()
    console.log("Message: ",msg)
}
msg()

When we execute the prg, we get message with Promise and with status pending, because msg() function is executed before 2sec, but we want msg() to execute after 2sec, so we get "hello" result in console.log. msg() function executes immediately when we execute this program thats why we get pending result in the output 
    So we need to make msg() function as async, to make it asynchronous we need to add "async" keyword and inside this function we need to call "await" keyword

function Clown() {
   return new Promise(resolve => {
       setTimeout(()=>{
          resolve("Hello")
       },2000)
   })
}
async function msg() {
    const msg=await Clown()
    console.log("Message: ",msg)
}
msg()

When we execute the prg, after 2sec we get output as Message: Hello
    So what this async does is, will make this function asynchronous and await will make this function to wait for 2sec. When we specify async before the function, so last stmt msg() will not execute immediately and msg() function will wait for the promises to return something. await operator is used to wait for a promise to resolve or reject, it can used only inside async function so when we have resolve or reject response from these promises, await operator will inform to this async and execute this function, so both the functions communicate with each other and execute ur async code 
    So when promises return resolve or reject, await is going to inform async that we get the data what we want and execute Clown() function so once we have the data, async will execute msg() function after 2 sec
    Now if we want to execute someother message after the result, so we create getResult() function and in body we call console.log() 

function Clown() {
   return new Promise(resolve => {
       setTimeout(()=>{
          resolve("Hello")
       },2000)
   })
}
async function msg() {
    const msg=await Clown()
    console.log("Message: ",msg)
}
msg()

function getResult() {
   console.log("Execute After")
}
getResult()

When we execute we get "Execute First" and then Message: Hello, but we want to get Message: Hello and then Execute First. We can do it by specify a callback function in msg()


function Clown() {
   return new Promise(resolve => {
       setTimeout(()=>{
          resolve("Hello")
       },2000)
   })
}
async function msg(callback) {
    const msg=await Clown()
    console.log("Message: ",msg)
    callback();
}
msg(getResult)

function getResult() {
   console.log("Execute After")
}

When we execute we get result as "Message: Hello" and then "Execute After"

Create HTTP Server in Node
     As we know node is runtime env for executing JS outside of the browser, so when we want to communicate with the browser we need to work with HTTP server. When we view a webpage in ur browser we are making a request to another computer on the internet, which then provides you a web page as a response, that computer we are talking to using the internet is a web server
     A web server receive http request from the client like ur browser and provide an http response like an http page or json data from api. We see how to create a basic HTTP server

1. Import the module called HTTP
   const http=require("http")
In node we dont have to install http module using npm because http is inbuilt module in node 

2. Next specify hostname and port where ur http server is going to run 
    const hostname="127.0.0.1"
    const prt=3000;

3. Next we create http server by calling http module createServer() method which help us to create http server and to that method we need to pass callback function as arrow function which takes 2 argument (ie) req and res
    createServer() is going to take the request using req parameter and return response using res parameter. Inside that we call statusCode property of response and provide as 200, then we call setHeader() and provide the contenttype as text/plain, finally call res.end() 

const server=http.createServer((req,res)=>{
    res.statusCode=200;
    res.setHeader("Content-Type","text/plain");
    res.end("Welcome to HTTP server");
})  

So when we get the successful request from the browser, we will return statuscode 200 which tell browser everything is ok (ie) successful response and set the type of content using setHeader(), next we end the response using end(). So when browser request something then we return above data using end() method. end() is used to help us to end the response process 

4. Now we call listen() of server and specify port, hostname and 3rd argument as callback function. If the server is successfully started then we get callback functions console message on the terminal 

server.listen(port, hostname, ()=> {
    console.log('Server running at http://${hostname}:${port}/');
})

>node index.js
    We can see message "Server running at http://localhost:3000/", when we click on the link it will open in browser and we can response on webpage as "Welcome to HTTP server"

Instead of writing 2 lines to define statuscode and header, we can use 
  res.writeHead(200,{"Content-Type":"text/plain"})
If we want to send the response independently we call
  res.write("Welcome to HTTP server");
  res.end();


const http=require("http")

const hostname="127.0.0.1"
const port=3000;

http.createServer((req,res)=>{
    res.writeHead(200,{"Content-Type":"text/plain"})
     res.write("Welcome to HTTP server");
  res.end();
}).listen(port, hostname, ()=> {
    console.log('Server running at http://${hostname}:${port}/');
})  


Making HTTP request 
     We use http request to send the request to the server and get response from the server 
    So here we make get request using get() where we first provide the url and as a 2nd arg we need to specify callback function as arrow function where we get the response from the url. So here we fetch info from this api and call on(), to this method we specify 2 argument, 1st arg is data where we get the data from url then on() will automatically trigger and as 2nd arg we pass callback function and add all data to variable called "chunk" 
    So inside get() we call another method on(), this method takes the event as 1st argument and callback function as 2nd argument. The data event collects the data from the request. 
   Next we call another method on() to end this request and to this on() we pass event called end and with callback function which just prints data. So we are going to get all data from chunk variable and concatenate it with this data variable and then we print data variable by ending the request using end event

const http=require("http")

http.get('http://api.open-notify.org/astros.json',resp => {
    let data='';
    resp.on('data',chunk=> {
       data+=chunk
    });

    resp.on('end',()=>{
        console.log(data)
    });
})

>node index.js
     
So openapi is going to return the result so once all the data have been received from the request using data event, the on() end event will automatically fired and then we get the result. This url will return the data as String, if we want to convert the result to json format we use json.parse() method

const http=require("http")

http.get('http://api.open-notify.org/astros.json',resp => {
    let data='';
    resp.on('data',chunk=> {
       data+=chunk
    });

    resp.on('end',()=>{
        let jsonData=JSON.parse(data)
        console.log(jsonData)
    });
})

Now we get the data in json format 


HTTP POST request 
    We discuss 2 different ways to perform post request 

1. Import http module
    const http=require("http")

2. Next we create data variable so we can pass this data with the http post request 

const data=JSON.stringify({
    name:"John",
    Job:"Writer"
});

3. Now we create a http request using request() which takes 2 argument, first we specify url of the api as hostname, port, content type, method as separate variable called options and 2nd is the callback function 
 
const options = {
    hostname: 'reqres.in',
    path: '/api/users',
    method: 'POST',
    header: {
       'Content-Type':'application/json'
    }
};

Inside callback function we define a variable called data where we store all response data, next we print status code. Then we call on() to specify event data as 1st arg, so when we get the data from url this event will automatically fired and execute the callback function and as 2nd arg  we specify callback function which get url data in chunk variable and concatenate with data variable 
   Next we call another on() method and call an  event end, so when request is successfully end we just return callback function which just print the message

const req=http.request(options, (res)=>{
    let body='';
    console.log("Status Code: ", res.statusCode)

    res.on('data',(chunk)=>{
        body += chunk;
    })
    res.on('end',()=>{
      console.log("Body:",JSON.parse(body));
    })
})

So with post request we send some post data, so we have req object so we use that object to send some data

req.write(body)
req.end();

> node index.js
     We will get an error since most of node appl use http modules but many api will block the request because of the SSL issues, to solve this problem so we make this request as https, so we specify
    const http=require("https");
In nodejs https module is implemented separately, this module is used to make a request to any server 

>node index.js
    We get expected output, so using secure https we will not get any SSL issue, so in output we can see status code 201 which is the successful status code of api and then we have body with json data 

So to make post request we have to write more lines of code, so instead we can use axios library 

1. Install axios library
>npm i -S axios

2. Import axios modules

const axios=require("axios");

const data=JSON.stringify({
    name:"John",
    Job:"Writer"
});

axios.post('https://reqres.in/api/users',data).then(res=>{
     console.log(`Status Code:${res.status}`);
     console.log(`Body: ${res.data}`);
}).catch(err => {
   console.log(err);
})

Now we call post() of axios, as first arg we specify url of api, as 2nd arg we get the data from this url, once we have the data we can use then() method which allows to create async code. Inside then() method we call a response and specify the callback function 

>node index.js
    We will get the data with status code and body as object, but if we want to print as Json we can use JSON.stringify()

 console.log(`Body: ${JSON.stringify(res.data)}`);


Express JS
    ExpressJS is application framework for NodeJS, it provides various features that provides web appl development fast and easy which takes more time using nodejs. Express is built on top of nodejs, so any functionalities of node can be used in express appl. 
   Express is similar to JQuery, the developer often have to write boilerplate code in JS, jquery exist to cut down all this boilerplate code by simplifying the api of browser and help to write new features. Express exist to cut down all these boilerplate code by simplifying the api of nodejs and help with new features in Express appl
   Express is small framework that sits on top of nodejs web server functionality to simplify its api and  help with new features. 

Express Features
1. Simple web server 
       Express appl provides convient basic web server creation which is essential to build nodejs appl

2. Middleware 
       It uses very flexible and middleware pattern with special functions to process different requests 

3. Functional programming
       Express is frequently functional prg and uses the nodejs core concepts like event emitter, streams etc

4. Restful api
       Express is used to built restful api faster, express supports MVC architecture with little work, we also work with HTML template with PUG or EJS template engines which reduce the amount of HTML code to write a page
       
5. Templates and databases
      Express also supports nosql database and simple to implement it, we can also create relational db like mysql and other lang

1. Create express-app folder 

2. We need to initialize this appl as npm package
>npm init

3. Install express
>npm i express --save

4. Create server.js file inside express-app folder

- First we need to import express module
       const express=require("express");

- Next we create express appl using
       const app=express();

- Next we create http server using express framework using get(), inside method we provide the path as 1st srg, and 2nd arg is callback function with req and res, inside callback function we send the response using send()
   app.get("/ping',(req,res) => {
       res.send("Node Express Appl")
   });

- Now we listen to server on port 
app.listen(3000,()=>{
    console.log("Server started at port 3000")
});

>node server.js
     Here we have created a http server with express and in browser if we give http://localhost:3000/ping we can see the response 

So when we change anything in code and if we refresh the browser, the changes will not be reflected. In order to reflect the changes we have to restart the server but each time we cant restart the server, for that purpose we can use nodemon module 

>npm i nodemon 

- In package.json, we create the start command

"scripts":{
   "test":"--------",
   "start":"nodemon server.js"
}

- Now we can start the app using
> npm start

So when we change anything the server will be automatically restarted 


Middleware
    - It is one of important concepts in Express appl, middlewares is very similar to request handler we saw in node appl which accept the request and sending back response. But middleware has one important difference rather than having just one handler, middleware allows to have many in sequence 
     Middleware functions are functions that have access to request and response object and next() function in appl req-res cycle. next() function is the function in express router which when invoked execute the middleware succeeding the current middleware 

Middleware can perform 3 major tasks
  Making the changes to the req and res object and req res cycle and call next middleware in the stack

Example
    Consider we want to create a login system with authentication, we send the request to the route but before that we call middleware function that authenticate the user using request. If the user is valid then use next() function and move further otherwise return the response
   Middleware functions can work with request and response object so we can manipulate response object using middleware functions 

1. Here we create a simple middleware function called myLogger, so we will print log when a request to the app passes through it 

- Import express module
     const express=require("express");
- Now we create express appl
     const app=express();
- Now we create a variable called myLogger and create a function with 3 parameters like req,res,next and print in console, after that we call next() function, calling this function will invoke next middleware function in this appl
   const myLogger=functin(req,res,next) {
      console.log('LOGGED');
      next();
   }
- Now we use middleware function in our express appl using use()
   app.use(myLogger);
- Now we load this middleware function by giving a request
   app.get('/',function(req,res){
    res.send("Home Route");
   })
   app.listen(3000,()=>{
       console.log("Server started at 3000");
   })

>npm start
     Now server will start in port 3000, in browser we run http://localhost:3000/, we get response as "Home Route" in browser and in the console we can see output as "LOGGED". So whenever everytime we make http request then the middleware will always executes, so middleware is best place where we can add login and authentication program

- Now we create another middleware 
     
const express=require("express");
const app=express();      
   
const myLogger=functin(req,res,next) {
      console.log('LOGGED');
      next();
}

const requestTime=function(req,res,next){
    req.reqTime=Date.now()
    next()
}

app.use(myLogger);
app.use(requestTime);

app.get('/',function(req,res){
    res.send(`Current time:${req.reqTime}`);
})
app.listen(3000,()=>{
       console.log("Server started at 3000");
})

Now when we run we can see currenttime in browser and in console first it executes myLogger middleware and then requestTime middleware, so order of loading middleware functions are depend on how we have defined 

How middleware functions are execute in node appl?
     So when we specify the use() method to use this middleware function, then node appl will put both these middleware functions in middleware callstacks, in that callstack it put myLogger in first position and requestTime in second position and then middleware callstack will execute this middleware functions one by one, first myLogger will be execute once process is completed and then using next() function it executes the next middleware and once process of requestTime middleware is completed, the next() function will tell middleware function to execute next middleware function where it execute the route "/" and prints message to the user 

Serving static files in Express
    When building web server with Express, its often required to serve combination of dynamic content and static files because node is not a web browser it is a server, we need to inform which file to use. So to serve static files such as images, css files and JS files we use express static() method, this is built-in middleware function in express which allows us to work with request and response object and it also allows us to add many new functionality  in appl when we make request 

1. Create public folder inside express-app folder, which have all static files like css, js, images. Now we want to use this static files in ur appl by using middleware function

const express=require("express");
const app=express();

app.use(express.static('public')); //using this stmt we tells the webserver that to use all static files of this public folder 

app.get("/',(req,res) => {
       res.send("Static files")
});
app.listen(3000,()=>{
       console.log("Server started at 3000");
})

So if we want to use anything from public folder (ie) root dir we can provide
    <img src="/photo.jpg"></img>

But consider if we want access files which is not inside public folder, inside public folder we create another folder called static and that contains image, how we can access that image, in that case we can create a virtual path prefix

app.use('/public',express.static('static'));
    
So here use() will take root path (ie) public and take the file from where we want to serve the static files, now next problem comes is what if we change the static folder name or the root folder name, in that case we need to change the hard coded value 
   For example if we change public to some other nam, we need to change the code as well, to avoid it we can use path module 

const express=require("express");
const path=require("path");
const app=express();

const publicpath=path.resolve(__dirname,'public')
app.use(publicpath,express.static('public'));

app.get("/',(req,res) => {
       res.send("Static files")
});
app.listen(3000,()=>{
       console.log("Server started at 3000");
})


Routing with Express
      Routing is one of most important topic in express appl or node appl because without routing we couldnt create any http request. Routing enables us to send and get the http request 
      To create a route we need to initialize ur express appl and call http request method like get,post, put,delete and so on. Once u specify http request, the first arg is the path of ur route so when the user enter the path then the request send to the server and get the response from the server. Next we have handler function as 2nd argument, this function is executed when the route is matched 

Example

const express=require("express");
const app=express();

const PORT=3000;

const data={
   id:1,
   name:"India"
}

app.get("/",(req,res)=>{
  res.end("Welcome to homepage");
})
app.get("/about",(req,res)=>{
  res.send("Welcome to About page");
})
app.get("/weather",(req,res)=>{
  res.send("The current weather is hot");
})

app.list(PORT,()=>{ console.log("Server starting at port",POST)});

>npm start 
    We can see server is started and open the browser and we give

http://localhost:3000/
http://localhost:3000/about
http://localhost:3000/weather

So using route we can send different response to the user, but now we dont want to send static data but we want to send some variable or data that is stored in the database, lets say we fetch the data from db and get the data something like an object and we store that object in data variable and now we want to return that data when the route is matched 

app.get("/weather",(req,res)=>{
  res.send(data);
})

Save the changes and reload the browser we can see the data as a result, but we can see the content type is an object, in case if we dont know what type of response the server is sending, this may be a problem with response. But there is another way to send the response using http server, we can send any data as a response with json type using 

app.get("/weather",(req,res)=>{
  res.json(data);
})

Save the changes and reload the browser we can see the data as a json type
    Express can also send a file as a response, express add methods like sendFile() which send a whole file as a response

app.get("/weather",(req,res)=>{
  res.sendFile('/static/index.html');
})

Views in Express
    As we know websites are built in html in long long times, but now we want a server to dynamically genetate html, we want to serve html that creates the currently login user or we want to dynamically generate the data table. To create dynamic html we have different view engines, there are different template engines we can use with express appl to create dynamic html like EJS(Embedded JS), Handlebars, PUG etc
    In template engine we can use many JS syntax like for, while loop, if else condition etc. The template engine replace the variable in the template file with actual values and transform the template into html file and send to the client

Example
1. Install PUG module
>npm i pug --save

2. Import express module and create express appl

const express=require("express");
const app=express();

const PORT=3000;

3. Next we need to inform express appl from where it needs to get the template files, so we call method set() of express appl, within this method first we pass template engine name 
     app.set('view engine','pug');

4. To create the views, first we need to create a folder called "views" inside project, which is the default dir of views engines. If we want to change this directory we need to call set() again with template directory name 
   For example, if we provide some other name like "htmlfiles" for "views" folder, then we have to give as 
   app.set('views','/htmlfiles');
If we provide default dir "views" then no need to use above line

5. Create index.pug inside views folder because we are going to create dynamic html
   In pug language we just have to specify tag name, there is no need to close the tag, and then specify indention so when we specify here indention then all tags are created inside html tags 

doctype html
html
  title Express View Engine
  body
    h1 Express Application
    p Express Template Engine

6. Now we create a route to render this page in server.js file, using render() to render the templates

app.get('/',function(req,res){
   res.render('index')
}).listen(PORT,()=>{console.log('Server started on http://localhost:3000')});

>npm start
    We can see the server is started in 3000 and in browser if we give http://localhost:3000/ we can see the output of template engine 

7. Now instead of defining all hardocded values in pug file, we want to pass values from the server. So in pug file we declare the variables and pass from the render()

doctype html
html
  title= title
  body
    h1= h1
    p= p


app.get('/',function(req,res){
   res.render('index',{title:'Express View Engine',h1:'Express Application',p:'Express Template Engine'})
}).listen(PORT,()=>{console.log('Server started on http://localhost:3000')});

When we save the changes and reload the browser then we will have the same output but this time we are going to have variable from server instead of hardcoded value 


Express Advanced Concept
      We will discuss about session, cookies, core middleware, core routing and core views

1. First we create a form in express, we create http server in server.js

const express=require("express");
const path=require("path");
const app=express();

const PORT=process.env.PORT || 3000

app.set("views",path.join(__dirname,"views"));
app.set('view engine','pug');

app.get('/',(req,res) {
    res.render("index",{title:"Form Handling"});
})
app.listen(PORT,()=>{
  console.log(`Listening to requests on http://localhost:${PORT}`);

2. We create simple form in index.pug file

doctype html
html
  title #{title}
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css" integrity="sha384-TX8t27EcRE3e/ihU7zmQxVncDAy5uIKz4rEkgIXeMed4M0jlfIDPvg6uqKI2xXr2" crossorigin="anonymous"> (no need to convert link tag in pug lang)
  
  body
    div.text-center
       h1.h1.py-4 Simple Form
    div.container.text-center.w-25
      form(method='POST', action='/form-submit')
        div.form-group
          input(type='text',name='username',class='form-control',value='',placeholder='Username')
        div.form-group
          input(type='text',name='email',class='form-control',value='',placeholder='Email')
        div.form-group
          input(type='submit',class='btn btn-primary',value='Submit')

>npm start
    When we run http://localhost:3000/ it will open simple form in browser

3. Now we are going to submit the data and get all the data using post request 

app.post('/form_submit',(req,res)=>{
  const username=req.body.username
  const email=req.body.email
  res.end('You username is: ${username} and Email is: ${email}');
})

When we give input and click submit button, we get an error because we didnt serialize the data, so we need to serialize the data when u submit the form using encoding we can serialize the data 

app.use(express.urlencoded({
   extended:true
}))

Now when we run and provide the values in textbox and click submit button we can see the output  


Session in Express
     Sessions are used to to track the user activities 

1. Create server.js with express module and define express appl, next we create a port to listen to that appl

const express=require("express");
const app=express();

const PORT=process.env.PORT || 3000

app.listen(PORT, ()=> {
   console.log(`Listening to requests on http://localhost:${PORT}`);
})

2. Install express-session module
>npm i express-session 

3. Import session module
     const session=require("express-session");

4. To setup the session we need to use session module as middleware using app.use(), we are going to use the session middleware module
   Inside use() we call session() method and specify parenthesis, inside it we pass some arguments like secret which hold the secret key for ur session. Next we call a property called "resave" as true which will force the session to be saved 
and "saveUninitialized" as true which is going to force a session that is uninitialized to be saved and stored 
    Using the secret property we can store any secret key inside the secret variable 

app.use(session({
    secret: "Your secret key",
    resave: true,
    saveUninitialized: true
}));

5. Next we create different routes, first we create get request with req and res parameter, and inside this callback function we are going to create session variable called name with "John" value and finally return the response using send()

app.get('/'.(req,res)=>{
    req.session.name="John";
    return res.send("Session Set")
})

6. Next we want to get this session variable on different route, so we create another route called /session and specify callback function with req, res parameters, so when we request on /session route we want to return the session variable 
    So we will call session variable name and specify to variable called "name" and finally return name

app.get('/session',(req,res)=>{
   var name=req.session.name;
   return res.send(name);
})

7. Save and run the appl
>npm start
    It will start the server at 3000, and run in browser as 
http://localhost:3000/ - we get msg "Session Set"
http://localhost:3000/session - we get session variable "John"

So when we start the server we first store the secret key inside the property called secret, then we create get request on '/' route and create a variable called name and specify value to it, then we send the response "Session Set". Next we create another route called /session, in that we access session variable using req.session.name which return the session variable to "name" variable and return the value using send()

8. In case if we want to destroy this session, so we create another route '/destroy' and specify callback function with req,res, inside that we call req.session.destroy() which destroy the session and specify callback function with error, so if there is any error so we get data inside error function 

app.get('/destroy',(req,res)=>{
   req.session.destroy(function(error){
      console.log('Session destroyed');
   })
   res.end();
})

9. Save and run the appl
>npm start
    It will start the server at 3000, and run in browser as 
http://localhost:3000/ - we get msg "Session Set"
http://localhost:3000/session - we get session variable "John"
http://localhost:3000/destroy - we wont get anything in browser but in terminal we get "Session destroyed", now if we run 
http://localhost:3000/session - we wont get anything because session is destroyed completely 

Cookies
    Cookies are small data that are stored on a client side and sent to the client along with server request. Cookies have various functionalities, they can used for maintaining sessions and adding user specific features in ur web appl
    
1. Create simple HTTP server

const express=require("express");
const app=express();

const PORT=process.env.PORT || 3000

app.listen(PORT,()=> {
   console.log(`Listening to requests on http://localhost:${PORT}`);
})

2. To work with cookie we need to install cookie- parser module
>npm i cookie-parser

3. Now  we create route for home page

app.get('/',(req,res)=> {
   res.send("Cookie Tutorial");
});

4. Now we create simple variable and store that variable data inside the cookies, so first we import cookie parser module in appl

const cookies=require("cookie-parser");

Now we use this module as middleware using use()
   app.use(cookies());
So this stmt will allows us to use this module and create cookies

5. Next we create next request called /setuser, inside that we use res.cookie() and create a variable called userData
   So we create a cookies using cookie() and specify variable name "userData" and specify value to it. So we create new variable called users with key value pair

let users={
    name:"John",
    age:28
}

Now we store this data into userData variable

app.get('/setuser',(req,res)=> {
   res.cookie("userData",users);
   res.send('User data added to cookies');
})

6. Now we get all cookies data into different route

app.get('/getuser',(req,res)=>{
    res.send(req.cookies);
})

>npm start 
   It will start the server, in browser we have
http://localhost:3000/ - Prints "Cookies Tutorial"
http://localhost:3000/setuser - Prints "User data added to cookies" and set the cookies inside the client browser 
http://localhost:3000/getuser - Prints all cookie info 

7. To destroy the cookies

app.get('/logout',(req,res)=>{
    res.clearCookie('userData');
    res.send('User logout successfully');
})

npm start 
   It will start the server, in browser we have
http://localhost:3000/logout - Prints 'User logout successfully' and cookies will be deleted
http://localhost:3000/getuser - Prints only cookies ssid, we can see cookie info called userData


Creating Login Application with Express and Node
https://github.com/akashyap2013/Login_Express_App

Create login system, we add panel and inside it we add title "Login System" and with 2 input text box and submit button. When the user specify valid email and password we just redirect the user to the dashboard of the website 

1. Create login_system folder 

2. Initialize the project as npm package
>npm init -y
   -y which skip all the questions and create default package.json 

3. Install modules for the project
>npm i express nodemon ejs express-session body-parser uuid

4. Create views folder inside project 

5. Create base.ejs inside views folder 
   - Type ! and press tab which create simple html  snippet 

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title><%= title %></title>
</head>
<body>
  <h2>Login System</h2>
</body>
</html>

6. Create http server in server.js inside project

const express=require("express");
const app=express();

const PORT=process.env.PORT || 3000;

app.set('view engine','ejs');

app.get('/',(req,res)=>{
  res.render('base',{title:"Login System"});
})

app.listen(PORT,()=> {
   console.log(`Listening to requests on http://localhost:${PORT}`);
})

7. Here we have simple lines of code in this html file but what if we have 1000 lines of code inside html page, in that case ur project is hard to manage for this reason we use programming principle called separation of concern, using that we separate the code in different file so we can easily manipulate it 

- Create header.ejs inside views 

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title><%= title %></title>
</head>
<body>

- Create footer.ejs

</body>
</html>

- In base.ejs we provide

<%- include('header') -%>
<h2>Login System</h2>
<%- include('footer') -%>

Now when we run nothing will change but the code is more accurate 

8. In order to design the form we use bootstrap, so we copy <link> for bootstrap and paste in header.ejs

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.1/css/all.min.css" integrity="sha512-+4zCK9k+qNFUR5X+cKL9EIR+ZOhtIloNl9GIKS57V1MyNsYpYcUrUeQc9vNfzsWfV28IaLL3i96P9sdNyeRssA==" crossorigin="anonymous" />

Now we can use all bootstrap class inside ur webpage

- In base.ejs, we create div with class text-center

Type .text-center.center-div and press tab, it creates <div> tag with above classes. If we type .text-center.center-div#login and press tab, it create <div> tag with 2 class and 1 id

<div class="text-center center-div" id="login">
    <div class="container w-25 border py-5">
        <div class="title pb-5">
            <h2 class="font-weight-bold">Login System</h2>
            <span>Log in for the existing user</span>
            
        </div>
        <form action="/route/login" method="POST" class="pt-3">
            <div class="form-group">
                <input type="email" class="form-control" placeholder="email" name="email">
                <small class="form-text text-muted text-left">Register email address</small>
            </div>
            <div class="form-group">
                <input type="password" class="form-control" name="password" placeholder="password">
            </div>
            <button type="submit" class="btn btn-success rounded-pill">Submit</button>
        </form>
    </div>
</div>

9. Create public folder inside project 
10. Create style.css inside public folder 

11. Inorder to load the static files from public folder, we provide code in server.js

const path=require("path");

app.use('/static',express.static(path.join(__dirname,'public')));

12. Now add style.css inside header.ejs

<link rel="stylesheet" href="/static/style.css">

@import url('https://fonts.googleapis.com/css2?family=Open+Sans&display=swap');

body{
    font-family: 'Open Sans', sans-serif;
    background-image: url('/assets/background_png.png');
    background-size: cover;
    background-repeat: no-repeat;
}

.center-div{
    padding-top: 10%;
}

.btn.btn-success{
    padding: .4em 2em;
}

form{
    padding: 0 3em;
}

#login .title > span{
    font-size: .8em;
}

12. Copy image inside assets folder of public folder and inside server.js configure 

app.use('/assets', express.static(path.join(__dirname, 'public/assets')))


13. After creating the form, we add login and logout features. For that first we import body-parser module in server.js

const bodyparser=require("body-parser");

app.use(bodyparser.json())
app.use(bodyparser.urlencoded({extended:true}))

Bodyparser module is responsible for passing the incoming request bodies in the middleware before we use it 

14. Next we create session in server.js using express-session, so we import the module so that we can create session variable 

const session=require("express-session");

app.use(session({
   secret:'secret',
   resave:false,
   saveUninitialized: true
}));

Here we specify the hardcoded value for secret, in case if we want to make session completely secret from the user so we can use hash value instead of string value "secret"
    We have already install UUID module which will create hash value with uuid method, so first we import uuid module

const {v4:uuidv4} = require("uuid");

Now we call this method to generate the string hash value for ur secret and make ur session completely secret and unique 

app.use(session({
   secret:uuidv4(),
   resave:false,
   saveUninitialized: true
}));

15. We see about simple error when we work with template engine. In case if we give wrong variable titl in route

app.get('/',(req,res)=>{
  res.render('base',{titl:"Login System"});
})

So if we run the appl we get an error title is not defined because we have use title variable in header.ejs. To solve this problem we use locals.title which will get all local variable of ejs template engine and check using if else condition

<title><%= locals.title ? title:'Login System' %></title>

Now it will display as Login System if title variable is not present 

16. We create router.js inside project to define all routes
    Now we create /login route, so when we provide email, password and when we click submit button we redirect to /login route and we get the values using req.body.email. We check whether email and password are matching then we set email to session variable user and if not we just print message

var express=require("express");
var router=express.Router();

const credential={
   email:"admin@gmail.com",
   password:"admin123"
}

//login user
router.post('/login',(req,res)=>{
   if(req.body.email == credential.email && req.body.password == credential.password){
      req.session.user=req.body.email;
      res.end('Login successful');
      //res.redirect('/route/dashboard');
   }else {
        res.end('Invalid Username');
   }
});

module.exports=router;

17. Now we add router.js file in server.js

const router=require('./router');

app.use('/route',router);

So this middleware will add all this router inside the server, so when we want to execute /login, then we want to specify as /route/login 
  
>npm start  
    When we give email as admin@gmail.com and password as admin123, then it will redirect to /route/login and prints Login successful, in case if we provide wrong email and password it prints as Invalid username 

18. Now we create dashboard.ejs inside views folder 

<%- include('header') -%>

<div class="text-center center-div mt-5" id="login">
    <div class="container w-25 border py-5 mt-5">
        <h3>Welcome to Express Dashboard</h3>
        <h5><%= locals.user ? user : "User" %></h5>
        <a href="/route/logout">Logout</a>
    </div>
</div>

<%- include('footer') -%>

19. Next we create route for /dashboard

// route for dashboard
router.get('/dashboard', (req, res) => {
    if(req.session.user){
        res.render('dashboard', {user : req.session.user})
    }else{
        res.send("Unauthorize User")
    }
})

Here we check for user session variable and render to /dashboard along with session variable user

20. Now we define the route for logout 

router.get('/logout', (req ,res)=>{
    req.session.destroy(function(err){
        if(err){
            console.log(err);
            res.send("Error")
        }else{
            res.render('base', { title: "Express", logout : "logout Successfully...!"})
        }
    })
})

So when we click Logout, we want to redirect to login page and destroy the session. If any errors we display the message otherwise we redirect to base.ejs page with title and logout variables 

21. Now we want to display logout message in base.ejs on successful logout, so after <span> tag in base.ejs

<% if(locals.logout){ %>
                <div class="alter alert-success text-center">
                    <%= logout %>
                </div>
            <% } %>

So when we run the appl, when we click logout it will destroy the session and display the message

Creating Middleware Application
    We create simple middleware appl that serves files from the folder. We will see how we can create a folder that serves different files to the requested user, user can request html file, images or any file
    The requirement is ur server should log every request whether or not its successful, then the appl should check if the file exists in the folder or not, if it does it will send that file over the internet it will continue on to the final middleware. The last requirement is if the appl didnt find the file it should return 404 message and fiinsh up the request 

1. Create middleware_app folder
2. Initialize as npm
      >npm init -y
3. Install modules
      >npm i express nodemon  
4. In package.json, we configure
"scripts":{
   "start":"nodemon server.js"
}

5. Now we create static folder inside the app and inside it we put all the files that we want to serve to the user 
   Create static folder inside middleware_app folder
   - Create cool.txt file and give Express Middleware appl
   - Create app.json file and give 
{
   "app":"Middleare App",
   "version":"1.0"
}  
   - Copy and paste one image inside static folder

Now we serve this files to the user when the user request these files 

6. Create server.js file inside project 

const express=require("express");
const path=require("path");
const fs=require("fs");

const app=express();

const PORT=process.env.PORT || 3000;

app.use(function(req,res,next){
   console.log("Request Date:"+new Date());
   next();
})

app.listen(PORT,()=> {
   console.log(`Listening to requests on http://localhost:${PORT}`);
})

7. Now we see how to serve the static file to the user, so in middleware we check if the requested file is exist in the static dir or not, if it exist respond with the file and if dosent exist continue to the next middleware in the stack 
    Using path we get the path of the requested url to determine whether the file is exist or not.
    Now we create another middleware using app.use(), we can notice that we have 2 middlewares inside this appl, so once first middleware is finish then this will call next() and execute the next middleware
    Inside the middleware we create a variable called filepath and call join() of path module and specify __dirname which returns project directory name (ie) middleware_app and next arg as static and next as req.url (ie) we are getting url from the user, when the user specify url in the browser so we get that url and create a path of the requested file 
    Next we call fs.stat() with filepath and callback function which takes err as 1st arg and fileinfo as 2nd arg. If there is a error while reading the file then we move to next middleware using next() and return from this method 
   Next we check if it is a file, then we send that file using sendFile() or execute the next middleware 

app.use(function(req,res,next){
  var filepath=path.join(__dirname,"static",req.url);
  fs.stat(filepath,function(err,fileinfo){
    if(err){
       next();
       return
    }
    if(fileinfo.isFile()){
        res.sendFile(filepath);
    }else {
        next()
    }
   })
});

>npm start 
    In browser we can run
http://localhost:3000/cool.txt - opens cool.txt
http://localhost:3000/app.json - opens app.json

8. In case if ur requested file is not in server
http://localhost:3000/abc.txt - we get error msg

So we add another middleware to handle this problem and it is executed only if the file is not found in the url 

app.use(function(req,res){
   res.status(404);
   res.send("File not found");
})

To this middleware we didnt specify next arg because we have specified res.send() to end this response. If we run

http://localhost:3000/abc.txt - it display 404 error msg 

If we paste the last middleware in the first of stack and if we give correct url also, we will get File not found message because the order of middleware stack is very important, so make sure ur requests flow through in a proper order 

Logger application with Morgan 
     Morgan is basically a logger, any request we made it generates a log automatically. Morgan is a popular http request middleware logger for nodejs, morgan used to log a message on the console whenever we make the request. Morgan is 3rd party middleware so we need to install it and use it using app.use()
    We create a simple app that will add an id to all the requests and display it using id token 

1. Create morgan_app project
2. Initialize this project as npm module
     >npm init -y
3. Install modules
     >npm i express nodemon morgan uuid
4. Configure package.json
"scripts":{
   "start":"nodemon server.js"
}

5. Create server.js 

const express=require("express");
const morgan=require("morgan");

const app=express()
const port=3000;

//Morgan module is not inbuilt in node, so install and use it with different parameters like combined,common,div,short,tiny. We can use this tokens to display some useful messages, if we want to print all the info of the logger we can use combined token or if we want to create short or tiny console message we can use short or tiny parameter
app.use(morgan('combined'));

app.get('/',(req,res)=>{
   res.end("Morgan Logger App");
})

app.listen(port,()=>{
   console.log(`Server is running on http://localhost:${port}`)});

>npm start 
     When we run http://localhost:3000/, then we can see very long message in console. If we change to tiny and reload the browser we can see tiny console message 


Exception Handling
      Every appl must handle errors, errors in nodejs are handled through exceptions. An exception is created using throw keyword, usually in client side it can be any JS value including string, number or an object. In nodejs we dont throw strings we just throw an error object, an error object is an object that is either an instance of an error object or extend an error object. If we want to throw error message to the user, we can use
    throw new Error("Error message");
Even we can handle error using try catch block
    try {
       //lines of code
    }catch(e){  }

We can handle exception using promises, using promises we can change different operation and handle errors 
    doSomething1()
        .then(doSomething2)
        .then(doSomething3)
        .catch(err => console.error(err))
We called a function doSomething1() and chain some methods with it, we execute doSomething2 once first method is finished, then we execute doSomething3 when second method is finished and execute catch if any error in the above methods 

doSomething1()
   .then(() => {
        return doSomething2().catch(err => {
           throw err;
        })
    })
    .then(() => {
        return doSomething3().catch(err => {
           throw err;
        })
    })
    .catch(err => console.error(err))

What is Buffer?
     Buffers were introduced to help developers to deal with binary data. In an ecosystem that traditionally deals with strings rather than binaries
     Buffers are deeply linked with streams, when the stream processor receives data faster than it can digest, it puts the data in a buffer. Stream in nodejs simply means a sequence of data being moved from one point to other point over time 
     So whole concept is we have huge amount of data to process but u dont need to wait for all the data to be available before you start processing it 

Example 1:
const buf=Buffer.from('Hey');

console.log(buf); //It print some ref, since buffer                      is like an array

console.log(buf[0]); //72 - unique code of H
console.log(buf[1]);
console.log(buf[2]);

Example 2:
const buf=Buffer.from('Hey');

console.log(buf.toString()); //Hey - we can print message using toString()
console.log(buf[0]); //72 - unique code of H
console.log(buf[1]);
console.log(buf[2]);

Example 3: We can write whole string into buffer using write()

const buf=Buffer.alloc(4);
buf.write('Hey')
console.log(buf.toString()); //Hey

console.log(buf[0]); //72 - unique code of H
console.log(buf[1]);
console.log(buf[2]);

buf[1]=111; //unique code of o
console.log(buf.toString()); //Hoy


NodeJS testing using Mocha and Chai

What is Mocha?
   - It is a testing framework for Javascript, we can use it on the server and on the browser. So ita runs on nodejs and the browser 
   - We can use any assertion library like Chai, should.js etc 
   - Mocha provides the hooks before(), after(), beforeEach(), afterEach(). For example we can use before or beforeEach to setup the database, then after and afterEach to clean up the database
   - Mocha makes easy to test async code and it also provides extensible reporting

What is Chai?
   - It is an assertion library for NodeJS and browser. It can be used with any Javascript testing framework, in this case we use Mocha
   - It provides different styles to write our assertions 
   - We have 3 assertion styles 
1. should 
chai.should();

foo.should.be.a('string);
foo.should.equal('bar');
foo.should.have.lengthOf(3);
tea.should.have.property('flavors').with.lengthOf(3);

2. expect
var expect=chai.expect();

expect(foo).to.be.a('string');
expect(foo).to.equal('bar');
expect(foo).to.have.lengthOf(3);
expect(tea).to.have.property('flavors').with.lengthOf(3);

3. assert
var assert=chai.assert;

assert.typeOf(foo,'string');
assert.equal(foo,'bar');
assert.lengthOf(foo,3);
assert.property(tea,'flavors');
assert.lengthOf(tea.flavors,3);

Difference between them

1. The assert and expect interfaces do not modify Object.prototype, whereas should does. So they are a better choice in an environment where you cannot or do not want to change Object.prototype.

2. The assert and expect interfaces support custom messages just about everywhere. For instance:

 assert.isTrue(foo, "foo should be true");
 expect(foo, "foo should be true").to.be.true;
       
3. First of all, notice that the expect require is just a reference to the expect function, whereas with the should require, the function is being executed.

var chai = require('chai')
const expect = chai.expect
const should = chai.should();
The expect interface provides a function as a starting point for chaining your language assertions. It works on node.js and in all browsers.

4. The should style allows for the same chainable assertions as the expect interface, however it extends each object with a should property to start your chain. 

var should = require('chai').should() //actually call the function
const foo = 'bar'
const beverages = { tea: [ 'chai', 'matcha', 'oolong' ] };

foo.should.be.a('string');
foo.should.equal('bar');
foo.should.have.lengthOf(3);
beverages.should.have.property('tea').with.lengthOf(3);

The should interface extends Object.prototype to provide a single getter as the starting point for your language assertions. It works on node.js and in all modern browsers except Internet Explorer.

https://gitlab.com/pragmaticreviews/node-mocha-chai

1. Create node-testing appl with express, nodemon, joi package

Assume youre working on an endpoint that expects user data such as  username, age, address, pin code, state, and phone number. Consider a user entering numeric data for the username by mistake when youre expecting alphabetic data; a user entering an invalid pin code or birthdate for their respective fields when youre expecting the data in a particular format. You dont wish to make undesirable data! So, you can go for Data Validation to make sure that the data you receive is in a proper format. Joi is the most famous, efficient, and widely used package for object schema descriptions and validation.

const validation = joi.object({
     userName: joi.string().alphanum().min(3).max(25).trim(true).required(),
     email: joi.string().email().trim(true).required(),
     password: joi.string().min(8).trim(true).required(),
     mobileNumber: joi.string().length(10).pattern(/[6-9]{1}[0-9]{9}/).required(),
     birthYear: joi.number().integer().min(1920).max(2000),
     skillSet: joi.array().items(joi.string().alphanum().trim(true))
.default([]),
    is_active: joi.boolean().default(true),
});

2. Create index.js with different endpoints 

3. Create utils/task-schema.js file

const Joi = require('joi');

const validateTask = data  => {
    const schema = Joi.object({
        name: Joi.string()
            .min(3)
            .required(),
        completed: Joi.boolean()
    });
    return schema.validate(data);
};
module.exports.validateTask = validateTask;


4. Start the appl
http://localhost:3000/api/tasks - fetch all tasks

5. Now we test the api using Mocha and Chai, so we install mocha, chai and chai-http as development dependency

>npm install mocha --save-dev 
>npm install chai --save-dev
>npm install chai-http --save-dev


6. In package.json, under scripts we create a property "test" and under that we use a command mocha

scripts": {
    "start": "nodemon index.js",
    "test": "mocha"
  }

7. Inside project create a folder "test", inside that create task.js file

8. First we import chai,chai-http next we import server in our case index.js file. 

let chai = require("chai");
let chaiHttp = require("chai-http");
let server = require("../index");

- Next we have to define assertion style like should, expect and assert, here we use "should" in this case 
         chai.should();

-Next we use chaihttp as a middleware
         chai.use(chaiHttp);
Now we can call restful api using http protocol

9. In order to create a test using Mocha we need to describe our test as "Tasks API" and then we define an arrow function where we do our test 

1. First we need to get all tasks, so we first describe our test with 'GET /api/tasks', and we pass in our function, inside that we call it() with message, then we call "done" object, inside that we use chai where we say chai.request() where we pass server which is actually api. We are going to test get() and we pass resource URL, then we expect using end() where we receive error in case of an error on the server and a response, then we provide the assertions, and finally with done()

let chai = require("chai");
let chaiHttp = require("chai-http");
let server = require("../index");

//Assertion Style
chai.should();

chai.use(chaiHttp);

describe('Tasks API', () => {

    /**
     * Test the GET route
     */
    describe("GET /api/tasks", () => {
        it("It should GET all the tasks", (done) => {
            chai.request(server)
                .get("/api/tasks")
                .end((err, response) => {
                    response.should.have.status(200);
                    response.body.should.be.a('array');
                    response.body.length.should.be.eq(3);
                done();
                });
        });   

    });

});

Now run the test using
>npm test
   Now we can test case will be passed 

Next we check in case if we pass a wrong uri then we get 404 status

it("It should NOT GET all the tasks", (done) => {
            chai.request(server)
                .get("/api/task")
                .end((err, response) => {
                    response.should.have.status(404);
                done();
                });
        });


Node JS Authentication
    - NodeJS implements authentication using Passport.js library.
    - Passport.js is an authentication middleware for nodejs, just like how we create our own custom middleware, this passport is also a middleware with its own set of functionalities. The best part of this libraries are the strategies using which we can implement different types of authentication, so we have strategy of using username and password which is common on, we also have OAuth strategies using Facebook, Twitter, Google etc, strategy using token using JWT 

Session based authentication Strategy
     Consider we have an account created for abc.com website, when we try to login into this website we will pass some sort of credentials (ie) username and password. So backend first validate the username and password with the user that store in the database, once that is done it will create a session for this user and store it in a separate database, it basically maintains a session for this user
   Once the session is created on the database it will send back a cookie to the client. Now this cookie is basically a string with some key value pairs with less value because its being sent across the network for every request, so its not ideal to have a lot of properties inside this cookie, but main property is session id that was created in the backend and sent inside this cookie
      Now that user has got this cookie whenever he makes any further request to this website, the cookie will also be sent in a cookie header. Any request that the user makes after he has logged in, consider he is trying to access his profile, the cookie will also be sent in a cookie header, the server will try to verify this cookie and check session id matches with the session that is stored in its database, if it matches it will give valid response (ie) profile info that the user is expecting
     But the problem with this strategy, it has to maintain state at the backend (ie) if we have million users on this website, the backend has to maintain sessions for all those users so we have to look at how to scale ur appl, if number of users goes beyond the limit. This problem is solved by token based strategy

Token based strategy
     First the user have to pass some credentials, at the backend it will not create a separate session for this user, it takes this username and creates a token out of this username, it will apply some encryption algorithm and create a token out of this username, then it will share the token back to the client. Now once the user has got this token from the backend, any subsequent request that it makes will have this token in a header (ie) inside authorization header 
    Basically the user has to pass in this token for every request after the login. Consider we are trying to access the profile after we have logged in, we will pass the token for the request, then server will look at the token, it will decrypt on its end and check it comes from a valid user, if the token matches it will send back valid response 
    So here there are no sessions being maintained at the backend, there is no extra database space  

1. Create NodeAuthentication project with 
>npm init

2. Install express, nodemon, ejs, mongoose package

3. Configure nodemon app.js in scripts

4. Configure all routes and server in app.js

const express=require('express');
const app=express();

app.get('/login',(req,res)=>{
    res.send('Login get');
})

app.get('/register',(req,res)=>{
    res.send('Register get');
})

app.post('/login',(req,res)=>{
    res.send('Login post');
})

app.post('/register',(req,res)=>{
    res.send('Register post');
})

app.get('/logout',(req,res)=>{
    res.send('Logout');
})

app.get('/protected',(req,res)=>{
    res.send('Protected');
})

app.listen(5000,(req,res)=>{
    console.log('Server is listening at port 5000');
})

5. Start the appl
>npm start

http://localhost:5000/login
http://localhost:5000/register
http://localhost:5000/logout
http://localhost:5000/protected y

6. Create views folder and inside create views for login and register using ejs 

login.ejs
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Login</title>
</head>

<body>
    <form action="/login" method='post'>
        <input type="text" name='username' placeholder="Enter username">
        <input type="password" name='password' placeholder="Enter password">
        <a href="register">New here?</a>
        <button type="submit">Log in</button>
    </form>
</body>

</html>

register.ejs
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>REGISTER</title>
</head>

<body>

    <body>
        <form action="/register" method='post'>
            <input type="text" name='username' placeholder="Enter username">
            <input type="password" name='password' placeholder="Enter password">
            <a href="login">Already have an account?</a>
            <button type="submit">Register</button>
        </form>
    </body>
</body>

</html>

7. To use ejs in app.js we use

app.use('view engine','ejs');

Now we can use ejs view inside the routes

app.get('/login',(req,res)=>{
    res.render('login');
})

app.get('/register',(req,res)=>{
    res.render('register');
})

when we run we can view for /login and /register

8. Install mongodb locally
 
- Download mongo from https://www.mongodb.com/try/download/community
- Install it
- Create c:/data/db folder
- Start mongo
C:\Program Files\MongoDB\Server\6.0\bin>mongod
- Start mongodb compass
C:\Users\senthil.kumart\AppData\Local\MongoDBCompass
Double click MongoDBCompass
- Click Save and Connect 
     It will connect with database
- Click Database tab, we can see default database 

9. We will setup a database, so we create config folder inside create database.js
   - First we import mongoose
      const mongoose = require('mongoose');
   - To connect with mongodb instance 
      mongoose.connect('mongodb://localhost:27017/passport');
    Here we use passport as database name, so mongodb first look for passport database, if it is not present it will automatically create for us 
   - In mongodb first we have to create schema for the objects that we are storing in database, here we store user details so we create user schema. 
      const userSchema = mongoose.Schema({
            username: String,
            password: String
      })
   - Next we have to create model out of the schema
      const UserModel = mongoose.model('User', userSchema);
   - Next export the model so we can use it other prgs
      module.exports = UserModel;

10. In app.js, we first import UserModel 
    const UserModel = require('./config/database');

- Since we are passing form data to express server, we need to parse the body, so we add a middleware which will basically parse the request from the form to the format that we need 
    app.use(express.urlencoded({ extended: true }));

- Now using this UserModel we can create a user in database 

app.post('/register', (req, res) => {
    let user = new UserModel({
        username: req.body.username,
        password: req.body.password
    })

    user.save().then(user => console.log(user));

    res.send({ success: true })
})

11. Start the appl and register the user as
http://localhost:5000/register
  Give some input and click submit button, it will return success as true
  In compass, refresh the mongodb, we can see passport database, click on it we can see users collection which is automatically created by mongo based on the string provided in database.js as
   const UserModel = mongoose.model('User', userSchema);
  Inside the collection, we can see a record with provided values

12. It is not recommeded to store the password as it is, the best way to encrypt the password is to use some encryption algorithm. We use bcrypt.js library, first we install
   >npm install bcryptjs

13. Now instead of passing password as it is, we use bcrypt function

const bcrypt=require('bcryptjs');

Now convert the password using hashSync() function, which takes 2 parameter, first the string and second is no of salt for encryption

password: bcrypt.hashSync(req.body.password,10) 


14. 11. Start the appl and register the user as
http://localhost:5000/register
  Give some input and click submit button, it will return success as true
  In compass, refresh the mongodb, we can see password is stored in encrypted manner 

Express Session and Password local strategy
      Previously we created few users and added them to the database, now we implement express session and also local authentication strategy using passport 
      The basic idea behind session is, whenever a user trying to login to the website, we provide some sort of credentials. The server at the backend  will look at the username and password and see once they are same in the database, then the server creates a session for this user in the database. The session will have sessionid, that sessionid will be added to the cookie and sent back to the browser 
   So whenever the client tries to make any new request after the login, the cookie will be passed inside the cookie header for all those requests. Consider the user is tries to access his profile page, so when he makes the get request, the same cookie from server sent to the user will be passed inside cookie header and sent to the server. The server will verify the cookie with the session id that is stored inside the database and if id is matches then it will send back the valid response and if wont they send back error

1. First install express-session library
>npm install express-session 

2. Import the library

const session = require('express-session')

Next we define session configuration, the session id for the session will be created based on secret key, inside cookie we specify the maxAge property which represents the timer after that the cookie will expire, here we provide as 1 day
   Next whenever we create session we need to store it somewhere else, but by default the server side session storage will happen in MemoryStore, instead we use database to store the session id using connect-mongo package which is mongodb based session store 
   So we pass same database url and inside that we create separate collections for sessions 

>npm install connect-mongo

- import in app.js
const MongoStore = require('connect-mongo');

app.use(session({
    secret: 'keyboard cat',
    resave: false,
    saveUninitialized: true,
    store: MongoStore.create({ mongoUrl: 'mongodb://localhost:27017/passport', collectionName: "sessions" }),
    cookie: {
        maxAge: 1000 * 60 * 60 * 24
    }
}))
 
3. We need to implement login functionality, we need to install passport library, we need the strategy for username pwd authentication which is password-local strategy 

>npm install passport passport-local

This localstrategy is a middleware, so whenever we make post request to /login route, we just pass this middleware and whatever logic we have inside this will be executed for that /login route 

- Create passport.js inside config folder
        Here passport implements LocalStrategy instance which takes a function, inside the function we have username and password which we get from the login form. First we validate the user stored in database is correct user or not. 
       Now it will look for the user with username that is passed inside this function. Inside the callback function, first condition is if we get an error we return done callback function. done() function takes 3 argument (ie) error, user and options. In first case we came across some error so we pass err object inside done()
      The second case there was no error but we didnt get any user maybe user is not created, so we return the done() callback function with null for error, false for user argument and for options argu we pass some message 
      The third case is used to compare the password using compareSync() of bcryptjs library, which takes 2 parameter, first is actual data that we are getting from the form and 2nd argument is encrypted string that we already store inside the database. So compareSync() will do some decryption at its end and checks the encrypted pwd with the stored pwd from database 

const passport = require('passport')
const LocalStrategy = require('passport-local').Strategy;
const UserModel = require('./database')
const { compareSync } = require('bcryptjs');

passport.use(new LocalStrategy(
  async  function (username, password, done) {
       let user= await UserModel.findOne({ username: username });

            if (!user) {  //When username is invalid
                return done(null, false, { message: 'Incorrect username.' });
            }

            if (!compareSync(password, user.password)) { //When password is invalid 
                return done(null, false, { message: 'Incorrect password.' });
            }

            return done(null, user); //When user is valid
        }
));

- Import passport.js inside app.js
      require('./config/passport');

- If we want to use passport we need to initialize it using password.initialize() and implement session in appl we use passport.session()

app.use(passport.initialize())
app.use(passport.session())

- Since we pass this inside /login post route, we pass passport.authenticate() with 2 argument, first is strategy and 2nd is callback 

app.post('/login', passport.authenticate('local', { successRedirect: 'protected' }))

So the appl is redirected to /protected route after the authenticate middleware executed successfully  

- If we are using session, we need to pass 2 function inside passport.js file
   So if the user try to login and we store user details inside the session, so serializeUser() will persist the user data inside session object 

//Persists user data inside session
passport.serializeUser(function (user, done) {
    done(null, user.id);
});

-deserializeUser() will fetch the session object based on the session id that is stored inside session object
//Fetches session details using session id
passport.deserializeUser(async function (id, done) {
   let user = await UserModel.findById(id);
   done(null,user);
});

4. Start the appl and run 

http://localhost:5000/register - register a new user, if we refresh the database we can see users and sessions collection. Inside users we can see user object with password hashed and in session collection we can see "expires" key which basically derives the maxAge property that we defined in session configuration. Inside session key we have cookie with original maxAge, so once we login some extra properties will be added to the session

http://localhost:5000/login - If we try to login with credentials, it will go to /protected route 

Right click Inspect - Network - Headers - we can see cookie property that we basically receive from the session created when we register the user 
   So we can see first 4 char of id char matches with cookie char. Now refresh the session and hover over the session we can see some extra property called passport inside which we can see user string with an id  

When we see the output in console, we can see users collection and session collections, user has an ObjectId with id, the same id is stored in passport property. So this only happen in serializeUser(), so it basically adds user.id property to our session body, so once we logout we cant see this id property in passport 

5. In order to logout we can actually use few methods that are present in request body once password authenticate is completed 

Actually interface Request contains certain properties and these properties are added to request object once the authentication is completed successfully. isAuthenticated() property will tell whether u r authenticated, it returns boolean value. We can use logout() to clear user property from the session 

app.get('/logout', (req, res) => {
    req.logout(function(err) {
        if (err) { return next(err); }
        res.redirect('/login');
      });
})

6. We can also use isAuthenticated() to protect the /protected route 

app.get('/protected', (req, res) => {
    if (req.isAuthenticated()) {
        res.send("Protected")
    } else {
        res.status(401).send({ msg: "Unauthorized" })
    }
    console.log(req.session)
    console.log(req.user)
})

7. Start the appl and run

http://localhost:5000/login - it will redirect to /protected after correct credential

http://localhost:5000/logout - it will redirect to login page

Now if we refresh the session and hover on it, we can see empty property for passport object 


Google OAuth with Password
     We will use session based strategy in this implementation, we keep db configuration and session configuration as it is, only change we do in passport config file and views section 

1. In database.js, we move collection from passport to passport-google 
 mongoose.connect('mongodb://localhost:27017/passport-google');

Since we dont have password here because the authentication method here is through google, we just remove password and add a google id 

const userSchema = mongoose.Schema({
    name: String,
    googleId: String
})


const mongoose = require('mongoose');

mongoose.connect('mongodb://localhost:27017/passport-google');

const userSchema = mongoose.Schema({
    name: String,
    googleId: String
})

const UserModel = mongoose.model('User', userSchema);

module.exports = UserModel;



2. In login.ejs, we dont need form, we just add <a> tag which just redirect to /auth/google route whenever we click on it 

<body>
   <a href="/auth/google">Login with Google</a>
</body>

3. We dont need register.ejs file, we can delete it 

4. We can add file for protected route as protected.ejs 

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=<device-width>, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <h1>Greetings, user <%=name%></h1> <br/>
    <a href="/logout">Logout</a>
</body>
</html>

5. Goto https://www.passportjs.org/docs/ - Click Strategies - Click passport-google-oauth20

- Install passport-google-oauth20
>npm install passport-google-oauth20

- In order to use this we need few credentials - Click Google Developers Console in documentation

- Creste new project 
     Project name: passport-demo
     Click Create
- Now we can create credentials for oauth
     Click Credentials 
     Click Create Credentials - Select OAuth ClientID 
     Click Configure Consent Screen 
     Select External - Click Create 

App Name: Passport-demo-Google
User support email: select email which used to login google platform
Developer Contact info: senthil1418@gmail.com
Click Save and Continue 
Click Save and Continue for scope
Click Save and Continue for Test Users
Click Back to Dashboard 

Click Credential - Click Create Credential - Select OAuth ClientID
Application Type: Web Application
Name: Passport Google

Click Add URI under Authorized Redirect URIs
  URIs 1: http://localhost:5000/auth/callback
Click Create

It will create client id ans client secret, copy and paste it locally somewhere  

- Once we got the credentials, we goto documentation, copy the code and paste in passport.js instead of local strategy 

Inside GoogleStrategy we can pass clientid, client secret and callback url as 1st argument. We can get clientid and client secret from google cloud account, so we can change clientid, client secret and callback url. As 2nd argument we pass a function and we get those values as arguments after successful authentication 
    So whenever we are trying to access the website and login through google, google will gives accesstoken and based on this accessToken, the 3rd party website will know that u r valid user and then only it provide the resource we need. So accessToken is a key to access the resource inside the website. So when accessToken is expired, refreshToken is replaced the accessToken  

const passport = require('passport')
const UserModel = require('./database')
const GoogleStrategy = require('passport-google-oauth20').Strategy;

passport.use(new GoogleStrategy({
    clientID: "409215015377-r40pj09p19ejt239nhb4tdeqb3ppdg4q.apps.googleusercontent.com",
    clientSecret: "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",
    callbackURL: "http://localhost:5000/auth/callback"
  },
  async function(accessToken, refreshToken, profile, cb) {
        let user= await UserModel.findOne({ googleId: profile.id });
 
             if (!user) {  //When username is invalid
                let newUser= new UserModel({
                    googleId:profile.id,
                    name:profile.displayName
                })
                newUser.save();
                return cb(null, newUser); 
            }
            else {
                return cb(null, user);
            }
    })
);

//Persists user data inside session
passport.serializeUser(function (user, done) {
    done(null, user.id);
});

//Fetches session details using session id
passport.deserializeUser(async function (id, done) {
   let user = await UserModel.findById(id);
   done(null,user);
});

Here we are finding a user based on googleId. Here if we dont get user, it means that this is the first time that we are trying to authenticate using google, then we create newUser for googleId so we will give property as googleId and name using UserModel, then we save to database and at the end we return the same callback but with newUser we have created. Finally if we find the user we simply return that user 
    This is Google strategy middleware

6. In app.js, we do some changes 

- In store, we change database as passport-google 
- we can remove /login in post, /register in get and post 

7. In documentation, we can see 2 request, we can paste in app.js

app.get('/auth/google',
  passport.authenticate('google', { scope: ['profile'] }));

app.get('/auth/callback', 
  passport.authenticate('google', { failureRedirect: '/login', successRedirect: '/protected' })
);

The first request /auth/google is a one which we added in login.ejs, so when we click on link we will redirect to /auth/google, inside this request we pass our google authentication strategy, so the middleware we have in passport.js file will be executed when we are on /auth/google route 
   The second one is /auth/callback route, so inside this route based on the status of the authentication, the user will be redirected to particular page. So if there is failure it will redirect to /login route and success means it goes to /protected route 

8. We provide some properties in /protected route 

app.get('/protected', (req, res) => {
    if (req.isAuthenticated()) {
        res.render("protected",{
            name: req.user.name
        })
    } else {
        res.status(401).send({ msg: "Unauthorized" })
    }
    console.log(req.session)
    console.log(req.user)
})

app.js

const express=require('express');
const app=express();
const UserModel = require('./config/database');
const bcrypt=require('bcryptjs');
const session = require('express-session');
const MongoStore = require('connect-mongo');
const passport = require('passport');

app.set('view engine','ejs');
app.use(express.urlencoded({ extended: true }))

app.use(session({
    secret: 'keyboard cat',
    resave: false,
    saveUninitialized: true,
    store: MongoStore.create({ mongoUrl: 'mongodb://localhost:27017/passport-google', collectionName: "sessions" }),
    cookie: {
        maxAge: 1000 * 60 * 60 * 24
    }
}))

require('./config/passport');

app.use(passport.initialize())
app.use(passport.session())

app.get('/login',(req,res)=>{
    //res.send('Login get');
    res.render('login');
})

app.get('/auth/google',
  passport.authenticate('google', { scope: ['profile'] }));

app.get('/auth/callback', 
  passport.authenticate('google', { failureRedirect: '/login', successRedirect: '/protected' })
);

app.get('/logout', (req, res) => {
    req.logout(function(err) {
        if (err) { return next(err); }
        res.redirect('/login');
      });
})

app.get('/protected', (req, res) => {
    if (req.isAuthenticated()) {
        res.render("protected",{
            name: req.user.name
        })
    } else {
        res.status(401).send({ msg: "Unauthorized" })
    }
    console.log(req.session)
    console.log(req.user)
})

app.listen(5000,(req,res)=>{
    console.log('Server is listening at port 5000');
})


9. start the appl
>npm start 

Now we call http://localhost:5000/login, it will have Login with Google link, when we click it will goto gmail page for authentication. When we click on the google account, it will be redirected to /protected route and redirect to protected.ejs page 

If we try to access http://localhost:5000/protected, it will display error message as {"msg":"Unauthorized"} 

10. Inside the database we can see passport-google database with 2 collection sessions and users. If we hover on session we can see passport key with user id which is similar to one which is created in users collections. If we logout we will redirect to login page and in database we have passport value as empty object 


Passport JWT Strategy
     We have seen passport local strategy and oauth strategy, sincve we implements session for both of the strategy, it is called as session based strategy 
     Passport JWT strategy is a token based strategy. So the basic idea behind token based strategy is not different from session based strategy, the different is that in session based strategy we normally store the data in backend, we need to store the user session whenever the user logins in database. But in token based strategy, first the user share some user credentials, in return the server will validate the credentials and then send back the token. The server will use some encryption algorithm and create token out of user details and send it back to user. Whenever user makes any subsequent request after the login, he need to pass the token inside authorization header, the server will check the validity of the token and if the token is valid, it will send back expected data to the user. The only difference that we see from session based strategy is that there is no session stored in backend. So even if number of users goes to billions we dont want to store any info related to user sessions, the authentication still takes place through the token 

1. Create Node project with express, nodemon, cors, bcryptjs, passport, passport-jwt,mongoose packages

2. Create app.js, we use cors because we make request from different domain so the appl is hosted on localhost:5000 and we making request from frontend appl which will on localhost:3000, so we need cors for that 

app.use(express.json());
app.use(express.urlencoded({ extended: true }))
    The above lines are deal with form data, so the username and password fields that will be sending from our form should need to parse and encode it using the above 2 lines

const express=require('express');
const app=express();
const cors=require('cors');

app.use(express.json());
app.use(express.urlencoded({ extended: true }));
app.use(cors());

app.post('/register',(req,res)=>{
    console.log('Register post request');
})

app.post('/login',(req,res)=>{
    console.log('Login post request');
})

app.listen(5000,(req,res)=>{
    console.log('Server is listening at port 5000');
})

3. In database.js, similar one but we create new database called passport-jwt 

const mongoose = require('mongoose');

mongoose.connect('mongodb://localhost:27017/passport-jwt');

const userSchema = mongoose.Schema({
    username: String,
    password: String
})

const UserModel = mongoose.model('User', userSchema);

module.exports = UserModel;

4. In /register route, first we create a UserModel instance where we get username, password from the request body and hash it. Then save the user into database and return the user object with id and name 

const UserModel = require('./config/database');
const bcrypt=require('bcryptjs'); 

app.post('/register',(req,res)=>{
    const user=new UserModel({
        username: req.body.username,
        password: bcrypt.hashSync(req.body.password,10)
    })
    user.save().then(user=>{
        res.send({
            success: true,
            message: 'User Inserted Successfully',
            user: {
                id: user._id,
                username: user.username
            }
        });
    }).catch(err => {
        res.send({
            success: false,
            message: 'Something went wrong',
            error: err
        })
    })
})

5. Start the appl

6. We can test this api by using postman tool, in POST request, http://localhost:5000/register. in Body - Raw - Json

{
  "username":"John",
  "password":"abcd"
}

We get success response, and in database we can see user John has been stored.

7. Now we go for login route, first we need to find the user using findOne() where we pass unique identifier and in our case which is username which we passed as request body.

UserModel.findOne({username:req.body.username}).then(user => {

})

   - First condition if we dont have user which means it is not present inside database so send the error object with status 401 and message. 
   
     if(!user){
         return res.status(401).send({
            success: false,
            message: 'Could not find the user'
         })
     }

   - In case if we find the user, then we need to verify the user, and to compare the password we use compareSync() provided by bcryptjs. Inside compareSync() we provide 2 argument, first one is the password provided in the login form which we get from req.body.password and 2nd argument is hash pwd that is stored inside the database which we can get from user object, so if this 2 passwords are not same then we return 401 code with Incorrect password message 

    if(!bcrypt.compareSync(req.body.password, user.password)){
       return res.status(401).send({
            success: false,
            message: 'Incorrect Password'
       })
    }
    Next if we find the user inside database and user password is actually valid, then it means the authentication is successful so we need to send back the token to user. Inorder to create a token we need a library called JsonWebToken using (refer the documentation)

jwt.sign(payload, secretOrPrivateKey, [options, callback])

>npm install jsonwebtoken

const jwt=require('jsonwebtoken');

The information we are passing inside payload object will be encrypted and stored inside this token, so we are passing details of the user, so we create payload object from user object with username and id. 
    const payload = {
          username: user.username,
          id: user._id
    }

secretOrPrivateKey can be any random value and for options object we pass expiresIn property with 1D which means jwt token will expires after 1 day

const token = jwt.sign(payload,"Random string",{expiresIn:"1d"});

So once the user logged in, we need to give the token back to the user 

return res.status(200).send({
     success: true,
     message: "Logged in successfully",
     token: "Bearer " + token
})

7. Start the appl

8. In postman tool, in POST request, http://localhost:5000/login. in Body - Raw - Json

{
  "username":"John",
  "password":"abcd"
}

We get success response with jwt token, in case if we wrong username, pwd we get message "Could not found user", if we wrong pwd we get "Incorrect password" message 

So in our login functionality we use jwt.sign() which sign and create tokens, now we use passport to verify those tokens

9. Goto Passport documentation - strategies - Select passport-jwt - In the down we can block of code we can copy and paste in passport.js 

- Import passport and UserModel in passport.js
    const passport=require('passport');
    const UserModel=require('./database');

   -  First we need JwtStrategy so we import it first, we also need ExtractJwt method because jwt we have cannot be passed directly, we need to extract only the token by using ExtractJwt.
      const JwtStrategy = require('passport-jwt').Strategy,
      ExtractJwt = require('passport-jwt').ExtractJwt; 

   - Next we have options object called opts where we have jwtFromRequest which uses ExtractJwt which we imported, this ExtractJwt has a method called fromAuthHeaderAsBearerToken() which extract the token from the token string excluding Bearer and also validate the token whether it is valid Json webtoken. 
   Next we have secretOrKey which should be same as secret provided in sign() (ie) "Random string". We dont need issuer and audience options so we can remove it 
    const opts = {};
opts.jwtFromRequest = ExtractJwt.fromAuthHeaderAsBearerToken();
opts.secretOrKey = 'Random string';

  - Next we again try to find the user using findOne(), so we find UserModel with an id which is already present in jwt_payload and if user is present we return the user

const JwtStrategy = require('passport-jwt').Strategy,
    ExtractJwt = require('passport-jwt').ExtractJwt;
const opts = {}
const passport=require('passport');
const UserModel=require('./database');

opts.jwtFromRequest = ExtractJwt.fromAuthHeaderAsBearerToken();
opts.secretOrKey = 'Random string';

passport.use(new JwtStrategy(opts, async function(jwt_payload, done) {
   let user = await UserModel.findOne({_id: jwt_payload.id});
        if (user) {
            return done(null, user);
        } else {
            return done(null, false);
        }
}));


10. Next we create /protected route and add passport.authenticate() where we pass strategy first which is jwt and also we want to pass session property but since we are not using session we define false, since we get user object once we authenticated so we return user object 

app.get('/protected', passport.authenticate('jwt', {session:false}),(req,res)=>{
     return res.status(200).send({
         success: true,
         user: {
            id: req.user._id,
            username: req.user.username
         }
     })
})

Since we are using passport, we need to import the passport 
   const passport=require('passport');
and use passport middleware 
   app.use(passport.initialize());
and also import all logic from passport.js file
   require('./config/passport')

11. Start the appl

12. In postman tool, in POST request, http://localhost:5000/login. in Body - Raw - Json

{
  "username":"John",
  "password":"abcd"
}

We get success response with jwt token

In GET request, we give http://localhost:5000/protected, if we try to directly access we get unauthorized because passport jwt strategy automatically checks if there is any valid token 

Now in Headers - key as Authorization and value as "Bearer token", then if we click send it will give success message along with user object 

app.js

const express=require('express');
const app=express();
const cors=require('cors');
const UserModel = require('./config/database');
const bcrypt=require('bcryptjs'); 
const jwt=require('jsonwebtoken');
const passport=require('passport');

app.use(express.json());
app.use(express.urlencoded({ extended: true }));
app.use(cors());
app.use(passport.initialize());

require('./config/passport')

app.post('/register',(req,res)=>{
    const user=new UserModel({
        username: req.body.username,
        password: bcrypt.hashSync(req.body.password,10)
    })
    user.save().then(user=>{
        res.send({
            success: true,
            message: 'User Inserted Successfully',
            user: {
                id: user._id,
                username: user.username
            }
        });
    }).catch(err => {
        res.send({
            success: false,
            message: 'Something went wrong',
            error: err
        })
    })
})

app.post('/login',(req,res)=>{
   // console.log('Login post request');
   UserModel.findOne({username:req.body.username}).then(user => {
    //No user found
    if(!user){
        return res.status(401).send({
           success: false,
           message: 'Could not find the user'
        })
    }
    //Incorrect password
    if(!bcrypt.compareSync(req.body.password, user.password)){
        return res.status(401).send({
             success: false,
             message: 'Incorrect Password'
        })
    }

    const payload = {
        username: user.username,
        id: user._id
    }
    const token = jwt.sign(payload,"Random string",{expiresIn:"1d"});

    return res.status(200).send({
        success: true,
        message: "Logged in successfully",
        token: "Bearer " + token
    })
   })
})

app.get('/protected', passport.authenticate('jwt', {session:false}),(req,res)=>{
    return res.status(200).send({
        success: true,
        user: {
           id: req.user._id,
           username: req.user.username
        }
    })
})

app.listen(5000,(req,res)=>{
    console.log('Server is listening at port 5000');
})

database.js

const mongoose = require('mongoose');

mongoose.connect('mongodb://localhost:27017/passport-jwt');

const userSchema = mongoose.Schema({
    username: String,
    password: String
})

const UserModel = mongoose.model('User', userSchema);

module.exports = UserModel;

passport.js

const JwtStrategy = require('passport-jwt').Strategy,
    ExtractJwt = require('passport-jwt').ExtractJwt;
const opts = {}
const passport=require('passport');
const UserModel=require('./database');

opts.jwtFromRequest = ExtractJwt.fromAuthHeaderAsBearerToken();
opts.secretOrKey = 'Random string';

passport.use(new JwtStrategy(opts, async function(jwt_payload, done) {
    let user = await UserModel.findOne({_id: jwt_payload.id});
         if (user) {
             return done(null, user);
         } else {
             return done(null, false);
         }
 }));


Secure ways to write NodeJs
      We discuss about some security which should be implement in appl. If we dont have any kind of security with ur project it is not good because anyone can steal ur data from ur database, anyone can exploit ur project, anyone can create traffic on ur server if we dont have security in our project

Best practice to secure nodejs appl
1. DOS attack
2. XSS attack
3. Brute force attack
4. SQL/NoSQL Injection attacks 

1. DOS attack
      It is Denial Of Service attack, where the attackers will simply send millions of request to ur server, they will use some commands, write some scripts and they will try to create some traffic on ur server. When ur server gets unlimited request, the traffic will increase, the real user may not access the server. The authenticated user of ur appl may or may not get access for ur server 
     So attackers are basically doing this type of attack by sending numbers of request to ur server. To prevent this type of attack, 
1. We can limit our request as per each route 
      Consider we have a route
app.get('/getRecord',(req,res)=>{
    res.send('hello');
})
So this is the request that is coming from client end to the server, so for this case we add some limitation means within some time interval the user can send maximum number of requests. For that we use

const bodyParser=require('body-parser');
app.use(bodyParser.json({limit:'25mb'});

We also use express to define limit as
app.use(express.json({limit:'10kb'}));
    So the request which are coming we can limit those request, so that for any time interval it will accept only limited number of requests 

We also have another inbuilt middleware called express-rate-limit
  - >npm install express-rate-limit 
  - Import it
const expressRate=require('express-rate-limit');
const apiLimiter=rateLimit({
     windowMs: 15*60*1000,  //15 min
     max: 100
})
app.use('/get',apiLimiter);

So here within 15min, maximum 100 request accepted for 1 single user 

In this way if we add this kind of module to our nodejs appl we can provide some kind of security to our app, which can prevent DOS attack so the attacker will not get chance to slow ur server 

2. XSS Attack
      It is Cross Site Scripting attack, the attacker injects malicious executable scripts into the code of a trusted application or website which may corrupt ur code or cause error directly at database. So attackers will just inject the malicious scripts or corrupt scripts from ur browser when u r making any request from the client to server
    To prevent this, nodejs has inbuilt middleware module called xss-clean or Helmet module
1. Install xss-clean
     > npm i xss-clean
2. Import in
const xss=require('xss-clean');
app.use(xss());
   So it will santize the body part of request  

1. Install Helmet
      >npm i helmet 
2. Import and use it
const helmet=require('helmet');
app.use(helmet());
   So when request comes from client side, it will give special header and it will help to block the extra code 

We have to implement one more security feature when we are integrating JWT token with nodejs appl, otherwise it may also create XSS attack (ie) we have to add our jwt token after generation to our cookies like
   res.cookies('jwt',token,{httpOnly:true});

3. Brute Force attacks
        Consider we have password for every appl, when we try to access any appl first we have to login with username and password. The brute force attackers will guess thousands of passwords and they will try or will implement some alogrithm to generate some random password and they will try one after another. So in this case they may get success to enter into the appl. To prevent it 

1. In server side we have to encrypt ur password, so when saving pwd into database it should be encrypt it and save it using Bcrypt package. So it would be difficult for the attackers to guess the password
2. We have to put proper validation before validating with database, we have inbuilt validator called Joi to do the validation 
3. Next we have to use 2-step verification like Google is doing. For example if we take any banking appl after giving credentials also they will ask to enter ur mobile number after that they will send OTP to mobile number and once it is validated then only we can get into the appl 

4. SQL/NoSQL Injection Attack
       If u r using SQL database we have to use parameterized queries. Consider we have query
  update user set name='"+req.body.name+"' where id=2;
This is not save query, we use parameterized query to prevent the SQL Injection. Here attacker will set req.body.name like 
   req.body.name='raj,City='USA';';
Now the query will changed as 
     update user set name='Raj',City='USA';
where the name and city will be updated as Raj for all rows, so this is one kind of sql injection. So to avoid we can just use parameterized query for it so it will get some protection
    
In NOSQL injection, most of them are integrating nodejs with mongodb, so for NoSQL database
   1. First we have to do input validation on server side
   2. Mongoose has some inbuilt validator method, so input will automatically validate as per requirement
   3. There is inbuilt module present in nodejs called express-mongo-sanitize npm
    

      
     
