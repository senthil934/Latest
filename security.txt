Authorization & Authentication
    - The person who accessing the website is right user and access right details. If customer, they have some access detail, if admin means they have some access details.
   - For eg, in Banking sites as a customer role we have only certain privileges like we can access the history, do some transaction, adding beneficiary etc. But he cant see others loan details, insurance details, changing of background color etc. So based on security only we can do this job
   - Spring Security basically do 2 important jobs Authentication and Authorization
   - Authentication basically collect the username and password of the user and if the credentials matches and fetch the role and based on the role we can decide what access privilege that particular user have in the application.
    - Authorization means which page the user is going to access based on the role
    - To get the authentication details, 3 ways
           1. In-memory authentication - while writing the prg itself we statically specify the username, password and role
           2. Database authentication - we are going to fetch all credentials from database
           3. LDAP
    - In realtime, whenever the request comes it should go to login page, there they enter username and password with help of that we fetch the roles and after that they decide whether we have to go to specific page.
   - In Spring Security apart from checking the username and password we also have JWT(JSON Web Token) and OAUTH(Open Authentication).
   - For ex, If we go to Quora, immediately they wont show the details, instead they ask us to login as google account or login as facebook account or create a account in quora site and then login. So we can use any account to check ur credentials and then we can login. This is called OAUTH
    - Whenever a user logs in, it generate one token which is combination of username,password, role etc it creates one token. So whenever the user enter into the page will get that token. The token has some time period for eg 10hrs we can use this token, after 10 hrs we can refresh the token and extend to another 10hrs or if time exceeds than 10hrs it shows u cannot access because token validation is over.
   So whenever we login, instead of giving username and password, they will give some token and for that token they set some time period. Once the time period is completed it says access denied. This is called JWT which contains token as key  value pair
   - So based on the requirements of the appl we can use any one of the security.
   - Spring Security concept can be used in both Spring MVC and Spring Boot also. But the difference is in Spring MVC we have to add lot of plugins and write more code. But in SpringBoot we havto add just 1 plugin with less code. If we are using Spring Boot 2 version and if u r having password in ur appl, then Spring Boot ask what type of encoding/encryption technique 
   - By default, Spring Boot give BCrypt password encoder or without password encoder
   - Bcrypt password encoder will generate different password for same string in different situation of length 60 so hacker cant able to hack it easily but in SHA, MD5 each time the length will differ
   - bcrypt is a password hashing function designed by Niels Provos and David Mazi√®res, based on the Blowfish cipher. Bcrypt uses adaptive hash algorithm to store password.BCrypt internally generates a random salt while encoding passwords and hence it is obvious to get different encoded results for the same string.But one common thing is that everytime it generates a String of length 60.


1. If we extends WebSecurityConfigurerAdapter which contains 2 methods
configure(authorization) and configureGlobal(authentication)
configure(authorization) and configure(authentication)

AuthenticationManagerBuilder is responsible for authentication details

2. UserDetailsService interface 
        - If u want to validate username and password (ie) it take details from database and check whether credential is correct or not for that we use UserDetailsService and returntype is UserDetails which contains username, password and only roles in the form of list
        - To validate this we call auth.userDetailsService() and take an argument where we passed the object of another separate class that implements an interface UserDetailsService. This interface is used to fetch username and password from database
        - Whenever we implement UserDetailsService, by default we override a method called loadUserByUsername() which has one abstract method so it is functional interface
        - This method takes username we passed and if username is present it shows the relevant details and if user is not found throws UsernameNotFoundException

3. GrantedAuthority interface - Represents an authority granted to an Authentication object.
   SimpleGrantedAuthority class - Basic concrete implementation of a GrantedAuthority.

4. Now whatever the username, password and role are stored inside inbuild class called User - Models core user information retrieved by a UserDetailsService.
public class User
extends java.lang.Object
implements UserDetails, CredentialsContainer


5. Since we are using Spring security concept, it wont allow to access the request directly instead it will show the login page where it will ask for username and password present in database. Using UserDetailsService it will check whether username and password is valid or not. If it is valid it will allow to access the respective page, if it is invalid it will stay in same page


Steps
1. Create tables
2. Declare Dependency like spring-boot-starter-security
3. Create User and Role class
4. Code UserRepository


What is JSON Web Token?
   - It is open standard, used to securely transfer information between two bodies (ie) any two users or any two servers 
   - It is digitally signed which means the information is verified and trusted there is no alternation of data in between the transfer
   - It is compact that u can send it via url as get request or post request or HTTP header so it is fast, that fast transmission makes JWT more usable 
   - It is self contained it means, that JWT token itself contain information about the user and this avoids querying the database more than once 
     Suppose u have logged in or ur user just logged in one time, u verify the information like username, password so u just provide the token. So every other time the user going to request something from ur website, u dont have to login, u just have to pass that token and then JWT system will just verify that token, and if it is correct it gives the response to that request

Why JWT is useful?
    - Authentication
        JWT is useful in case of authentication 
    - Information exchange
        used for exchanging information between any two bodies

What is JWT structure?
    Consider aaaaaaaa.bbbbbbbbb.ccccccccc, here a part is called header, b part is called payload and c part is signature 
    1. Header 
{
   "alg":"HS256",
   "typ":"JWT"
}
       It is a json object, it includes 2 fields and first is alg which is algorithm like HMac,sha-256,RSA. This alg will tell JWT that in which algorithm it is encoded
    typ means the type of web token which is JWT
    This header JSON is base64Url encoded to form first part 

   - Payload is also JSON object which contain claims which are user details or additional metadata like expiry date of token, whether it is admin or not. Payload itself is base64 encoded url to form second part.
   - Signature
       We told JWT that in the header we are using this kind of token and encode with this type of algorithm, but how we will ensure that this data will not change while transferring to one body to other body so we use signature
       Signature uses base64 header then concatenate with base64 version of payload and all these things use HMac sha-256 encoded. This algorithm contains header base64, payload with a secret 

So after combining all these three we get JWT with dot

eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c

The first is base64 version of header, second one is base64 version of payload and thrid one is base64 of header.base64 of payload.secret all these things use HMacsha-256 encoded to form the signature 

How JWT works?
   From the browser u send a post request to the server with credential like username and password, then server verify it and afterthat it generates with secret and then that passed back to the browser, then we send JWT on header on the post request on url to access some protected resources on our website 
   On the server first we check about JWT, if JWT signature matches with the signature we have defined then it issue the information that everything is good and respond to client 

JSON WEB TOKEN
   - Best secure way to communicate between client and server
   - It completely follows stateless authorization mechanism (ie) all user state dosent store in server memory or cookies
   - When client want to access any rest API from server side appl, we need to provide hardcode username and password. When client want to access any API from server side appl always we need to pass hardcode username and password which is not good
   - We dont want to give username and password for each and every request, to overcome this issues we use JWT
   - As we enabled spring security in server side application, when first time client sends the request we need to pass hardcode username and password as part of request. Now request comes to server side appl, now the server returns one encrypted string called JSON token which consist username and password in encrypted format. Now client want to access another api, there is no need to pass username and password for each and every request. Instead of passing username and password for each and every request, you can use jwt token.
    - JWT contains 3 parts separated by ".", 
          - header which specify the type of algorithm we use HS256 and type of token we use like JWT 
          - payload - need to set the userdetails which is called as claims
          - signature - header and payload convert as base64 url encoder and give the signature 

Steps
1. Create spring boot project with spring web, spring security, spring data jpa and mysql dependency
2. Create entity and repository to store user details
3. We initailize some default username and password in main class, so after main class invokes it stores all username and password in database using @PostConstruct
4. configure all db information in application.properties
5. Configure security information in WebSecurityConfig
6. Create CustomUserDetailsService which implements UserDetailsService
7. Run the appl, with http://localhost:8080 which starts default login page and u can use any  username and password to validate it

8. But we want to implement JWT (ie) if user sends the request with username and password, we want to generate web token, so that user can directly pass that web token as part of request header for authorization (ie) user no need to pass username and password for each and every request
9. For that we need to add one JWT library and create utility class in which we write logic to create and validate token
<dependency>
   <groupId>io.jsonwebtoken</groupId>
   <artifactId>jjwt</artifactId>
   <version>0.9.1</version>
</dependency>

10. Create JwtUtil class, which contain generateToken() which generate token by taking username as argument. When user send request first time with username and password as part of request header and we fetch the username and based on that username we create a token by calling createToken()

11. Inside createToken(), we use JWT library and set claim which is empty Map and subject is username and set the date when we issued the date and also set expiry limit for that token for next 10hr and also with algorithm used HS256.

12. Inside validateToken(), we provide token and userDetails which is username and password, then extractUsername() which extract username from token. Basically token will generated in the form of encrypted string, we can extract username and password from that string, then we validating username and verifying whether the token in expired or not

13. isTokenExpired(), used to check whether token is created before 10hr it return true otherwise false

14. Create "/authenticate" endpoint which take username and password and generate web token. We take AuthenticationManager to authenticate username, password from AuthRequest, and if it is succeed it will generate JWT token in encrypted format

15. As we implement Spring Security, we need to inform Spring framework, if request is coming with /authenticate then dont apply security for this specific method, because we want to generate jwt token. Since we implement Spring security, it will enable for all endpoint so we want to disable for "/authenticate" url
   For that in SecurityConfig, we override configure() and disable csrf() and we specify if we get request "/authenticate" to permit and if anyother request comes means to authenticate

16. Run the application, go to postman in POST request we access http://localhost:8080/authenticate 
   In Body - Raw - Type (application/json)
{
   "userName":"hello",
   "password":"abcd"
}
click Send
  Now it will generate one encrypted string
 - Copy the string and paste in jwt.io site and check 3 parts of the token 

17. Now we access other endpoint "/" using token. 
Goto Postman in GET request we access http://localhost:8080/
In header - contenttype: application/json
            Authorization: Bearer "paste the token"
Click Send
  - Now the endpoint will not work, because Spring boot didnt understand the type of authorization


18. We need to tell to SpringBoot extract the string, get username and password then authenticate user, if user authentication is succeed then allow user to access endpoint.
    So before request goes to controller endpoint we want to validate the token, for that we write one filter called JwtFilter which extends OncePerRequestFilter which executes for every request once, here we write logic to validate and authenticate the user.
    In this filter, we need to extract authorization header from ServletRequest

19. Run the appl
Post Request - http://localhost:8080/authenticate - generate the token by providing username, password in body
Get Request - http://localhost:8080/ 
In header - contenttype: application/json
            Authorization: Bearer "paste the token"
Click Send
   - We can see the response



     

Spring Oauth2
    - Let say we are building ur website where u want to provide security, where ur user want to login ofcourse we can have own database or own way of verifying the user. 
   - But we have one issue, if u have user details in ur database or ur server, u have to protect it. Ofcourse it becomes difficult to manage the database ip, if someone hacks its u r responsible.
   - Second issue even if we have database or own server most of the user using some type of social networking login, for example ur consumer has google account or facebook account. So can we have google login in ur website, so we dont want to manage the data, it will manage by Google.
   - For that we have a feature called OAuth2
OAuth 2 is an authorization framework that enables applications to obtain limited access to user accounts on an HTTP service, such as Facebook, GitHub, and DigitalOcean. It works by delegating user authentication to the service that hosts the user account, and authorizing third-party applications to access the user account. OAuth 2 provides authorization flows for web and desktop applications, and mobile devices.

What is OAuth2?
    - OAuth is open standard for access delegation, so it is not for authentication only, it is for access delegation so basically u delegate ur authority to somebody else. It is not authentication protocol it is authorization standard
    - OAuth also provides secured delegate access to server resource on behalf of resource owner 
    Suppose we have google account, however u r accessing bank statement and bank statement asks to provide google account and get redirected to google page, from there google asks whether u want to authorize ur bank to redirect or give information about u to bank 
   So literally bank does not have ur username and password from google so instead it will just delegate the URL or the request to google and google will authenticate u and then Google will ask u what all the accesses do u need to give to the bank. So basically the authorization information is received from google to the bank and the bank uses that for further any communication
    - OAuth2 is more of a framework then a defined protocol 

   Consider we log into ur city bank account for some reason and citybank is asking to authenticate ur facebook account. So imagine city bank server as authentication client and Facebook server as authentication server.
 



Steps: SpringBootOauth2-Github

1. Configure pom.xml
2. Configure the controller and mapping 
3. Now we will access the appl using github account for that we need to create client id and client secret, so from appl based on that client id we can communicate through Github server
    - Goto Github.com - login - Settings- Developer Settings - Oauth Apps - Register new application
    Application name: SpringBootOauth2-Github (project name)
    Homepage url : http://localhost:8080/
    Authorization callback url: http://localhost:8080/
    - Click Register Application
Now it will create client Id and client secret and paste in application.yml
    - Upload new logo
    - Click Update Application

4. Run the application and access http://localhost:8080/
    - Now from the appl it will access the request from Github for authentication purpose


Steps: SpringBootOauth2-Google project 
Now we will use google login to access the website and access the token. Once u login through google, it will send one token for the website based on that token ur website will access.

1. Goto https://console.developers.google.com/ login with google credentials
2. Click MyFirstProject - Click New Project
   Project Name: SpringBootOauth2-Google
   Create 
3. Now we need to enable Google API
   Click Enable API and Services - Search for Google+ API
   Click Enable 
4. Click on API & Services - Click Credentials - Click Create Credentials - Select Oauth Client ID
   Click Configure Consent Screen - Click External - Click Create
         App Name: SpringBootOauth2-Google
         User support email: senthil1418@gmail.com
         Developer Email: senthil1418@gmail.com
      - Click Save And Continue - 3 times
 - Goto Credentials - Create Credentials - Select Create Oauth client Id
      - Select Application Type: Web Application
           Name: SpringBootOauth2-Google
      - Under Authorized redirect URIs - Click Add URI
           URIs: http://localhost:8080/login
      - Click Create
Once we click create, it will create client ID and client secret key 

5. Create spring boot project with Spring web, Spring Security, Oauth2 client
6. Create HomeController
7. Create SecurityConfig, in that we say any user can access "/" but if "/prevent" request comes it has to be authenticated using Google.
8. In application.properties we configure the client id and client secret to access the appl using google account
9. Now start the application
http://localhost:8080 - print any user can access this
http://localhost:8080/prevent - it will automatically goes to google account
   - But now it should shows authorization error, so copy url http://localhost:8080/login/oauth2/code/google 
   - Goto Credentials - Go to the project - paste url in Authorized Redirect URI - click Save
10. Now run once again http://localhost:8080/prevent
   - Now provide gmail username and password, which displays the entire user info
 


JWT Authentication Token
     - Consider we have SpringBoot server where we will write some endpoints and we have postman to test the api's on the server. 
     - Consider we have /welcome api and we want to keep it secure, which means no one can access directly, if the user logins and have token then only he can access the rest api's.
     - So in order to access the endpoints first the client has to generate token along with username and password. Now the server will authenicate the username and password and if it is correct the server sends the response otherwise sends error
     - So whenever client want to access any api along with any request url we have to pass token as authorization header. Now SpringBoot will validate the token then give permission to access the api's
     - Format of the header would be key value pair where key is Authorization : and value is Bearer "tokenname" 

Steps : Refer SpringBootJWT

1. Create SpringBoot project with Spring web, Spring Security, Jsonweb token and javax.xml.bind dependency

2. Create HomeController to create "/welcome" api. Now we dont want to access this api publicially which means if the user logins and get the token then we need to authenticate this api

@RestController
public class HomeController {	
	@RequestMapping("/welcome")
	public String welcome() {
		String text="This is a private page. ";
		text += "This page is not allowed to unauthenticate users";
		return text;
	}	
}
 
If we want to check whether "/welcome" is working and since we implement Spring security by default it opens login page by giving "http://localhost:8080/welcome"  and u provide 
    username: user
    password: copy the generated password in server console 
and check whether it works. Similarly if we want to logout we can provide http://localhost:8080/logout.
   Here we didnt use anything about JWT, it is form based spring security 

3. We need to configure the security features, so we create MySecurityConfig which extends WebSecurityConfigurerAdapter and override the configure() for HttpSecurity and AuthenticationBuilder, so that we can change default configuration of Spring security features.
   Now we use UserDetailsService authentication (ie) we provide user details so we create CustomUserDetailsService which calls loadByUserName() and authenticate the user information and autowired the class.
  We also configure the password encoder. 

@Configuration
@EnableWebSecurity
public class MySecurityConfig extends WebSecurityConfigurerAdapter{
	
	@Autowired
	private CustomUserDetailsService customUserDetailsService;

        @Bean
	public PasswordEncoder passwordEncoder() {
		return NoOpPasswordEncoder.getInstance();
	}

        @Bean
	public AuthenticationManager authenticationManagerBean() throws Exception {
		return super.authenticationManagerBean();
	}


	@Override
	protected void configure(AuthenticationManagerBuilder auth) throws Exception {
		auth.userDetailsService(customUserDetailsService);
	}

	@Override
	protected void configure(HttpSecurity http) throws Exception {
		
	}

}


4. Create CustomUserDetailsService class which implements UserDetailsService and override loadUserByUsername() which returns UserDetails (ie) it will return user information.
   So whenever we call auth.userDetailsService(customUserDetailsService), it will call internally loadUserByUsername() to get user details.
   Inside loadUserByUsername(), we are going to check fake username and password are equal and returns User class (we dont have User class so we are using Spring User class which has username, password and Role authority). If username dosent match then it throws UsernameNotFoundException
  
public class CustomUserDetailsService implements UserDetailsService {

	@Override
	public UserDetails loadUserByUsername(String userName) throws UsernameNotFoundException {
		if(userName.equals("senthil")) {
			return new User("senthil","abcd123",new ArrayList<>());
		}
		else {
			throw new UsernameNotFoundException("User name is not found!!!");
		}
	}

}

5. Now we configure the authorization in configure(HttpSecurity http) method first we disable csrf and cors, then we authorize "/token" request to generate the token for all users. Then for any request we need to authenticate and finally creating the session
        @Override
	protected void configure(HttpSecurity http) throws Exception {
		http
		    .csrf().disable()
		    .cors().disable()
		    .authorizeRequests()
		    .antMatchers("/token").permitAll()
		    .anyRequest().authenticated()
		    .and()
		    .sessionManagement().sessionCreationPolicy                      (SessionCreationPolicy.STATELESS);
	 }

6. Now whenever we give request for first time, it has to generate the token for that we need to add jwt token and javax.xml.bind dependency.
   In order to generate the token we need to create JwtUtil class which contains methods for generating token, validating token, check whether token is expired.
   We can take code from the internet, in google we can give jwt util class code and get from github
https://github.com/koushikkothagal/spring-security-jwt/blob/master/src/main/java/io/javabrains/springsecurityjwt/util/JwtUtil.java

Which contains generateToken() which internally call createToken() to create token and validateToken() to validate the token
  We can declare this class as @Component so that we can autowire JwtUtil class and use its methods

7. Create JwtController class to generate the token, for that we create "/token" endpoint with POST request. Here generateToken() accept the user information for that we create JwtRequest model class which contains username and password

8. Create JwtRequest class

9. Now we get entire JwtRequest class into generateToken(), so we pass JwtRequest inside the method.
   We need to autowire other services also like AuthenticationManager, JwtUtil and CustomUserDetailsService

10. Now inside generateToken() we got username and password, now we want to authenticate for that we use authenticationManager authenticate(),inside that we need to pass username and password for that we use UsernamePasswordAuthenticationToken along with username and password from JwtRequest

@RequestMapping(value="/token",method=RequestMethod.POST)
	public ResponseEntity<?> generateToken(@RequestBody JwtRequest jwtRequest) throws Exception{
		System.out.println(jwtRequest);
		try {
			this.authenticationManager.authenticate(new UsernamePasswordAuthenticationToken(jwtRequest.getUsername(), jwtRequest.getPassword()));
		}
		catch(UsernameNotFoundException e) {
			e.printStackTrace();
			throw new Exception("Bad Credentials!!!");
		}
	}

11. In case if username and password is correct, we need to generate token for that we need UserDetails, so we get those details from CustomUserDetailsService class

UserDetails userDetails = this.customUserDetailsService.loadUserByUsername(jwtRequest.getUsername());

12. Now from the userDetails we need to generate token for that we need to call JwtUtil generateToken()
 
String token = this.jwtUtil.generateToken(userDetails);
System.out.println("JWT "+token);

13. Now we want to send the token out, for that we need to convert token as JSON object. So we need to create JwtResponse class with String token property. Now return that response with token in generateToken()

return ResponseEntity.ok(new JwtResponse(token));

14. Start the application and in Postman we generate the token using http://localhost:8080/token with POST request and in Body - Raw - JSON and give
{
   "username" : "senthil",
   "password" : "abcd123"
}
Click Send 
Now it will generate the token for that username and password

In case if we pass wrong username and password, then it will thow an exception as Bad Credential

15. Now the client is sending the request to "/welcome" along with generated token and now on the server side we have to check whether the token in correct or not, for that we have to create a filter 

16. Create JwtAuthenticationFilter class which extends OncePerRequestFilter and override doFilterInternal()
   Inside this method we need to get Jwt header and check whether it starts with "Bearer" and then validate the token.

17. Now we want to configure JwtAuthenticationFilter inside MySecurityConfig using 
http.addFilterBefore(jwtFilter, UsernamePasswordAuthenticationFilter.class);

which means before the request goes, the filter will check for the token and then validate it 

18.  Start the application and in Postman we generate the token using http://localhost:8080/token with POST request and in Body - Raw - JSON and give
{
   "username" : "senthil",
   "password" : "abcd123"
}
Click Send 
Now it will generate the token for that username and password

After that we issue http://localhost:8080/welcome with GET request and in Headers
key: Authorization
value: Bearer "token"

Click Send

Now it will display the output from "/welcome" endpoint securely

19. In case if we want to secure any other endpoints we have to generate token then only we can access the endpoint
Now if we want to access the "/getUsers", first we have to generate the token and the we can access the endpoint

20. Previously we have two endpoints "/welcome" and "/getUsers". If the user login and generate the token then only he can access those endpoints.
    But consider we dont have token and if we try to access the endpoints then it will shows 403-Forbidden error. But we need to get unauthorized information that they dont have token 
    We need to create a JwtAuthenticationEntryPoint class which implements AuthenticationEntryPoint interface and override commence() which reject all unauthenticated request and send error code 401.
 
   Next we configure inside MySecurityConfig configure(HttpSecurity) using

.and().exceptionHandling().authenticationEntryPoint(entryPoint);

21. Start the application, now if we access http://localhost:8080/welcome in GET request without token, it will show 401-Unauthorized request


SSL Concepts
   - Secured Socket Layer is the standard security technology for establishing encrypted link between a webserver and a browser.
   - For example, whenever we are going for any banking transaction we are using our browser to make connection to the banking server, so we enter our userid, password  and card details which are very sensitive details. If those data in the network is somebody hacks it and they misuse it. 
   - For this one SSL is very handy, it dosent allow the data that we are putting in the browser and it dosent allow that to be clear while passing through network fron the browser to the web server, it may be encrypted. So it establish an encrypted link between a web server and a browser. This link ensures that all data passed between the web server and browsers remain private and integral.
   - SSL is an industry standard and is used by millions of websites in the protection of their online transactions with their customers.We have a banking website, we need to ensure that our customers data to be secured.

2 ways of SSL
1. 1 way SSL
     - Whenever from the client request is given to the server, so how does the encrypted link is created.
   In 1 way SSL, immediately the server will send a public certificate and if this public certificate is available in the client truststore that means it is trusted server from where we are getting the response. Once client certificate is trusted then only we can see the response from the server.
   So whenever we send the data to the server, so that will be encrypted by this certificate and then data will flow from client to server.
   The data that client entering in browser that should not passed in clear throughout the network. So encrypted link has to established and first phase the certificate will verified whether that is available in client. Once it is trusted then the data will be encrypted with this certificate and then sent to the server.
  - Every browser or OS has a package of bundeled certificates, root and common intermediate certificates of trusted certificate authorities.
    - In Google chrome - Security - Manage Certificates  - Select Intermediate Certification Authorities 
    We can see so many trusted certificates in our OS. So whenever we give google.com, it creates secure connection that means the google server have sent public certificate to our system or browser where we get request  which has certificate to access my system.

2. 2 way SSL
      - The server public certificate has to be in the client truststore and client certificate has to be in the server truststore. The server will send first then client after verifying will send its public certificate to the server back and vice versa.

Example:Refer SpringBoot-SSL project - 1 WAY SSL

1. Create SpringBoot-SSL project with Web dependency

2. Create an endpoint and check how it works without SSL 

@RestController
public class DemoController {
	
	@RequestMapping("/getData")
	public String demo() {
		return "Hello SSL";
	}

}

3. Now we start the application and invoke the endpoint "/getData"
http://localhost:8080/getData

4. In order to make SSL, we need to put some configuration in application.properties
server.ssl.key-alias=demo
server.ssl.key-password=changeit
server.ssl.key-store=classpath:ssl-server.jks
server.ssl.key-store-provider=SUN
server.ssl.key-store-type=JKS

We create keystore file called ssl-server.jks and its password is "abcd1234" which is jks file provided by Sun.
A JKS file is an encrypted security file used to store a set of cryptographic keys or certificates in the binary Java KeyStore (JKS) format. It requires a password to be opened.

5. We create selfsigned certificate using keystore explorer or keytool commands provided by JDK. We use keytool provided by JDK

we create alias as "demo" since we configured in application.properties file as
server.ssl.key-alias=demo and password for keystore will be always "changeit"

C:\Spring\SpringBoot-SSL>keytool -genkey -alias demo -keyalg RSA -keystore "ssl-server.jks"
Enter keystore password:
Re-enter new password:
What is your first and last name?
  [Unknown]:  senthil
What is the name of your organizational unit?
  [Unknown]:  hcl
What is the name of your organization?
  [Unknown]:  hcl
What is the name of your City or Locality?
  [Unknown]:  chennai
What is the name of your State or Province?
  [Unknown]:  Tamilnadu
What is the two-letter country code for this unit?
  [Unknown]:  IN
Is CN=senthil, OU=hcl, O=hcl, L=chennai, ST=Tamilnadu, C=IN correct?
  [no]:  yes

Enter key password for <demo>
        (RETURN if same as keystore password):
Re-enter new password:

Warning:
The JKS keystore uses a proprietary format. It is recommended to migrate to PKCS12 which is an industry standard format using "keytool -importkeystore -srckeystore ssl-server.jks -destkeystore ssl-server.jks -deststoretype pkcs12". 


6. Now start the application and hit endpoint "localhost:8080/getData" 

Now Tomcat runs on 8080 with https so we get "Bad Request.This combination of host and port requiers TSL" that means secure communication is happened. Now ur connection is not private (ie) the certificate we have used is not trusted so we need to give trust because this certificate is selfsigned we didnt purchase like cyclechain which is authorized by any certified authority

Now give https://localhost:8080/getData
    click Advanced - Proceed to localhost
Now the output will be coming as "Hello SSL"


Example: 2 way SSL 
      In case of 1 way SSL, in server and client one certificate is exchanged and the client truststore should be available, that request which is coming from server, the client should trust that certificate then only handshake will happen and the certify data will transfer from server to client.
    In case of 2way SSL, both client and server need to trust both certificate then only handshake will happen and then data will transfer from server to client.
    First client need to trust the server and also server has to validate the client certificate, once the server gives the certificate to client and again the client send back the required certificate to the server then only the trust will happen and then handshake will happen between server and client and then data will be transferred.

Traditionally, most of us are familiar with 1 way SSL. In this form, the server presents its certificate to the client and the client adds it to its list of trusted certificate. And so, the client can talk to the server.
2-way SSL is the same principle but both ways. i.e. both the client and the server has to establish trust between themselves using a trusted certificate. In this way of a digital handshake, the server needs to present a certificate to authenticate itself to client and client has to present its certificate to server. 

https://medium.com/@niral22/2-way-ssl-with-spring-boot-microservices-2c97c974e83

Refer nt-gateway and nt-ms projects for 2 way SSL

1. Create self signed client certificate
c:/project>keytool -genkeypair -alias nt-gateway -keyalg RSA -keysize 2048 -storetype JKS -keystore nt-gateway.jks -validity 3650 -ext SAN=dns:localhost,ip:127.0.0.1 

password:nt-gateway

2. Create self signed server certificate
c:/project>keytool -genkeypair -alias nt-ms -keyalg RSA -keysize 2048 -storetype JKS -keystore nt-ms.jks -validity 3650 -ext SAN=dns:localhost,ip:127.0.0.1

password: nt-service

3.Create public certificate file from client cert
c:/project>keytool -export -alias nt-gateway -file nt-gateway.crt -keystore nt-gateway.jks

password:nt-gateway

4. Create Public Certificate File From Server Cert
c:/project>keytool -export -alias nt-ms -file nt-ms.crt -keystore nt-ms.jks

password: nt-service

5. Import Client Cert to Server jks File
c:/project>keytool -import -alias nt-gateway -file nt-gateway.crt -keystore nt-ms.jks

6.Import Server Cert to Client jks File
c:/project>keytool -import -alias nt-ms -file nt-ms.crt -keystore nt-gateway.jks

7. Create nt-gateway and nt-ms project 

8. Configure Server For 2 Way SSL 
Copy final server jks file (in my case, nt-ms.jks) to the src/main/resources/ folder of nt-ms application and configure application.yml

spring:
  application:
    name: nt-ms
---
server:
  port: 9002
  ssl:
    enabled: true
    client-auth: need
    key-store: classpath:nt-ms.jks
    key-store-password: nt-service
    key-alias: nt-ms
    key-store-type: JKS
    key-store-provider: SUN
    trust-store: classpath:nt-ms.jks
    trust-store-password: nt-service
    trust-store-type: JKS

9. Configure Client for 2 way SSL
copy final client jks (in my case nt-gateway.jks) to src/main/resources/ folder
Next, add the entries in application.yml
spring:
  application:
    name: nt-gateway
---
server:
  port: 9001
  ssl:
    enabled: true
    client-auth: need
    key-store: classpath:nt-gateway.jks
    key-store-password: nt-gateway
    key-alias: nt-gateway
    key-store-type: JKS
    key-store-provider: SUN
    trust-store: classpath:nt-gateway.jks
    trust-store-password: nt-gateway
    trust-store-type: JKS

10. convert jks to nt-ms.pc12 file
keytool -importkeystore -srckeystore nt-ms.jks -destkeystore nt-ms.p12 -srcstoretype JKS -deststoretype PKCS12 -srcstorepass nt-service -deststorepass nt-service -srcalias nt-ms -destalias nt-ms -srckeypass nt-service -destkeypass nt-service -noprompt

https://www.agenciatributaria.es/AEAT.internet/en_gb/Inicio/Ayuda/_comp_Consultas_informaticas/Categorias/Firma_digital__certificado_o_DNIe__y_sistema_Cl_ve_PIN/Certificados_electronicos/Como_importar_una_copia_valida_de_su_certificado_electronico/Instrucciones_para_Windows/Importar_copia_del_certificado_en_Google_Chrome/Importar_copia_del_certificado_en_Google_Chrome.shtml

11. configure .pc12 file in chrome
       - Settings - Security - Manage Certificate
       - Click Import - Click Next
       - Click browse and select nt-ms.pc12 file - Click Next
       - Provide password "nt-service"
       - Click checkbox "Mark this key as exportable. This will allow to bakup or transport the key" - click Next
       - Check "Automatically select the certificate store based on type of certificate"
       - Click Next - Click Finish 
       - If the import has been completed correctly, the message "Import successful" will appear
       - If the certificate is valid it will come under "Personal tab" otherwise it will comes under "Other tab"

12. Start both appl
13. In browser give https://localhost:9001/nt-gw/ms-data
       



Spring Boot with SSL - Refer springboot-https project

1. Create project with web dependency
2. Create a rest end point /hello in HelloResource.java
@RestController
@RequestMapping("/hello")
public class HelloResource {

    @GetMapping
    public String hello() {
        return "Hello YouTube";
    }
}

3. Configure all properties in application.properties to make spring boot use SSL

server.port=8443
server.ssl.key-alias=https-example
server.ssl.key-store-type=JKS
server.ssl.key-password=password
server.ssl.key-store=classpath:https-example.jks

In order to provide secure hhtps connection we can use
  1. SSL(Secured Socket Layer) - If we use https connection over the internet, this is used to secure the data using https and u dont want others to peek into ur information when transfer info from one end to another 
   2. TLS(Transport Layer Security) - It is advanced version of SSL which adds more feature to SSL 

Truststore and Keystore
   - Truststore is when u want to store public certificate into the keystore. Eg: google.com which is public for everyone to view
   - Keystore is used to store private certificate of client or server. Eg: server name which is specific to internal servers

4. We create self signed certificate using keytool called https-example with password called "password"

C:\Spring>keytool -genkey -alias https-example -storetype JKS -keyalg RSA -keysize 2048 -validity 365 -keystore https-example.jks

5. https-example.jks to resources folder

6. Start ur application and run as 
http://localhost:8443/hello - shows bad request
https://localhost:8443/hello - shows the output



What is Oauth2? mainly based on authorization concept
     Consider we develop an application abc.com and ur application will be consumed by some people, so whatever appl we create, we develop an interface so that enduser can interact with it. For eg facebook which has frontend and we can interact with it.
    Like that we create abc.com and some person is interacting with our appl. Consider that person is registered in our appl, so he is accessing some resource (ie) backend which has rest api, services and data in appl.
   But these resources cannot be accessed directly so we have to provide some authentication. So in order to access resource server which contains the resources we have to authorize it for that we have to create an authorization server.
    So whenever the user gives request to the appplication, and from there if we provide credentials it will go to authorization server. This authorization server can be a third party server like github, facebook, gmail etc or we can implement our own server. 
    Based on the credentials provided, the authorization server provides a token back to the clien t. Now the appl use this token and send to resource server, and we validate the token in resource server and if it is validated we can access the details from resource server using that token.
    Authorization server will just share the token, it does not provide any credential information and that token will be validated using oauth2 and then give the response back to client.


Step 1: Creation of AuthorizationServer

- Oauth2 is protocol for token based authorization
- Oauth2 is an authorization framework
- Oauth Roles: Resource Owner(User), Client(App), Resource Server, Authorization server
- Oauth work as actor between client, user, authorization server and resource server

1. Create SpringBoot-AuthorizationServer with Spring security, cloud oauth2, spring web dependency
2. To transfer user details we use inmemory authentication and no password encoder in UserManageConfig class
@Configuration
public class UserManageConfig {

	public UserDetailsService userDetailsService() {
		InMemoryUserDetailsManager user=new InMemoryUserDetailsManager();
		user.createUser(User.withUsername("senthil").password("abcd1234").authorities("read").build());
	    return user;
	}
        
        public PasswordEncoder passwordEncoder() {
		return NoOpPasswordEncoder.getInstance();
	}
}

3. Whatever user is created is transferred to authorization server. Now we create authorization server and we connect the user to that auth server 
   - Create class  AuthorizationServerConfig that extends AuthorizationServerConfigurerAdapter with @EnableAuthorizationServer so it will act as authorization server and override 2 methods
   - First method public void configure(ClientDetailsServiceConfigurer clients) is used When user pass credentials to appl, the credential goes to auth server, but how auth server knows that token has to be released for that particular appl (ie)abc.com appl. The auth server has to know from which appl the request comes so the token has to sent to that particular appl. Here also we use in memory auth for client details with client name and secret.
     clients.inMemory().withClient("abc.com").secret("abc123")
		.scopes("read")
		.authorizedGrantTypes("password");

   - Consider we login with facebook, so in case we already logged in with facebook in that case it will directly access the resource server, it does not go to auth server. So user will directly access auth server or user will access auth server through abc.com appl, it depends on Grant Types like 
   authorization_code - here will provide credential from resource owner to auth server directly
   implicit(deprecated) 
   client_credentials
   refresh_token
   password (deprecated) - here will provide credential from resource owner to client appl
and based on that auth server will release the token

   - Second method public void configure(AuthorizationServerEndpointsConfigurer endpoints) used to couple the particular user with the related authorization server using AuthenticationManager.
 @Override
	public void configure(AuthorizationServerEndpointsConfigurer endpoints) throws Exception {
		endpoints.authenticationManager(authenticationManager);
	}

   - Inject AuthenticationManager in UserManageConfig
        @Override
	@Bean
	public AuthenticationManager authenticationManagerBean() throws Exception {
		return super.authenticationManagerBean();
	}


Now the user created called "senthil" with client "abc.com". Now credentials pass to abc.com and then to auth server and in auth server user and client details are there

4. Start the application and in the console we can see endpoint called pattern='/oauth/token' which automatically created by oauth
pattern='/oauth/check_token' used to connect auth server and resource server

5. Go to Postman with POST request provide 
http://localhost:8080/oauth/token?grant_type=password&username=senthil&password=abcd1234&scope=read 
and go to Authorization tab - select Basic Auth.
   In that provide client name and secret key for username and pasword.
   - click SEND button

Now user gives credentials and through abc.com it sends credentials to auth server and it will generate access_token.

So we create an authorization server and this server not only needs information of user as well as client informtion, so based on that client the auth server will issue u the token.

In case if we want to configure multiple clients then we can configure different clients in Authorization server like 

@Override
	public void configure(ClientDetailsServiceConfigurer clients) throws Exception {
		clients.inMemory()
		.withClient("abc.com").secret("abc123")
		.scopes("read")
		.authorizedGrantTypes("password")
		.and()
		.withClient("xyz.com").secret("abc12")
		.scopes("read")
		.authorizedGrantTypes("password");
	}


6. Previously resource owner or user interact with client appl and from their it interact with authorization server and auth server it releases the token.
    But resource owner can directly interact with auth server also. If resource owner interact through client it may less secure so resource owner directly interact with auth server and it depends on "grant types" like password. But "password" grant type is deprecated because it is less secured and multiple appl credentials is available in client application.
    So here instead of giving credentials in client appl we are going to give credentails (ie) authenticate in authorization server and client appl is just accessing the resource server using token based authorization. 
   Using grant type "authorization_code" we can credentials from resource owner to auth server but how authorization server will release token to particular client appl using redirectUris()
  .withClient("xyz.com").secret("abc12")
		.scopes("read")
		.authorizedGrantTypes("authorization_code")
		.redirectUris("http://localhost:8083");

7. Since we are giving credentials in auth server directly, so where we are going to provide username and password for that we create default form based authentication in UserManageConfig by override protected void configure(HttpSecurity http) 
        @Override
	protected void configure(HttpSecurity http) throws Exception {
		http.formLogin();
		http.authorizeRequests().anyRequest().authenticated();
	}

8. Start the appl and run in browser as
http://localhost:8080/oauth/authorize?response_type=code&client_id=xyz.com&scope=read
   - Now it will open login page where u provide credentails we provide in UserManageConfig called "senthil" and "abcd1234". Here response_type=code represent the grant type "authorization_code"
  - Now it will ask to approve or deny - select approve and click Authorize
  - Now it will redirect to localhost:8083 with some authroization code and with that we can interact with client

http://localhost:8080/oauth/token - used from owner to client appl
http://localhost:8080/oauth/authorize - used from owner to auth server

9. Now we can run in postman with that generated code in POST request with 
http://localhost:8080/oauth/token?grant_type=authorization_code&code="generatedcode"&scope=read

In authorization - select Basic Auth - provide 
     username: xyz.com
     Password: abc12
 - click Send
Now it will generate access token 


What is Grant Type: Password ?
    1. Consider resource owner accessing abc.com application, you are registered user in that appl and now we want to modify the username in that appl, so once u hit the resource url first we have to provide userid and password.
    2. Now which resource to be modified, deleted will be kept under resource server. But we cant access resource server directly we have provide some restrictions and user should be authorized. We have kept user details in authorization server, now client appl will send credentials to auth server but how auth server will send the generated token to the related client appl. Along with userid and password we also provide client secret details, so auth server will return with access token. Now we send the token to resource server and we authorize that particular user to access the resource 


What is authorization_code grant types?
     1. It is implicit grant types enhance version
     2. Now resource owner will communicate with auth server directly using "/oauth/authorize" endpoint and once u hit the endpoint it generates auth_code and sent to the client application
     3. From postman we are going to provide the end point with generated code (ie) from client appl to auth server which will provide access token back to client appl
http://localhost:8080/oauth/token?grant_type=authorization_code&code="generatedcode"&scope=read
     4. Now with the help of access_token we can access the resource server 

Client_Credential with refresh token:
   1. we have only client, auth server and resource server actors
   2. If the client request resource server to access any resources, it cant access directly, it requires some token to access the resources. Now the client interact with auth server to provide access_token so that it access some resources from resource server. 
   3. Now auth server is requesting for client credentials, previously in grant types password and authorization_code we provided user credentials. But here we have to provide client credentials to auth server and based on that it provides access token, with that access token we can access resources from resource server

Steps:
   1. We configure client credentials inside AuthorizationServerConfig as
                .withClient("pqr.com").secret("abcd")
		.scopes("read")
		.authorizedGrantTypes("client_credentials");

   2. Start the application
   3. Go to postman with POST request provide 
http://localhost:8080/oauth/token?grant_type=client_credentials&scope=info 
and in Authorization tab - Select Basic Auth - provide 
       username: pqr.com
       password: abcd
 -click Send
     Now it will generate the access token

   4. refresh token grant type can be used only along with combination of another grant types. In our case we are using along with password grant type as follows
                .withClient("abc.com").secret("abc123")
		.scopes("read")
		.authorizedGrantTypes("password","refresh_token")

   5. Start the application
   6. In Postman with POST request provide the endpoint
http://localhost:8080/oauth/token?grant_type=password&username=senthil&password=abcd1234&scope=read 
and go to Authorization tab - select Basic Auth.
   In that provide client name and secret key for username and pasword.
   - click SEND button
       - Now along with access_token, it also generate refresh_token also 

    Normally for any token there will be some expiry time, once time is expired that access_token cannot be reused. If u want to reuse then we want to regenerate the access_token by involving all the actors once again instead we use refresh_token.
    Once access_token is expired, so by using refresh_token we can regenerate the access_token, so once access_token is regenerated, the refresh_token also will be regenerated.
    



How resource server would validate the access token ?
    1. When client tries to access the resource server endpoints we send access_token to resource server from auth server by providing the credentials from client to auth server, now the access_token from auth server goes to resource server with the help of validated access_token we can access the resources from resource server
    2. How does resource server understands whatever access_token the client sends is valid access token?
      There are 3 ways, with that resource server can understand that auth server has send the access token to client and from client, it sends the access token to resource server

First way - using oauth/check_token
    Refer SpringBoot-ValidateToken project
    1. Create project with spring web, oauth client, spring security dependency
    2. Create UserManageConfig class, which contains user detail information
    3. Create AuthorizationServerConfig class. In UserManageConfig we have implemented BCryptEncoder, so in secret code also we have to implement BCryptencoder also. Instead we can implement a new security feature inside public void configure(AuthorizationServerSecurityConfigurer security) method
      By default Spring security uses opaque token.
@Override //client info no need to bcrypt 
	public void configure(AuthorizationServerSecurityConfigurer security) throws Exception {
		security.passwordEncoder(NoOpPasswordEncoder.getInstance());		
	}
    4. Start the application
    5. In Postman with POST request provide the endpoint
http://localhost:8080/oauth/token?grant_type=password&username=senthil&password=abcd1234&scope=read 
and go to Authorization tab - select Basic Auth.
   In that provide client name and secret key  as "abc.com" and "abc123"
   - click SEND button
       - Now along with access_token, it also generate refresh_token also with expiry time as 7999 sec because we set access validity token as 8000 sec

   6. Now we want to validate the access-token sent by the client to the resource server using "/oauth/check_token" endpoint. But by default "/oauth/check_token" is not accessible, so we want to make it accessible by configuring 
        @Override //client info no need to bcrypt 
	public void configure(AuthorizationServerSecurityConfigurer security) throws Exception {
		security.passwordEncoder(NoOpPasswordEncoder.getInstance())
		        .checkTokenAccess("isAuthenticated()");
	}
isAuthenticated() means anyone cant access or validate the token from authorization server, so before that we have to inform which client credential like "abc.com" and "abc123"
   7. Start the application
   8. In Postman with GET request provide the endpoint as
http://localhost:8080/oauth/check_token?token="paste access_token"
   In Authorization tab - select Basic_auth 
      - provide client username and password as "abc.com" and "abc123"
      - Click SEND
Now it will provide all client info, user info for that particular token as

{
    "active": true,
    "exp": 1617641165,
    "user_name": "senthil",
    "authorities": [
        "read"
    ],
    "client_id": "abc.com",
    "scope": [
        "read"
    ]
}

   9. In case if u dont want to authenticate particular client, in that case we can provide 
public void configure(AuthorizationServerSecurityConfigurer security) throws Exception {
		security.passwordEncoder(NoOpPasswordEncoder.getInstance())
		        .checkTokenAccess("permitAll()");
	}
Start the appl, in postman with GET request provide 
http://localhost:8080/oauth/check_token?token="paste access_token"
   In Authorization tab - select no auth 
      - Click SEND
Now it will provide all client info, user info for that particular token as

Second way - Black boarding approach
     In real time when access_token generates and send to the client, the access_token will be stored into database. Here auth server and resource server access the same database. So once access_token generates, before sending to the client, it will store the token inside database and then send to the client.
     Now from the client it send the token to resource server, now resource server will go to database and fetch the access token and check it validate or not.


Spring Boot oauth2 Authorization server and Resource server 

https://github.com/talk2amareswaran/Spring-Boot-2.1-OAuth2-Authorization-Server-and-Resource-Server-JWT-and-MySQL

Step 1:
   - we create userservice database
   - Create table permission which stores permission details
   - create role table which stores roles
   - create user table 
   - Create assign_permission_to_role table used to assign permission to every role
   - create assing_user_to_role used to assign user to role
Here John is an adminstrator with roles create_note,edit_note,delete_not,view_all_note,view_note and Mike is user with view_all_note and view_note roles.

Step 2:
    - Create SpringBoot-AuthServer project with web,data jpa,mysql, oauth2 client dependency 
    - In application.yml, we configure database properties 

Step 3:
    - We create public and private key for auth and resource server using Open SSL
    - Download openssl from https://code.google.com/archive/p/openssl-for-windows/downloads
    - Extract OpenSSL and configure in env variables as
           Path: c:/softwares/openssl/bin
           OPENSSL_CONF: c:/softwares/openssl/openssl.conf
    - open openssl command prompt
    - Both public and private key are used to make resource server should understand that token has been received from the authorized auth server. To make reliable communication between auth server and resource server we have to generate the public and private key and to be mentioned in application.yml file
    - To create private key we have to use
              OpenSSL> genrsa -out jwt.pem 2048
      We have openssl command to generate private key using RSA algorithm, file name is jwt.pem of size 2048
    - Now we fetch private key using
              OpenSSL> rsa -in jwt.pem
    - Now we fetch public key using
              OpenSSL> rsa -in jwt.pem -pubout
     public key can be given to resource server, but both keys have to configure only inside auth server
    - Now we configure both keys in application.yml file
        accesstoken_validity: we are going to get jwt token from auth server,so validity of access token provided is 1 hr
        refreshtoken_validity: 30 days, once access token is expired we can send refresh token to auth server until access token is created 
        public and private key: we are going to wrap into JWT token so that the resource server can understand the token has been coming for authroized auth server

Step 4:
    1. Define @EnableAuthorizationServer in main appl, so that it will act as authorization server
    2. Define model class called UserEntity with id, name,emailId,password and list of permission assigned to user based on roles
    3. Create CustomUser class which extends User class and we have set all user info to User class of Spring security
    4. Create CustomTokenEnhancer class, by default JWT token contains information about the username and users permission list, if u want to add any other info into JWT token we can use this class.
       We get prinicpal object which returns CustomUser, in that we add additional info like id, name and username into jwt token
    5. Create SecurityConfiguration class which provides the security configuration info like password should be encoded using BCrypt encoder, custom user details service
    6. Create Oauth2Config class,whatever oauth2 configure we provide inside application.yml is configured inside Oauth2Config class
      - We take all values from yml file like clientid, secret, publickey, private key using @Value 
      - Autowire passwordencoder and authenticationmanager bean
      - Next we override configure() for security purpose and client info to configure
      - Next configure() which accept AuthorizationServerEndpointConfigurer to configure the JWT token and token converter separately


Step 5:
    1. Start the application
    2. In Postman give POST request with http://localhost:8080/oauth/token
 - In Authorization tab - select Basic Auth - provide client details in
       username: senthil1418
       password: senthil@123
 - In Body tab - Select x-www-form-urlencoded - Provide
       grant_type: password
       username: john@gmail.com
       password: password
 - Click SEND
     Now it will generate the access_token and refresh_token,bearer, expiry and additional info called id,name,username
 - Now copy the access_token and paste in jwt.io, u can see the authorities and user info. Now give public and private key and u can check whether the signature is verified or not
   
Step 6:
   1. Now we create resource server and we can write access control endpoints in resource server and access those endpoints  by sending the bearer token and fetch those info from resource server
   2. Create SpringBoot-ResourceServer with web and oauth2 client dependency 
   3. Define @EnableResourceServer in main app so it will act like resource server
   4. We configure few properties in application.yml like name,port and public key     5. We have access token which contains additional info of user so we are going to decrypt the access token and save inside model class called AccessTokenMapper
   6. We create security configuration inside SecurityConfiguration class and we override configure()
   7. Now we want to decrypt all JWT token details in resource server and store in AccessTokenMapper class using JWTConverter class.We have extractAuthentication() which extracts authentication info and store in AccessTokenMapper
  8. Create Rest controller in resource server for post,get,put and delete request
Here who have role CREATE_NOTE they only have permission to access createNote(). Now assume we got access_token from auth server and then we try to access these resources createNote(),editNote() methods etc by using access_token but if access_token contains the permission (ie) roles then only we can access.
    If we want to fetch AccessTokenMapper custom details we can fetch using SecurityContextHolder      
  
Step 7:
   1. Start the application
   2. In Postman with POST request we give http://localhost:9090/note
     In Authorization - Select Bearer token - paste the access_token generated
     Click SEND
   3. In Postman with PUT request we give http://localhost:9090/note
   4. In Postman with DELETE request we give http://localhost:9090/note
   5. In Postman with GET request we give http://localhost:9090/note
   6. In Postman with GET request we give http://localhost:9090/noteById
Now John can execute all endpoints because john has all permission to access      


Step 8:
   Now we are going to give permission for Mike, he has only VIEW_ALL_NOTE, VIEW_NOTE
    1. In Postman give POST request with http://localhost:8080/oauth/token
 - In Authorization tab - select Basic Auth - provide client details in
       username: senthil1418
       password: senthil@123
 - In Body tab - Select x-www-form-urlencoded - Provide
       grant_type: password
       username: mike@gmail.com
       password: password
 - Click SEND
     Now it will generate the access_token and refresh_token,bearer, expiry and additional info called id,name,username

Step 9:
   1. In Postman with GET request we give http://localhost:9090/note
   2. In Postman with GET request we give http://localhost:9090/noteById
Now Mike can execute only /note and /noteById endpoints because he have only 2 permission, but he tries to access other endpoints he gets access denied     


Authentication and Authorization
     Authentication is about verifying who you are, for example when u login into web appl using ur username and password, you are letting the appl to identify who you are 
    Authorization on the other hand is about verifying what u r allowed to do, what resources u r allowed to access, so once u have logged in and identified urself, you have some role or access rights assigned to you. For example once you have logged in, you can create, edit and delete ur threads, but you dont have the rights to edit or delete other peoples threads, the way that works is through authorization in those apis

Basic Authentication
     You take the username and password, base64 encode it and add it to the header of your request, so for this reason it was always combined with ssl. This is simple and there are couple of problems with this approach 
    The most obvious one is that username and password are sent with each request leading to a much higher chance of attacker compromising the data, on top of this integrations with other applications is not great
    Let's say your api is twitter for example, it has large user base and some 3rd party appl who would like to build on top of your api's, these apps might want to allow users to post tweets on behalf of them, to do this with basic authentication would mean that the users would need to share their user credentials with these appl, this is bad because appl have to store these  credentials in clear text or in a way they can decrypt them 
   If a bug or leak in the appl exposed this data, an attacker could gain access to credentials, given that most people stick to same username and password for multiple accounts, this is bad in so many ways.
   This also leads to another issue, lets say user has authenticated against multiple appl, there is no way for the user to revoke access to single appl, because changing password would revoke access to all the appl and this is not desirable
   Finally applications get full access to user data, there is no way to limit the amount of access an appl should get to these selected resources. For example these apis want to post tweets on behalf of user, but technically they have access to their direct messages, their timeline and all the other data that the user has, so for these reasons basic authentication has proven to become a legacy form of authentication
   We use twitter as example, since twitter actually used to use basic authentication back then and for all the reasons that we just discussed above, twitter decided that basic authentication dosent work and they move to OAuth to solve all these problems

OAuth
   It is a standard that was introduced in 2007, basically it allows to grant access to applications without having to share passwords with them 

1. No password sharing
2. Each appl gets registered with ur api, and user has opportunity to revoke access to each of those appl individually 
3. User have granular access to resources, in fact oauth is all about limiting access to resources
 
OAuth Authorization Code flow 
    Consider twitter example, u have got ur api and got ur users, thers is a 3rd party appl that wants to integrate with ur api on behalf of the users.
   Normally flow usually happens on front and back channel, the front channel is the code that runs in a browser or some less secure interface, the back channel is secure server something that you have full control over, unlike the front channel
   Now user wants to use a feature of the 3rd party appl that ur api provides, to make this work ur 3rd party appl will get the user to redirect to authorization server, in this case its twitters authorization server. We pass some key piece of information along with this request, we indicate something called redirect uri, this is where authorization server will callback when users interaction is done 
   There also something called response type, this is where we indicate oauth flow that we want to use, in this case authorization code flow is indicated by "code". Finally we also indicated scopes needed, in this case it is write access 
   So we basically saying this user would like to authorize my appl to use ur apis to get write access, then this prompts the user to login and consent to providing the requested access rights. 
   Once user consents to it, it gets what is called an authorization code, the app then uses this code from back channel and exchanges this code with the authorization server again to get what is called access token, this access token is then used to make requests to the api to perform any action. So in this example, the appl can post tweet on behalf of the user. 
   If u think why we get an authorization code and then exchange it for an access token, because of security. The browser is not fully trusted,so we dont want to expose access token in the browser, even if authorization code is stolen, an attacker cant directly use it to exchange it for access token, this is because  back channel will also pass a secret which only the authorization server and back channel knows about it during the exchange. 
   So basically this is how oauth will allows applications to integrate with apis in a secure manner  which also allows granular access to resources. Oauth is very popular, so people misusing oauth, they started using it for authentication rather than delegated authorization which is meant for
    It means it was used to identify users rather than focussing on access rights, the end result is an access token which was never meant to hold any user info like name, email or any other relates to the identity of the user and this is where openID connect came into picture

OpenID connect
    It is a simple identity layer on top of oauth protocol which tackles identity problems that many people tried to solve using oauth. 
    So it is not a separate protocol, its meant to work together with oauth and standardize authentication and authorization 

OpenID integrates with Oauth
    When we make a request from front channel to authorization server, in the scopes we mention one additional piece of information called openid, this indicates authorization server that we are interested in getting back something called an "id token", so id token is meant to give access to user info, the access token meant for authorization problems.
   It is used to standardize authentication and authorization 

Scopes(read,write,read-write)
   Oauth scopes are used to limit an application access to user data, during the authorization request the api provider will display all the requested scopes to the user, this way user is able to understand exactly what access rights they are providing to the appl

Refresh tokens
      It is not good idea to have an access token  that can live forever, to tackle this problem oauth protocol provides limiting the validity of an access token, this adds another layer of security
     Many api providers choose to set expirations of anywhere between few min or hours or even days, depends on api providers.Now if you provide access tokens with expiry then you need to let the client get a new token whenver it expires
    Typically u dont want end users to be involved in this renewal process because that would be super furstating for the end user to keep logging whenever something expires, so it has to be done behind the scenes by issuing refresh token
    It is a special kind of token which can be used to request new tokens whenever the current one expires. The appl need to provide the client id and the secret, this is the info that you get back when an appl registers with an api and you pass this info along with a refresh token to get a new access token 
   In oauth flow, an authorization server that provides an access token which has a limited validity will also provide a refresh token, so the appl stores this refresh token but continues to make requests with an access token and at some time the access token will expire, this is when the appl uses the refresh token exchanges with the authorization server for a new access token   and then makes a new request which will succeed


SpringBoot-WebApplication
      We created springboot appl with bootstrap and themeleaf, this appl allows any user to visiting our site to read or modify data. But we dont want to do that, so we secure our appl by authenticating and authorizing users 
     Spring security takes care of it with minimum configurations, it is powerful and highly customizable authentication and access control framework. Authentication is a process of verifying who a user is while authorization is the process of verifying what the user has access to
     In our appl, we have 2 users (ie) user1 with admin privilege and user2 with normal user privilege, though both are valid users, who can login into our appl. Only the user with admin privilege should have access to modify the data and normal user should only be able to view the data 

1. Add spring security dependency for the above project 
so form based and http basic authentications are enabled for all requests
  It will generate auto generated password to access ur appl, with username as "user"

2. Now run the appl, localhost:8000/login, give username as "user" and password as "generated password from console"
   To logout, spring security provides default path called "/logout", so we give localhost:8000/logout, which does post request for same logout path and spring renders logout success url which is default "/login" with query string "logout", which is used by login html to display the message that user has logged out successfully 

3. In real world we need more fine grained control on what paths are restricted and who gets to access which resource, with more user and not generated security passwords
   So we create configuration class that extends WebSecurityConfigurerAdapter and annotate with @EnableWebSecurity and we will override spring security configure() with HttpSecurity and AuthenticationManagerBuilder arguments
     The default configuration of HttpSecurity method is that, every request needs to be authenticated, both form login and http basic authentication is enabled by default
@Override
    protected void configure(HttpSecurity http) throws Exception {
   http.authorizeRequests()
                .anyRequest().authenticated()
                .and()
                .formLogin()
                .and()
                .httpBasic();
}

    - The other configure() which has AuthenticationManagerBuilder as parameter, AuthenticationManagerBuilder is used to create an AuthenticationManager instance which is main spring security interface for authenticating a user. We can AuthenticationManagerBuilder to build in-memory authentication or ldap authentication, jdbc authentication or you can even add your own custom authentication provider
    Now we create in-memory authentication by adding 2 user, one user with username "user" and password as "pass" with the role user, and another user with username "admin" password as "admin" and role with "admin". 
    In Spring security version 5, u can no longer store your passwords in plain text, u have to provide PasswordEncoders, all password encoders implement PasswordEncoder interface, which defines method encode() to convert plain password into the encoded form and method matches() compare plain password with encoded password. Before version 5, the default password encoder is NoOpPasswordEncoder which is not secure, since it doe no hashing and used only for testing purposes where you prefer working with plain test passwords.
   In Spring security 5, the default is DelegatingPasswordEncoder which requires password storage format. We are using NoOpPasswordEncoder in our demo

@Override
	protected void configure(AuthenticationManagerBuilder auth) throws Exception {
		 auth.inMemoryAuthentication()
		     .withUser("user")
		     .password("{noop}pass")
		     .roles("USER")
		     .and()
		     .withUser("admin")
		     .password("{noop}admin")
		     .roles("ADMIN");
	}

4. In header.html, we create Logout button 
   We can see Thymeleaf th namespace and sec namespace in html, Thymeleaf spring security modules provides sprinfg security dialect which we can used to print logged in users credentials and show different content to different roles.
   To use this module, we need to provide thymeleaf-extras-springsecurity dependency. The spring security dialect allows to conditionally display content based user roles, permissions and other security expressions 
   It also gives access to spring authentication object, the sec:authentication attribute is used to print the username and roles 

5. For control of authorization, we make use of configure() with HttpSecurity parameter.
   HttpSecurity allows configuring web based security for specific http requests, by default it can applied to all requests, but can be restricted using requestmanaher or other similar methods 
   authorizeRequest() allows restricting access based upon the HttpServletRequest, here we use antMatchere() which will configure  http security to be invoked only on the matching ant style path pattern 
   In our appl we want to allow the operations like add, delete to the users who have admin role only, to do that we add 
.antMatchers("/category/?**","/questions/?**").hasRole("ADMIN")
.antMatchers("/api/**").permitAll()

6. Similarly in questions.html, we add 
<td sec:authorize="hasRole('ADMIN')">, so that edit andf delete actions is visible only to admin 

7. Run the appl, if u login as user u cant add new question, edit as well as delete the question
    If we login as admin, all privileges are avaialable 


Authenticating user with database
    Spring Security provides inbuilt JDBC authentication which provides support for username, password based authentication that is retrieved using JDBC 

1. Create user_info table with user_id, username,pwd and roles
sql>create table user_info(user_id int,username varchar(20),pwd varchar(200),roles varchar(200), constraint user_pk primary key(user_id));


2. Create UserInfo jpa entity class and repository interface

3. We create custom implementation of Spring Security using UserDetailsService interface
    - Create UserDetailsServiceImpl class which implements UserDetailsService, which overrides loadUserByUsername() which returns UserDetails instance.
    UserDetails interface provided by Spring security to store core user details which defines methods like getUsername(), getPassword(), getAuthorities() etc. We need to provide concrete implementation of these interface
    - Now we need to talk to database, to fetch user info from table, so we autowire the UserInfoRepository 
    - Now loadUserByUsername() will use findByUsername() of UserInfoRepository to fetch userinfo object. We can return an instance of UserDetails, by creating UserDetailsImpl object which takes userInfo JPA entity as argument

4. Create UserDetailsImpl class which implements UserDetails interface and override all methods.
    UserDetails interface works as an adapter between ur own user database and what spring security needs in SecurityContext holder.
    We make use of UserInfo JPA entity which is an representation of user_info table, by adding as member of UserDetailsImpl class. Here getPassword() returns password and getUsername() should returns username
   Next getAuthorities() returns the authorities granted to the user. In spring security "GrantedAuthority" is individual priviledge or permission, these permission are expressed as strings and spring decides if the user has access to something
    Roles are coarse grained GrantedAuthority with prefix  "ROLE_", for example the condition hasRole('ADMIN') is same as hasAuthority('ROLE_ADMIN').
    In UserInfo table we have define roles which contains comma separated roles for user, that string need to converted to collection of GrantedAuthority 
  To do that first we null check on roles, if it is null we return an empty ArrayList or we use Arrays.stream() which gets sequential stream from String array, which we get by splitting the roles using "," delimiter, on resulting stream we apply map() which creates a new SimpleGrantedAuthority with "ROLE_" and returns resulting stream. On that stream we use terminal operation collect() which will convert to list using Collectors.toList()  
  
5. In SecurityConfig, we need to configure DaoAuthenticationProvider, for that we need an instance of UserDetailsService implementation, so we create a method which returns UserDetailsServiceImpl anbd annotated with @Bean 
@Bean
    public UserDetailsService userDetailsService(){
        return new UserDetailsServiceImpl();
    }

Next we need password encoder for authentication, we use BCryptPasswordEncoder which is preferred because of its strong hashing function
 @Bean
    public PasswordEncoder passwordEncoder(){
        return new BCryptPasswordEncoder();
    }

Now we configure DaoAuthenticationProvider, which returns an instance of DaoAuthenticationProvider and set UserDetailsService to our custom implementation and the password encoder as value get from passwordEncoder()

 @Bean
    public DaoAuthenticationProvider authenticationProvider(){
        DaoAuthenticationProvider daoAuthenticationProvider = new DaoAuthenticationProvider();
        daoAuthenticationProvider.setUserDetailsService(userDetailsService());
        daoAuthenticationProvider.setPasswordEncoder(passwordEncoder());
        return daoAuthenticationProvider;
    }

Now we configure DaoAuthenticationProvider to AuthenticationManagerBuilder using authenticationProvider(), this will add DaoAuthenticationProvider in addition to in-memory authentication, and we change in-memory authentication password to use Bcrypt password encoder 

@Override
    protected void configure(AuthenticationManagerBuilder auth) throws Exception {
        auth.authenticationProvider(authenticationProvider());
        auth.inMemoryAuthentication()
                .withUser("user")
                .password(passwordEncoder().encode("pass"))
                .roles("USER")
                .and()
                .withUser("admin")
                .password(passwordEncoder().encode("admin"))
                .roles("ADMIN");
    }

6. But user_info table does not have any records, we can manually add some data using insert query but it is problem since we need to store password in encoded format
   Spring framework provides functional interface "CommandLineRunner" which we use to insert test entries in user_info table programmtically 
   Create DbInitializer class which implements CommandLineRunner and try to insert some values inside user_info table

7. Run the appl, localhost:8000/login 


OAuth2.0, OpenId connect - works below 2.6.0 version
     In previous 2 methods, user management is tedious task and have to waste lot of resources  into keeping ut appl secure, so we can delegate authentication and authorization to 3rd party identity and access management provider like Okta
    - Okta provides an implementation of OAuth2.0 and OpenID connect which makes it easy to add Single signon(SSO) page for spring boot appl 
     Single SignOn is an authentication method that enables user to securely authenticate with multiple appl and websites by using just one set of credentials. This prevents the need for user to login separately into different appl
    - OAuth2.0 is industry standard protocol for authorization. OAuth2.0 authorization framework is a protocol that allows the user to grant a 3rd party website or appl, access to the users protected resources without revealing their credentials or identity 

OAuth2.0 flow
    - OAuth2.0 authorization has following roles like Client, Resource Owner, Authorization Server and Resource server 
      Resource Owner is an entity that can grant access to the protected resource, typically it is end user.
      Resource server is the server which is protected resource that u want to access 
      Client is the appl requesting access to a protected resource on behalf of resource owner
      Authorization Server is the server that authenticates the resource owner and issues access token after getting proper authorization, in our case this is Okta
    - OAuth introduces an authorization layer and separates the role of client from that of resource owner.  In Oauth, the client request access to resources control by resource owner and most by resource server. Instead of using resource owners credentials to access protected resources, the client obtains access tokens
    Access tokens are received to 3rd party client by authorization server with acknowledgement of resource owner, then client uses access token to access the protected resources hosted by resource server 

OpenID Connect 
    OpenID Connect or OIDC is simple identity and authentication layer on top of OAuth2.0 protocol, it allows client to verify their identity of enduser based on the authentication perform by authorization server, as well as to update basic profile information about enduser
    Okta with help of Oauth2.0 and OIDC protocols provides the ability to link users digital identity across separate security domain 

Authorization Code flow provide by Okta
     Here resource owner which is us the enduder, tries to access spring boot appl, the resource server take us to spring boot appl login page, on ur appl login page we have button to signin using okta, the button hits "/authorize" endpoint of okta server with info like client id, redirect uri, request authorization code
    If ur not logged in already, u will redirect to okta signin page and once u submit ur credentials to okta sign in page, the browser will redirect to redirect uri with authorization code 
    Now our spring boot appl will can exchange this auth code for access token and id token. Our appl hits "/token" endpoint of okta with info like client id, client secret, auth code and response will contain access token and id token. The id token is issued by OpenID provider and contains info about end user in the form of names encoded and secured Json web token(JWT)
    Te return id and access token are validated by our appl and then grants access to resource server (ie) our spring boot appl.
   In this whole process, our spring boot appl does not handle user credentials directly, our appl only deals with oauth code and tokens received from auth provider Okta 
   
   Access token vs ID Token
      Access token is something similar to tempory access card u will be provided in hotel rooms, it is temporary once u check out of the hotel it will be revoked.
      ID token is something specific for yourself, for example pancard we have our information about ourself in this particular ID token, ID token has time period. So OpenID connect use ID token by default and OAuth uses access token 
      So ID token is something specific to user who allowed you to access it and access token is something temporarily who acts as a particular resource. In hotel; reservation, our govt ID card is ID token which has info about ourself and temporary access card which is given to access each room is a access token 

Resource Server vs Authorization Server
      Resource Server is a server which holding a resource to access something (ie) our Springboot appl and Okta is authorization server which authorize me to allow our spring boot appl

Resource Owner vs Client
     Resource owner is not the appl but ourselves, so client is our spring boot appl and resource owner is us because we are allowing springboot appl to use our information 

1. To implement Oauth login with okta, signup in okta
from https://developer.okta.com/signup

https://dev-62948164.okta.com/oauth2/v1/authorize?client_id=okta.2b1959c8-bcc0-56eb-a589-cfcfb7422f26&code_challenge=lzUws9gyUqhPq_34Ecb_DtpPo8J9goG2vFy3VTz8CPA&code_challenge_method=S256&nonce=QUoT2r2XvarSrRofvPu41BjdkfkDnJzW8zKWTVv0hc7UlBFKr4Fd6BHV11Tg3GTN&redirect_uri=https%3A%2F%2Fdev-62948164.okta.com%2Fenduser%2Fcallback&response_type=code&state=ZtMYAyfZdkgaofFAFTdlw2lCEfHHowYx8ZGJlSygfFA3wLPDOvOvUyGQag62Hx70&scope=openid%20profile%20email%20okta.users.read.self%20okta.users.manage.self%20okta.internal.enduser.read%20okta.internal.enduser.manage

click 3lines in top - Expand Application - Click Application - Click Create App Integration - select OIDC OpenID connect - Select web application - click next

App Integration Name: QuestionBank

Sign-in redirect URI: http://localhost:8000/login/oauth2/code/okta

Base URIs: http://localhost:8000

Controlled Access:Allow everyone in ur organozation to access

Click Save

Copy client id and secret 

client id: 0oa5aj227cUjNAb2F5d7
secret: LYGEipQQJELwYNls7pJQh7r3mjgeYXMnkZqgWqW6

2. Provide 3 dependency in pom.xml

<dependency>
			<groupId>org.springframework.security</groupId>
			<artifactId>spring-security-oauth2-client</artifactId>
		</dependency>
		<dependency>
			<groupId>org.springframework.security</groupId>
			<artifactId>spring-security-oauth2-jose</artifactId>
		</dependency>
		<dependency>
			<groupId>com.okta.spring</groupId>
			<artifactId>okta-spring-boot-starter</artifactId>
			<version>1.4.0</version>
		</dependency>

3. In SecurityConfig, we already implemented configure() with HttpSecurity as parameter, this method defines bunch of authorization rules
   The path starting with "/category" and "/questions" are allowed to access only by user who has role "Admin" and "/api" path is permitted for all. Now we add oauth configuration to HttpSecurity object and configure login page for oauth2 as "/login"
      .oauth2Login().loginPage("/login");
  OAuth2 login path is not defined, spring security will generate default login page with hyperlink to okta login page overriding our custom formlogin page
   In our appl, we need both form login and single signon from our custom login page, hence we provide login page for oauth2 login as "/login"

4. In application.properties, configure okta properties like client id, issuer and secret
   We can get client id and secret, in order to get issuer (ie) ur authorization server

click 3 lines - Security - API - copy issuer uri

https://dev-62948164.okta.com/oauth2/default


okta.oauth2.issuer=https://dev-62948164.okta.com/oauth2/default
okta.oauth2.clientId=0oa5aj227cUjNAb2F5d7
okta.oauth2.clientSecret=LYGEipQQJELwYNls7pJQh7r3mjgeYXMnkZqgWqW6
spring.thymeleaf.cache=false

5. In our custom login page, we need to add "signin to Okta" button which would redirect to okta signin page.
   This is done by adding hyperlink in login.html

 <div class="card-footer">
                <a class="btn btn-block btn-primary" href="/oauth2/authorization/okta"><i class="fa fa-sign-in-alt mx-2"></i>Sign In with Okta</a>
            </div>

6. Run the appl, localhost:8000, now we can see "SignIn to Okta" button in login form
    Now it will login through Okta and connect to our application with Single signin 
    But it will display logged in as alphanumeric value , but it has to display username from login account

7. To understand we need to know what are the information our Oauth provider Okta sends to our appl as claims in ID  token and access token 
     To inspect user attributes from Okta we can create request mapping method in "QuestionBankUIController" program 
    Now created a request "/oauthinfo" handle by oauthUserInfo() which is annotated with @ResponseBody annotation
    We inject OAuth2AuthorizedClient and OAuth2User object into method which is provided by Spring security  for oauth2 user at runtime. We are using info from this injected objects to print user attributes in html format 

8. Now when we run the appl, localhost:8000 and click "SignIn to Okta", it wont access for username and password since we have already signed in with okta, so it will automatically login into our application

9. Now we provide, localhost:8000/oauthinfo, which will display info like username, user authorities etc
    Username is id of the user, to get name we can see name attribute under User Attributes field, User Authorties attribute has list of authorities granted to user like ROLE_USER and list of scopes, these values can be used for authorization and based on different user roles, access can be granted or denied to set of resources 
   SCOPE_openid is scope unique to oauth users and will not be present for user logged in with form login
   We can use these in Spring EL condition with help of thymeleaf inside header.html

 <span th:if="${#authorization.expression('hasAuthority(''SCOPE_openid'')')}">
                Logged in as <span sec:authentication="principal.fullName" ></span>
            </span>
            <span th:unless="${#authorization.expression('hasAuthority(''SCOPE_openid'')')}">
                Logged in as <span sec:authentication="name"></span>
            </span>

If the user have authority "SCOPE_openid" so the user is oauth user and thymeleaf if contition evaluates to true, and we use "principal.fullName"  attribute from Spring security authentication object. Otherwise if the user logged in using existing form login and we print the same using "name" attribute in authentication object 

Now run the appl, localhost:8000, click "SignIn to Okta", now it will display the username,

10. Now we implement authorization using okta, we can see oauth user has only view access and dosent see edit,update and delete button, this is because the default role for user in okta is user.
     In previous project we have assigned different roles to different user using formlogin and we restricted access to user with role user and granted full access to user with role admin 
   To implement same in okta 

click 3 line - Directory - Groups - Add Group

Name: ROLE_ADMIN
Description: Admin 

Click on ROLE_ADMIN - People - Assign People - click Add all - click Save 

Goto Applications tab - Click Assign Applications - Select SpringBootApplication - Click Assign - Click Done

Click 3 lines - Goto Applications - Select SpringBootApplication - under Assignments tab - Select Groups - check ROLE_ADMIN is assigned to that appl

Click 3 lines - Goto Security - Click API - Select default authorization server - Goto Claims tab - Clcik Add Claim - 

Name: groups
Include in token type: Access Token
Value type: Groups
Filter: Matches regex .*
Include in: Any Scope
     click Create 

Once again click Add Claim

Name: groups
Include in token type: ID Token
Value type: Groups
Filter: Matches regex .*
Include in: Any Scope
     click Create 
	
Now when restart and run the appl once again, now we can see edit,delete and add button

Now if we inspect "http://localhost:8000/oauthinfo", we can see new attribute called "groups" with value Everyone and ROLE_ADMIN. Spring will automatically extract groups claim from JWT and maps it to Spring authority, so user now has both roles so he can do all operations


Spring Boot with JWT
     
1. Create SpringBoot-JWT1 project with web, data jpa and mysql,spring security dependency
2. Create Role Entity class
3. Create RoleRepository interface
4. Create RoleService class 
5. Now we want to create a new entity to store user info, create User entity class, with many user have many roles 
6. Create UserRepository interface
7. Create UserService class
8. Create UserController class
9. Now run the appl, it will create user,role, user_role table in db
10. In UserController, we create 2 endpoint "/forAdmin" and "/forUser". But in this case the appl is not secured, since both endpoints will be accessible to everyone 
  In order to make appl secured, we apply JWT token and role based authentication 

11. Apply 2 dependency spring security, jwt 

12. We need to tell our appl that the appl needs to use Spring security, so we have to configure the appl
  - Create CorsConfiguration, used to define the allowed mappings, methods in to the appl 
  - Create JwtAuthenticationEntryPoint, this class will basically an entry point which take care if something goes wrong, we just send message that u r not authorized 
  - Create WebSecurityConfiguration, with @Configuration, @EnableWebSecurity,@EnableGlobalMethodSecurity which will take care role based authentication, now we have multiple roles like admin, user and we use many endpoints specifically for admin and specifically for users
    This class will extends WebSecurityConfigurerAdapter class and override authenticationManagerBean() and configure() 


SpringBoot JWT
Step 1:  User/Client Register process
    - Client has to send above details as JSON format and that will be converted into User object and finally saved in database
    - When u run the appl, it will create user_tab and roles_tab
    - In Postman, run localhost:9000/user/save with POST request, in Body - Raw - JSON
{
   "name" : "Sam",
   "username": "sam",
   "password": "abcd",
   "roles": [
              "ADMIN",
              "EMP"
            ]
}

Step 2: JWTUtil class code
      - We use JJWT dependency to pom.xml 
      - We create JWTUtil class with @Component 

1. In application.properties file we create JWT secret 
       app.secret=kumar
2. Now we access that secret inside JWTUtil class using @Value 
3. Next we need to write method to generate token which returns string. Here if we give subject,it will prepare subject with details and compact() will return string representation of token 
4. Next method is used to read token data with token  
5. Next we create method to read expriry date from claims 
6. Next we create method to read subject/username
7. We create method to validate exp date
8. We validate the token, if it is not expired and validate the username/subject. From the token we take username and we check it is similar with database username and if token is still not expired then it is valid 

Step 3: JWT Token generation without security for testing
    - Read username and password as JSON format, convert to UserRequest object. Generate token and define one message, return this data as JSON format using UserResponse object 

1. Create UserRequest model class with username and password 
2. Create UserResponse class with token and message
3. Create loginUser() inside UserController
4. Run the appl
5. In Postman, run localhost:9090/user/login with POST request - in Body - Raw - JSON
{
   "username":"abc",
   "password":"xyz"
}
Now it will be generated token for the dummy username and password, which will be provided with header, payload and signature

Step 4: JWT Token after User Authentication 
1. Add Spring Security dependency
2. Create AppConfig class, to define PasswordEncoder before saving user into db
3. Modify UserServiceImpl to implement password encoding 
4. Create SecurityConfig class which extends WebSecurityConfigAdapter and overrider 2 configure() one with AuthenticationManagerBuilder and HttpSecurity 
    We will having a login process with username and password as json format. Now it will go to UserDetailsService interface with loadUserByUsername() which takes username as argument and communicates with our database, which returns model class User object and later converted into Spring Security User object 

5. In UserRepository, add findByUsername()
6. In IUserService declare the same method and override in UserServiceImpl class and fetch username from db
7. Now in UserServiceImpl class also implements UserDetailsService interface and override loadUserByUsername()
   Here we are returning Spring security User object which takes username,password and collection that contains GrantedAuthority objects and we have taken SimpleGrantedAuthority class which is implementation of GrantedAuthority 

8. Now we inject UserDetailsService, BCryptPasswordEncoder in SecurityConfig program for authentication 
@Override
	protected void configure(AuthenticationManagerBuilder auth) throws Exception {
		auth.userDetailsService(userDetailsService).passwordEncoder(passwordEncoder);
	}

Now we write authorization, that everyone can access "/user/save" and "/user/login". In case if any exception occurs we need to convert into a readable message 

9. We need to create authenticationEntryPoint to verify the user is loggedin
   Create InvalidUserAuthEntryPoint implements AuthenticationEntryPoint and override commence(), in case of form based we will write access denied page, but here it is Rest so we create simple JSON message

10. Normally AuthenticationManager checks for username and password incase of session, but here it is stateless session so checking should be manula, so we need to inject one more bean AuthenticationManager 

  @Override
    @Bean
    protected AuthenticationManager authenticationManager() throws Exception {
    	// TODO Auto-generated method stub
    	return super.authenticationManager();
    }

11. In UserController, loginUser() use AuthenticationManager and validate the username and password from database and generate  token 
    So in case form based login authenticationManager will automatically happen but in stateless session we need to provide as authenticationmanager to generate the token
    authenticationManager.authenticate() and pass UsernamePasswordAuthenticationToken which takes username and password as arguments. In case if it is not valid then automatically AuthenticationEntryPoint will be invoked 
   If it is valid then it will generate the JWT token and not valid means InvalidUserAuthEntryPoint is triggered 

12. Start the appl
13. Create new user in postman 

- In Postman, run localhost:9000/user/save with POST request, in Body - Raw - JSON
{
   "name" : "Ram",
   "username": "ram",
   "password": "xyz",
   "roles": [
              "ADMIN",
              "EMP"
            ]
}

14. In Postman, run localhost:9090/user/login with POST request - in Body - Raw - JSON
{
   "username":"sss",
   "password":"xyz"
}
Since username and password is wrong it will show 401 error "Unauthorized user"

15. In Postman, run localhost:9090/user/login with POST request - in Body - Raw - JSON
{
   "username":"ram",
   "password":"xyz"
}
Now it will be generated token

Step 5: JWT token verification from 2nd request onwards
    Now we write filter which will check verification process and that will implement session type authentication token, if it is valid then we have to continue 
   Consider we send http request to "/user/welcome", this can be accessed only by logged in person, so we need to pass generated token as authorization, if it is valid then only it gives the response. 
  Whenever we made request we are going to build one request filter called OncePerRequestFilter which is abstract class. It will first read and validate the token from authorization header using JWTUtil validate(), once it is valid we have to create SecurityContext object. Inside that we have to create object for Authentication
   From there it will go to WebSecurityConfigureAdapter and reads the authentication object we created, if it is valid it will access the resource or else it will show unauthorized user 
   In case of form based login, there is no need to create request filter, it will automatically created.

Define one filter which gets executed for every request, if request is having authorization heade, then validate using JWTUtil. If it is valid then create Authentication inside SecurityContect which will again communicate with WebSecurityConfigAdapter 

1.Create SecurityFilter class which extends OncePerRequestFilter and override doFilterInternal()

2. Register security filter in SecurityConfig 
.addFilterBefore(securityFilter, UsernamePasswordAuthenticationFilter.class);

3. Create a request in UserController class and return username from Principal interface 

4. Start the login
5. In Postman, run localhost:9090/user/login with POST request - in Body - Raw - JSON
{
   "username":"ram",
   "password":"xyz"
}
Now login into appl
6. Now access the resource 
In Postman, run localhost:9090/user/welcome with GET request, in headers
   Authorization: generated token


Spring documentation using OpenAPI and Swagger
     Documentation is an essential part of building REST api, the api documentation not only helps internal teams but it is very critical for external clients to tell how to consume ur apis. 
      There are several ways in which we can document ur rest apis, we can just use plain text and tell these are all the endpoints we have exposed and explain what our method does and how we consume our data and these are various exceptions. We can also use word document and write lot of text over there and create flow diagram about how data is flowing in our api, but now we have a standard to document REST apis and it is called OpenAPI specification 
     We use Spring doc which is a tool that simplifies the generation and maintainence of api docs based on openapi specification for spring boot appl

1. SpringDoc - openapi java library which helps in automating the generation of API documentation using Spring boot projects. It automatically generates documentation in json,yml and html format 
    This library supports openapi 3, swagger-ui, spring boot, JSR 303 annotation specifically for @NotNull, @Min,@Max and @Size, and also oauth2 

OpenAPI and Swagger
    Actually the standards are started by company called Smartbear software in 2015, now this openapi is managed openly. The first version cames as openapi 3.0, since 2015 it also renamed as swagger ui to openapi. Currently openapi we can see as specification which tells us how to document the rest api 
    Swagger now becomes a tool for implementing open api and also have set of tools which not only implement this specification but it can used by developers to interact with apisto visualize and generate some code


OpenAPI Specification (OAS)
      - It defines the standard, language interface to RESTful API's which allows both humans and computers to discover and understand the capabilities of the service without access to source code, documentation. When properly defined, a consumer can understand and interact with the remote service with minimal amount of implementation logic
     In order to understand this defination, we need to know why we need to apply this specification in our API 
     1. Imagine we will have a document which describe the whole api regardless of prg lang its built in, so basically if u have spring boot appl with rest api and we apply this open api specification standards, we can extract a json file for example which contains all the info of ur api, all th responses, all the tags everything. We can use this document to generate the code or the boilerplate code for ur api within different prg lang like nodejs, we can also use this document to benefit a large set of open api compatible tools like Postman 
     So basically we apply standards, we extract those standards and those standards are readable by all api tools 
     2. The ability to have ur API routing operations build in different prg lang with a click of a button (ie) We have one document and we can use this document to do lot of work 


There are 2 ways to create Open API Specification
   1. We use swagger editor to build json/yml file then use swagger code generator to create boilerplate code with ur preferred code lang for both backend and frontend
     Here we open swagger.io website, we use the editor over there to start building the schema and yml file or json file of open api specification, then we generate the boilerplate code for ur preferred code language 
     2. Implement openapi library dependency in ur project (java, node) and use swagger or openapi annotation to document and build the api 
     We use 2nd approach here

1. Create spring boot project spring web dependency
and add some controller into it

2. In postman, run all endpoints 
POST - http://localhost:8080/items

{
    "itemId":"5000",
    "title":"Java",
    "description":"core java",
    "completed":"true"
}

PUT - http://localhost:8080/items/5000?isClient=true
and in Headers part give key as fromHost and value as true 

{
    "itemId":"5000",
    "title":"J2EE",
    "description":"core java",
    "completed":"true"
}

GET - http://localhost:8080/items
GET - http://localhost:8080/items/200 - getById
DELETE - http://localhost:8080/items/200

3. Add open api dependency in pom.xml

<dependency>
   <groupId>org.springdoc</groupId>
   <artifactId>springdoc-openapi-ui</artifactId>
   <version>1.6.4</version>
</dependency>

Now start the appl and we can access swagger ui
http://localhost:9090/swagger-ui/index.html

We have user interface which displays all endpoints. Swagger interface gives u a lot of functionality to your project, for example to test each endpoint we have used postman to send request, now we can use swagger interface to do that.

Swagger user Interface 
    We can see that the naming is not correct, we need to start customize this user interface and we need to start to see the section of this swagger user interface
     First at the sections of this user interface we have search button in the top, where we can search if we have lot of endpoints and we need to search for specific endpoint. Next we have project title in this case it is "OpenAPI defination", next we have version of project as v0, next 0AS3 specifies the openapi specification version that we are using 
   Under that we can see small link "/v3/api-docs" which is the link for actual openapi specification document json file, we can take this json file and apply it on multiple tools to build api 
   Next we have servers section which include all the servers that we are using, in our case we have only one server since we are running locally, but if we are running ur project on cloud then we can have another server and we can switch between them 
   Next sections we have actual endpoints which has its own title. At the end of the section of this user interface we can see schemas or data model, in our case we have 1 data model called "Item" which is POJO class which has attributes and methods 

Now we customize this user interface and add some openapi defination to our project in order to describe the whole api

1. First we can change the project name and changing the version, we can do that by going to main class and use 

@OpenAPIDefination(info=@Info(title="Items API Project", version="1.0.0"))

If we save and run the project and refresh swagger ui, we can see changed project name and version for our specification and all those changes will be reflected inside json file of openapi specification itself (ie) "/v3/api-docs" 

2. Now we want to define our server info, here we are working on one server but what if we have another copy of this project running on some container in cloud and we also want to test some endpoints after the pipeline is executed 

@OpenAPIDefinition(
		info = @Info(title="Items API Project", version="1.0.0"),
		servers = {@Server(url="http://localhost:8080"), @Server(url="http://abc.com")}
)

Now if we run the project and refresh swagger ui, we can see 2 servers 

3. Now we describe our endpoint endpoint one by one and now we focus on one endpoint called UpdateItem because it has all the property that we want to define. Each one of the endpoint has its own tag or own category but it dosent make sense because all of those endpoints belonging to /items and all working with one data model so it make sense if we have all of those endpoints inside one tag only 
    We can define it by using @Operation which is swagger3 wrapper, so if we want to describe any endpoint it will be inside @Operation 

1. First tags attribute which is String[] so we give curly brackets and write tags, its array because each one of these endpoints can have more than one tag 

@Operation(
    tags = {"Items"}
)

When we run the project and refresh swagger ui, we can see Items tag for PUT endpoint. Now we copy same annotation and paste in all controller programs, if we run the project and refresh swagger ui we can see all endpoints will come under single tag called "Items" which make more sense
    Each endpoint can have multiple tags, for example if we need PUT request to appear at 2 place

@Operation(
    tags = {"Items","Items 2"}
)
 
If we run the project and refresh the swagger interface we can see PUT request will be under different tags 

2. In case if we want to provide some description for that tags, we can do it in main class with @OpenApiDefination annotation 

@OpenAPIDefinition(
		info = @Info(title="Items API Project", version="1.0.0"),
		servers = {@Server(url="http://localhost:8080"), @Server(url="http://abc.com")},
		tags = {@Tag(name="Items", description="This is Items API endpoints")}
)

If we run the project and refresh the swagger interface we can see description will be provided for Items tag

3. Next we describe endpoints and start putting some tags inside operation and we have more description for this endpoint
    First we can put operationId which is for referencing purposes maybe we have some callbacks or some other endpoints to communicate with this endpoint so we define a unique operation id and use it in the future 
 @Operation(
    	    tags = {"Items","Items 2"},
    	    operationId = "updateItem"
    	)
   - Next we can provide summary and description, so summary will come on the endpoint and description will come under the title 
   @Operation(
    	    tags = {"Items","Items 2"},
    	    operationId = "updateItem",
    	    summary = "This is the summary",
    	    description = "This is the description"
    )

   - This PUT endpoint have couple of parameters in this endpoint, first as a request this endpoint required a path variable called itemId, cookie parameter, header parameter and also query parameter. So inorder to fulfill this request we need to provide a path variable, cookie, header and query parameters. We put everything inside this endpoint and we can start to describe this endpoint 
   In request body we can provide the item object that to be updated in json format 
    1. First we describe our request body, we can have some description for this request body and even we can change the schema for this request body for any reason 
    In order to change the schema of the request body we create our own custom data model. In our case we create Customer.java

public class Customer {
    public String customerId;

	public Customer(String customerId) {
		super();
		this.customerId = customerId;
	}
}

Now we can implement this custom model in @Operation annotation 

@Operation(
    	    tags = {"Items","Items 2"},
    	    operationId = "updateItem",
    	    summary = "This is the summary",
    	    description = "This is the description",
    	    requestBody = @io.swagger.v3.oas.annotations.parameters.RequestBody(description="This is request body description",
    	    content = @Content(schema=@Schema(implementation=Customer.class)))
    )

If we run and refresh the interface, we can description under request body and it will have different schema which is customerid
 
    2. Next we define list of parameters like pathvariable, cookie, header and query parameters and for all parameters we can define one attribute called parameters 

@Operation(
    	    parameters = {@Parameter(name="itemId",description="This is path variable",example="4556")}
    )

When we run and refresh the interface, we can see description for path variable along with some example value which will be automatically filled in.
    Next it dosent make sense if we change the place of this parameters because we already defined it in Spring boot and swagger already know it, but in case if we want to change the place of parameter, for example from pathvariable to cookie value we can do that by using "in" which is enum type

  @Operation(
    	    parameters = {@Parameter(name="itemId",description="This is path variable",example="4556",in=ParameterIn.COOKIE)}
    )

When we run and refresh, we can see pathvariable will be changed to cookie, but now we have to provide as 
 
  @Operation(
    	    parameters = {@Parameter(name="itemId",description="This is path variable",example="4556",in=ParameterIn.PATH)}
    )

   - For other parameters it would same process so we can just copy and paste it, we can change name, description and put some example as we want 

    3. Next is hidden attribute, for some reason we want to hide the whole endpoint from user interface we can by using hidden, by default is false. If we set to true, ur endpoint will be hidden

  @Operation(
    	     hidden=true
    )

    4. Next we can define some external documents, sometimes we can have some description for your endpoint in this user interface but also we have extended documentation in other places, so we can define an external documentation which is external link for ur documentation

@Operation(
    	    externalDocs = @ExternalDocumentation(url="http://abc.com",description="For more details check the link")
    )

If we save and refresh, we can find more details and check the links 

     5. Next we can describe what kind of  responses we are expected, so as we know HTTP response code 200 means successful, 400 means bad request, 404 means its not found so we can describe all of this in here. We can also provide some description and also media type, in what format we need to get response

 @Operation(
    	    responses = {@ApiResponse(responseCode = "200",content = @Content(schema=@Schema(implementation=Item.class), mediaType = MediaType.APPLICATION_JSON_VALUE),description="Success Response")}
    )

If we save and refresh we can see response code 200 which is successful and we get schema as an example of the value we can get 
    If we have couple of responses variable here but we can define only one api response for each status code, but maybe there are some cases where sometimes we will have this as response and another data model as response, it dosent make sense but we are going to see how to work on it
    @Operation(
       responses = {@ApiResponse(responseCode = "200",
    	    content = @Content(schema=@Schema(implementation=Item.class), mediaType = MediaType.APPLICATION_JSON_VALUE,
    	              examples = {@ExampleObject(name="Success 1",value="Object"),
    	            		  @ExampleObject(name="Success 2",value="String")}
    	    		),description="Success Response")}
    )

If we save and refresh the interface, we can see under 200 status code we have Example1 and Example2, if we change the option we can see its related values


Security schemes
     Our endpoint will use some kind of authentication maybe http basic or bearer token or oauth flow. We can define this by doing 2 things, first we can define the global authentication in which the project will be used and we can see it as a description. Next is which authentication system each endpoint will use so it is endpoint specification but we defined it on the global term
 
1. In main class, we define security schema using @SecurityScheme 

@SecurityScheme(name="BearerJWT",type=SecuritySchemeType.HTTP,
        scheme="bearer",bearerFormat="JWT",
        description = "Bearer token for this project")

If we save and refresh the interface, we can see Authorize button, when we click it we can see Bearer JWT as we define the name, description, type. 
     So we have defined the global authorization system but not even one of those endpoints are using it, because sometimes we will have public endpoints and where u will have a private endpoints, so we create endpoint specific authentication and not like a global one 

2. Now we define authentication for particular PUT endpoint, again we define configuration inside @Operation annotation

@Operation(
    	    security= {@SecurityRequirement(name="BearerJWT")} //provide same name as global auth
    )

If we save and refresh the interface, we can see lock icon for PUT request, so when we click it we can see Bearer JWT, which determine that this endpoint need an authentication 

Benefits of OpenAPI document (ie) json file
      We can access the file from "/v3/api-docs", now save this file as api-docs.json which is regardless of any prg lang
    1. We can use this with swagger code generation to generate some boilerplate code and also to preview the api itself 

Goto Swagger Codegenerator in Google - goto https://swagger.io - Editor - Try Swagger Editor - File - Import file - select json file 

Now we can see the entire endpoint, so benefit is that if u have any meeting with any client and we dont have ur project with u and we want to show the result of ur documentation for client or other part of team without having full springboot appl running, we can use editor here in code generation in swagger.io, to review ur swagger documentation 

2. This documentation is regardless of any prg language, we can see we built that using springboot and java, but what if for any reason we want to change the prg lang of ur api, for example nodejs with express 
   Once we have json file we can use swagger.io and we can generate a boilerplate code project for server as well as client
Click Generate server - Nodejs server  

3. We can use this json file with the postman and create whole api and documentation inside postman 
In Postman - File - Import json file 
  The postman identified this project as openapi and create whole api and documentation


OpenAPI documentation in yml file

openapi: 3.0.0
info:
   title: SpringBoot API 
   description: Springboot Course appl
   version: 1.0.0
   contact:
     email: abc@gmail.com
     name: Springboot

paths:  #define all endpoint urls
   /course/{course_id}:  #path for getting detail of course
      get:
        description: Fetch details of course
        parameters:
            name: course_id
            required: true
            in: path
            schema:
               type: integer 
        responses:
           "200":
              description: 200 responses
              content:
                 application/json:
                   schema:
                      $ref: "#/components/schemas/course"
   /course:
      post:
        description: Used to create course 
        requestBody:
          description: Structure of course
          required: true
          content:
             application/json:
               schema:
                 $ref: "#/components/schemas/course"
        responses:
           "200":
              description: Course created successfully 

components:
   schemas:
     course:
        type: object
        properties:
           title:
             type: string
           description:
             type: string
           id:
             type: integer 


 
Web Application Security
      Security is one of the most important non-functional requirement whenever we build appl. We might have a very strong appl, we might have very strong infrastructure but one small flaw can break security and thats where its very important that architects, developers, testers and functional users are aware about the security 

OWASP(Open Web Application Security Project) Top 10
     OWASP is non profit security organization which does analysis into security and provides a list called OWASP top 10 which gives an overview of what are major security flaws that are present in an application

1. Broken Access Control
2. Cryptographic Failures
3. Injection
4. Insecure Design
5. Security Misconfiguration
6. Vulnerable and Outdated Components
7. Identification and Authentication Failures
8. Software and Data Integrity Failures
9. Security Logging and Monitoring Failures
10. Server Side Request Forgery (SSRF)


1. Broken Access Control
         Broken access control moves up from the 5th position back in 2017 which is previous version of owasp top 10, and the appl that are tested for different security threads by owasp organization, 94% of appl had some form of broken access control
        Consider we have an appl and we have users that want to access the appl, but we also have attackers who are trying to do bad things to the appl and we want to let these good users in and we want to block the bad attackers. So there should be some kind of access controls that built in ur appl and one of the issues with this is that, there are so many different endpoints and that needs to be control around the appl to let the good people in and keep the bad people out
     So failures around access control will lead to things like information disclosure, information modification and these attackers may delete all ur data. 
     Consider we have an api endpoint like mail.example.com/messages/1234, so if we change that id to 5678, so behind the scene it is typically a sql or database call that something like
  select id,data from messages where id=1234
So now if we change id as 5678 then that would change the structure of this or change the contents of this sql message which is not good, so we could add few info like 
  select id,data from messages where id=1234 and messages.owner=owner
   So point here is we not only check the id is correct but also the actual owner who can access that message, so now we are doing some extra check to put control on the access to who can gain access to that api endpoint 
    We have some common access control vulnerabilities like violation of principle of least privilege where access should only be granted to users or roles, but instead its given to anyone, so the least privilege is basically give someone the least amount of privilege that they need to do their job, but if that starts to expand then we have problem
   Another is when we bypass access control checks by modifying the url or html page or using some kind of attack tool to modify api requests. 
   Another is viewing or editing of someone else account by providing unique identifier 
   Next is accessing an api with missing access controls for post,put and delete, so if we dont have controls around the methods that the api is able to handle 
   Next is force browsing to unauthenticated pages as an unauthenticated users. For example example.com/app/get_info so if we get to that url as unauthenticated user which is not good beacuse we are getting info about the app. At the same time if we access example.com/app/admin_getInfo so if u r not adming then we should not able to get data, so this is one of unauthenticated user should not be able to get to either one of these and non admin should not be able to get 2nd url, so some people can force browse to these urls and if we gain access then thats a problem 
     So we can deny by default, then we can implement access control mechanisms once and reuse them throughout the appl. We also should enforce record ownership rather than accepting the user can create or read or update or delete any record, so we need to enforce record owership. Next is log access control failures which is like monitoring and logging, but we need to log these failures 
    So good access control features are hard to add to an appl late in the development lifecycle so make sure we start this early on development lifecycle 

2. Cryptographic failures
         This shifts up one position to number 2 from the previous version, in fact previously it is called as sensitive data exposure, but sensitive data exposure is more of broad symptom rather than like a root cause so the focus really on failures related to cryptography which lead to exposure of sensitive data 
      When we think about cryptographic failures is the protection of data that we have in ur appl, sp data in transit or data at rest. For examples passwords or credit card number or personal info number etc, so if we have sensitive data then we need to  determine the protection needs of that data. 
     So when we build the appl we can use any kind of cryptographic algorithms or protocols and if we dont have any encrpyption then always use https.
     Next we can use key mgt which is the server certificate and trust chain is properly validated. Next dont write crypto on ur own, always use trusted libraries 

Example:
    Consider we have users who are accessing ur appl and this appl is connected to database which contains credit card information. So user access the appl and then appl sends an sql query to database, then the response (ie) credit card number, comes back from the db back to the user in decrypted and user pulls the data out of the database. If a attacker comes and perform an SQL injection attack and grab credit card number out of database which is automatically decrypted, then attacker would have access to that credit card number. So it is an example of cryptographic failure, in this case good to use encryption but bad to use automatic decryption 

Example 2:
   Consider we have variety of url and first one uses https which is good and another url uses only http, so we dont enforce tls or encryption for every single page on ur appl. So here attacker could listen to all of the traffic and if user accesses 2nd url then attacker could see all of that data which is not good, so we have enforce https across all urls

So finally if we have ur appl and we need to classify the data which is sensitive and which data maybe not sensitive. Next is dont store sensitive data unnecessarilt discard it as soon as possible, next encrypt all of ur sensitive data and rest back to database and no automatic decryption

3. Injection
       Injection goes down to 3rd position, in fact in 2003 this is number one on the list. When people talk about injection they talk about SQL injection, but injection is broader it is not just sql injection, we have LDAP and we can do injection attack with that or OGNAL(Object Graph Navigation Library) injection attacks etc. Also cross site scripting has been combined and it is part of this injection risk
     So typically applications are vulnerable to injections when user supplied data is not validated or filtered. Consider we have users that are sending input and ur appl reads and then takes action, so when user supplied data is not validated by the appl then we are opening urself for injection attack 

    Consider a code snippet

public Person find_Unsecure(String inputFromUser){
   return jdbcTemplate.queryForObject("select * from person where name="+inputFromUser, new BeanPropertyRowMapper<Person>(Person.class));
}

So here we are taking an input from the user and we are directly appending it to our sql stmt, so what would happen if the input from user is something like Ram or 1=1, then the query would become
  select * from person where name=Ram or 1=1
then every row from person table would be returned back which is not good practise and this is called as SQL Injection. But this method is protected because we are using a BeanPropertyRowMapper and try to map it to one person, but if we map into List of persons then this would have a serious security flaw 
    So here we are taking input from user and directly using it in a query without validating it. So as far as SQL is concerned the best way to do it using parametrized queries, so we use ? and make sure that value is passed into the name  
    
public Person find_Secure(String inputFromUsre){
   return jdbcTemplate.queryForObject("select * from person where name=?", new Object[]{inputFromUser}, new BeanPropertyRowMapper<Person>(Person.class));
}

So now the query look like
  select * from person where name='Ram or 1=1'
So here it will look for that specific name. So the base of preventing SQL injection is by using parameterized queries but in general the way we can prevent any of injections is by validating the data which is provided by the user 
    In LDAP samething happens instead of interacting with database, it interacts with LDAP server 
    To wrap up on preventing injection it really requires keeping the data separate from the commands and query. Next always we use server side input validation, also parameterize ur queries whenever we can, use of limit command where it is not loading the entire data  

4. Insecure design 
        This is new category on 2021 and focuses on the risks that are related to design and architectural flaws 
        So secure design can still have a problematic implementation or defects related to implementation that leads to vulnerabilities, but this is insecure design which cannot be fixed by a perfect implementation 
      Consider we are building an appl, prior to building we want to think about the architectural componentsy, how we are going to design and think about how to roll in security into that before even start writing ur first line of code 
      We have a movie theatre and we have an online appl where people can buy tickets, so they can come into ur appl and buy their tickets. Lets say in ur appl we want all these people to come ur theatre so we offer some kind of bulk discount and say that if there is less than 15 tickets so we can reserve those on this appl. So attackers take advantage of the design, so ur appl is amazing applin the sense it runs very fast, so basically attacker have taken advantage of an insecure design in the appl itself so attacker will buy out or reserve all the tickets and effectively block out any kind of a normal user to watch the movie
    So secure design is a methodology that constantly evaluates threats and ensures that code is robustly designed and tested to prevent attack methods in ur appl. So secure software requires some sort of secure development lifecycle or secure design pattern or secure component libraries or tools. We also reach out security specialist throughout the whole project and throughout the maintainence of the software, so incorporate security team throughout the entire lifecycle of this code. We use threat modeling for critical authentication, access control and business logic and key flows that going through the appl. Next we need to write test to validate all the critical flows through the threat model. We need to compile use cases but also missed use cases for every tier of appl, so when we do the testing we dont need to just test the appl to works but we need to do a misuse case also 

5. Security misconfiguration  
         So we have security components within ur appl but they are not configured correctly like we didnt change the default password 
         So couple of things to look for to know if ur appl might be vulnerable is if unnecessary features are enabled or installed, if default accounts and their passwords are still unchanged, maybe latest security features are disabled if we do an upgrade on ur software, maybe ur appl server is not sending security headers or they are not set to secure values, maybe the software taht we are running is out of date or vulnerable 
     Consider we have an appl and have designed securely but the software that is used to run this appl is misconfigured or we have appl server that ur appl is running on, that appl server comes with some sample appl and that appl is not removed when we install ur appl, and ur sample appl has some kind of known vulnerability. Now the attacker comes after sample appl and going to exploit these known vulnerability, for example default accounts are not changed, default password are well known in sample appl then the attacker can login with those default passwords and then take over the appl. So thats a problem so that would be a misconfiguration of security so now we need to remove of whole sample appl from the app server 
     Another scenario is when u r running an appl and its designed correctly, we have an error message that gets sent to the user whenever there is some sort of error, which includes all of the information, maybe as appl developer we are trying to give all the info about the error that we are experienced on my appl, where we are opening door for an attacker to knowingly create an error message and they start looking at all of these detail info and use that info and try to attack some sort of vulnerability that we have in appl. If there is too much detail in error message that could be a security misconfiguration 
     To wrap up in ur appl we have a minimal platform with least privilege that removes any kind of unnecessary features or components or documentation or samples 

6. Vulnerable and Outdated components
        This moves up from number 9 on 2017 list to number 6
       Consider we have an appl which is composed of many different components and that contains different libraries, so ur appl relies on 3rd party libraries or variety of external components that we bring together to build ur appl. When attackers are looking at the appl as wht type of components they made up of and what kind of libraries are in this appl
   So to know if ur appl is vulnerable we need to know all the different versions of all the components that we use both client side and server side, so if the software is vulnerable or unsupported or out-of-date then ur appl is vulnerable 
   If we dont scan for vulnerabilities regularly or like subscribe for security then we are vulnerable. If we dont fix or upgrade the underlying platforms or frameworks then we are proably vulnerable. If software developers who develop ur appl, if they dont test the compatibility of the updated or upgraded or patched libraries then we may vulnerable
     So to secure urself we need to remove any know of unused dependency, unnecesary features, unnecessary components. OWASP has a project called dependency check and it is very useful to run against ur appl to tell there is any unused or unnecessary dependencies. Next we need to continuously inventory the versions of both client side and server side components to see what u r running and we only need to use components from official sources over secure links, so dont and get some unverified component 
    We also need to monitor for libraries and components that are unmaintained or dont create security patches for older versions 

7. Identification and Authentication Failures
       Previously known as broken authentication and come down from the list, it was 2nd in 2017 list but now it is 7th position 
      We have an appl and we got users that want to access ur appl and there needs to be some kind of authentication mechanism that happens to make sure the user is authenticated, so if it is broken or misused then we got the problem. So if the appl itself permits things like credential attack where the attackers have valid usernames and password it could be a problem, if the appl is built in such a way that it permits brute force or other automated attacks then it could be a problem or if ur password policy on ur appl permits weak or default or wellknown passwords which is also not good. Also the password recovery like credential recovery or forgot password process like knowledge base answers like what is mothers maiden name, so those answers can be found out and it could be an unsafe method of password and it is not safe 
      Next one is session timeout, we have public library where we read books and improving urself, when u sit on the computer there and do all ur work and then instead of logging out of computer we just close the browser tab. If someone comes and sit on same computer then it is open for them to steal that session and start to use that. So if the appl that u had been accessing dosent have proper timeouts then every user can use ur session 
    To protect against this, wherever possible we need to implement multi-factor authentication so we can prevent some of credential stuffing problem (ie) someone stolen ur credentials and get reused. Next implement password checks on ur appl so test for new passwords or change passwords and not allow user to enter previous passwords. We can align ur password length, complexity and rotation policy against strong passwords. We can use server side secure built-in session managers that generate a new random session id after login and session id also should not be in url and we need to invalidate after logout 

8. Software and data integrity failures
        This is a new category for 2021 list and it focuses on making assumptions related to software updates, critical data, CICD pipelines without verifying the integrity of that software
       For example where an appl relies on like plugins or libraries or some untrusted sources or repositories or an insecure CICD pipeline which introduce the potential for unauthorized access and malicious code those kinds of things which is not good
     Now lot of appl include auto update functionality and these updates are downloaded without sufficient integrity verification, so if we are downloading something without checking the integrity of that download then thats a problem and attackers could come in and could potentially upload their own updates and then those could be distributed and run on all different installation so that is not good 
     Consider we have home router which gives different wireless access, the router itself has firmware on it, so the router does not verify updates via signed firmware, so unsigned firmware could be a problem where attackers could come in and manipulate this firmware. We have IOT devices whether it is TV or refrigerator which are connected to internet and lot of these devices just dont update their software via verified sources
       Consider we have monitoring software which is installed on variety of different endpoints, and that monitoring software is not updated and all organization in different endpoints is downloading the software from source, and attackers were able to get into different endpoints organization through this monitoring software 
      In order to prevent this, use digital signatures or similar kind of mechanisms to verify the software or the data that we have from the expected source. We have to make sure libraries or dependencies are consuming from trusted repositories. Also we should have review process for code and configuration changes within ur organization, make sure ur CI CD pipeline has proper configuration and access control built-in to ensure the integrity of the code 

9. Security logging and Monitoring failures
        This came up from 10th position in 2017 list 
     Consider we have an appl which perform many processing and we have users that are accessing ur appl and we need to do some logging on this, so do we do sufficent logging and do we monitor the logs. If we have auditable events like fail logins or high value transactions, if those are not logged then it is a problem 
     If logs are only stored locally and there is no backup, there should be appropriate alerting thresholds and response escalation process and if those are not then it is problem 
     Consider we have health plan provider and their website is attacked and patient datas are out, but the website operator couldnt detect that because thresholds are not in place or warnings or alerts are not in place, they didnt log in and they didnt monitor it. Maybe an external 3rd party to inform this health plan provider that an attacker had already accessed and modified these sensitive health records of patients 
     Lets say that you are an airline and we have data lost that involves 10 yrs worth personal data like millions of passengers passport number, credit card number etc, then we realize that the problem occured at 3rd part cloud hosting provider that we use and they are actually notified you about the  data lost, so that could be a problem if we got some 3rd party hosting provider that u r relying on and they dont do sufficient logging and  monitoring 
      In order to prevent this, we can ensure that all ur login and access control, server side input validation failures can be logged, and also we make sure that there are enough context in the logs to identify suspicious activity. We can hold the logs for long enough for forensic analysis, also ensure ur log data is encoded correctly to prevent things like injections or attacks on logging and monitoring systems, there was a recent attack on log4j which was an attack on the logging and monitoring system. Also adopt an incident response plan or recovery plan so if and when you are attacked and we need to plan to recover from that problems

10. Server side Request Forgery(SSRF)
         This is a new category added in 2021 list. This occurs when a web appl fetches a remote resource without validating a user supplied url, so it effectively allows an attacker to force the appl to send request to an unexpected destination, even when that destination is protected by firewall or vpn 
     Consider there is an shopping appl and we have users to access ur appl, one of feature of the shopping appl is allow the user to check and see if an item is in stock by sending a query to backend rest api, then api endpoint returns and then the appl returns to the user. In typical scenario what could happen is the user sends http POST request, the appl sends stock api call to restful api endpoint and then it sends back the information
     In server side request forgery, we take appl server and forge a request to an unexpected endpoint and we are going to get back information that u should not have been able to get back. So attacker can modify all this url like /admin  and request the url on server as /admin and the appl server is going to fetch the contents of /admin url and return back to attackers 
     So the attacker is going to forge the request and use the server to access the url, because the server is a known trusted place, so the contents of url from the server request are going to return to the attacker 
     To prevent this, we have some network layer where we can segment out ur remote resource functionality in separate networks and then that reduces the impact of SSRF. We can also enforce a deny by default firewall policy at network level. Next is log all ur accepted and blocked network flows on the firewall 
