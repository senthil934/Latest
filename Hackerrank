1.	Simple Cipher
A simple cipher is built on the alphabet wheel which has uppercase English letters ['A'-'Z'] written on it:
 
Given an encrypted string consisting of English letters ['A'-'Z'] only, decrypt the string by replacing each character with the kth character away on the wheel in the counter-clockwise direction.  Counter-clockwise is the opposite direction in which the hands on a clock usually move.
 
Example
encrypted = 'VTAOG'
k = 2
Looking back 2 from 'V' returns 'T', from 'T' returns 'R' and so on. The decrypted string is 'TRYME'.
 
Function Description
Complete the function simpleCipher in the editor below.
 
simpleCipher has the following parameter(s):
    encrypted: a string
    k: an integer
 
Returns
    string: the decrypted string
 
Constraints
•	1 ≤ |encrypted| ≤ 105
•	1 ≤ k ≤ 105
•	encrypted[i] ∈ ascii['A'-'Z']
 
Input Format For Custom Testing
Sample Case 0
Sample Input
STDIN     Function
-----     -----
CDEF   →  encrypted = 'CDEF'
2      →  k = 2
 
Sample Output
ABCD
 
Explanation
Each character is replaced by the character k = 2 positions away in the counter-clockwise direction. 'C' → 'A', 'D' → 'B', and so on. The decrypted string is 'ABCD'.
Sample Case 1
Sample Input
STDIN     Function
-----     -----
DGEO   →  encrypted = 'DGEO'
3      →  k = 3
 
Sample Output
ADBL
 
Explanation
Each character is replaced by the character k = 3 positions away in the counter-clockwise direction. 'D' → 'A', 'G' → 'D', and so on. The decrypted string is 'ADBL'.

class Result {

    /*
     * Complete the 'simpleCipher' function below.
     *
     * The function is expected to return a STRING.
     * The function accepts following parameters:
     *  1. STRING encrypted
     *  2. INTEGER k
     */

    public static String simpleCipher(String encrypted, int k) {
        StringBuilder decrypted= new StringBuilder();
        int effectiveShit=k%26;
        
        for(char c: encrypted.toCharArray()){
            int originalPosition=c-'A';
            int newPosition=(originalPosition- effectiveShit+ 26) %26;
            char newChar=(char) ('A'+newPosition);
            decrypted.append(newChar);
        }
        return decrypted.toString();

    }

}
public class Solution {
    public static void main(String[] args) throws IOException {
        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter bufferedWriter = new BufferedWriter(new FileWriter(System.getenv("OUTPUT_PATH")));

        String encrypted = bufferedReader.readLine();

        int k = Integer.parseInt(bufferedReader.readLine().trim());

        String result = Result.simpleCipher(encrypted, k);

        bufferedWriter.write(result);
        bufferedWriter.newLine();

        bufferedReader.close();
        bufferedWriter.close();
    }
}



2.	Two Strings
Given two arrays of strings, determine whether corresponding elements contain a common substring.
 
Example
a = ['ab','cd','ef']
b = ['af', 'ee', 'ef']
 
Make the following decisions:
i a[i] 	b[i] 	Common 	Result
0 ab 	af 	a 	YES
1 cd 	ee 		NO
2 ef 	ef 	ef 	YES
 
For each test, print the result on a new line, either YES if there is a common substring, or NO.
 
Function Description 
Complete the function commonSubstring in the editor below. For each a[i], b[i] pair, the function must print YES if they share a common substring, or NO on a new line.
 
commonSubstring has the following parameter(s):
    string a[n]:  an array of strings
    string b[n]:  an array of strings
 
Return
    void: output should be printed to stdout (console.log() in javascript) rather than returned
 
Constraints
•	All the strings consist of lowercase English letters only, ascii[a-z].
•	|a| = |b|
•	1 ≤ |a|, |b| ≤ 103
•	1 ≤ |a[i]|, |b[i]| ≤ 104
 
Input Format for Custom Testing
Sample Case 0
Sample Input 1
STDIN      Function
-----      --------
2      →   a[] size n = 2
hello  →   a = ['hello', 'hi']
hi
2      →   b[] size n = 2
world  →   b = ['world', 'bye']
bye
 
Sample Output 1
YES
NO
 
Explanation 1
i a[i] 	b[i] 	Common 	Output
0 hello world 	o, l 	YES
1 hi 	bye 		NO
There are two common substrings of (a[0], b[0]): 'o' and 'l'.
 
class Result {

    /*
     * Complete the 'commonSubstring' function below.
     *
     * The function accepts following parameters:
     *  1. STRING_ARRAY a
     *  2. STRING_ARRAY b
     */

    public static void commonSubstring(List<String> a, List<String> b) {
    for(int i=0;i<a.size();i++){
        String strA=a.get(i);
        String strB=b.get(i);
        Set<Character> setA=new HashSet<>();
        Set<Character> setB=new HashSet<>();
        for(char c: strA.toCharArray()){
            setA.add(c);
        }
        for(char c:strB.toCharArray()){
            setB.add(c);
        }
        if(!Collections.disjoint(setA, setB)){
           System.out.println("YES"); 
        }else{
            System.out.println("NO");
        }
    }

    }
}
public class Solution {
    public static void main(String[] args) throws IOException {
        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));

        int aCount = Integer.parseInt(bufferedReader.readLine().trim());

        List<String> a = new ArrayList<>();

        for (int i = 0; i < aCount; i++) {
            String aItem = bufferedReader.readLine();
            a.add(aItem);
        }

        int bCount = Integer.parseInt(bufferedReader.readLine().trim());

        List<String> b = new ArrayList<>();

        for (int i = 0; i < bCount; i++) {
            String bItem = bufferedReader.readLine();
            b.add(bItem);
        }

        Result.commonSubstring(a, b);

        bufferedReader.close();
    }
}


class Result {

    /*
     * Complete the 'commonSubstring' function below.
     *
     * The function accepts following parameters:
     *  1. STRING_ARRAY a
     *  2. STRING_ARRAY b
     */

    public static void commonSubstring(List<String> a, List<String> b) {
    // Write your code here
    
    
        for(int i=0;i<a.size();i++){
            
            String strA=a.get(i);
            String strB=b.get(i);
            
            Set<Character> set=new HashSet<>();
            for(char ch:strA.toCharArray()){
                set.add(ch);
            }
             boolean hasCommon=false;
             for( char ch:strB.toCharArray()){
                if(set.contains(ch)){
                    hasCommon=true;
                    break;
                }
             }
             if(hasCommon){
                System.out.println("YES");
             }
             else{
                System.out.println("NO");
             }
            
            
        
        }

            
        }
        }

public class Solution {
    public static void main(String[] args) throws IOException {
        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));

        int aCount = Integer.parseInt(bufferedReader.readLine().trim());

        List<String> a = new ArrayList<>();

        for (int i = 0; i < aCount; i++) {
            String aItem = bufferedReader.readLine();
            a.add(aItem);
        }

        int bCount = Integer.parseInt(bufferedReader.readLine().trim());

        List<String> b = new ArrayList<>();

        for (int i = 0; i < bCount; i++) {
            String bItem = bufferedReader.readLine();
            b.add(bItem);
        }

        Result.commonSubstring(a, b);

        bufferedReader.close();
    }
}













3.	Balancing Parentheses 

Given a string that consists of left and right parentheses, '(' and ')', balance the parentheses by inserting parentheses as necessary. Determine the minimum number of characters that must be inserted.  
 
Example
s = '(()))'
 
Insert 1 left parenthesis at the left end of the string to get '((()))'. The string is balanced after 1 insertion.
 
s = '))(('
 
Insert 2 left parentheses at the start and 2 right parentheses at the end of the string to get '(())(())' after 4 insertions.
 
Constraints
•	1 ≤ length of s ≤ 105
Input Format For Custom Testing
Sample Case 0
Sample Input
STDIN     Function
-----     -----
()))   →  s = '()))'
 
Sample Output
2
 
Explanation
Insert a '(' 2 times at the beginning of the string to make it valid: '((()))'.
Sample Case 1
Sample Input
STDIN     Function
-----     -----
()()   →  s = '()()'
 
Sample Output
0
 
Explanation
The sequence is already valid, so no insertions are needed.


class Result {

    /*
     * Complete the 'getMin' function below.
     *
     * The function is expected to return an INTEGER.
     * The function accepts STRING s as parameter.
     */

    public static int getMin(String s) {
    int open =0, close =0;
    for(char c : s.toCharArray()){
        if(c=='(')
        {
            open ++;
        }
        else{
            if(open>0){
                open --;
            }
            else{
                close ++;
            }
        }
    }
    return open + close;

    }

}

public class Solution {
    public static void main(String[] args) throws IOException {
        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter bufferedWriter = new BufferedWriter(new FileWriter(System.getenv("OUTPUT_PATH")));

        String s = bufferedReader.readLine();

        int result = Result.getMin(s);

        bufferedWriter.write(String.valueOf(result));
        bufferedWriter.newLine();

        bufferedReader.close();
        bufferedWriter.close();
    }
}










4.	Counting Closed Paths

Some numbers are formed with closed paths. The digits 0, 4, 6 and 9 each have 1 closed path, and 8 has 2.  None of the other numbers is formed with a closed path. Given a number, determine the total number of closed paths in all of its digits combined.
 
Example
number = 649578
The digits with closed paths are 6, 4, 9 and 8.  The total number of closed paths is 1 + 1 + 1 + 2 = 5.
 
Function Description 
Complete the function closedPaths in the editor below.
 
closedPaths has the following parameter(s):
    int number:  an integer
Returns:
    int: the number of closed paths in number
 
Constraints
•	1 ≤ number ≤ 109
Input Format For Custom Testing
Sample Case 0
Sample Input
STDIN      Function 
-----      --------- 
630     →  number = 630
 
Sample Output
2
 
Explanation
Sum the closed paths count for each digit, 6, 3 and 0. Return 1 + 0 + 1 = 2.
Sample Case 1
Sample Input
STDIN     Function 
-----     --------- 
1288   →  number = 1288
 
Sample Output
4
 
Explanation
Sum the closed paths count for each digit, 1, 2, 8, 8. Return 0 + 0 + 2 + 2 = 4.

class Result {

    /*
     * Complete the 'closedPaths' function below.
     *
     * The function is expected to return an INTEGER.
     * The function accepts INTEGER number as parameter.
     */

    public static int closedPaths(int number) {
    // Write your code here
    Map<Integer, Integer>closedPathsMap = new HashMap<>();
    closedPathsMap.put(0,1);
    closedPathsMap.put(4, 1);
    closedPathsMap.put(6, 1);
    closedPathsMap.put(9, 1);
    closedPathsMap.put(8, 2);
    
    int count = 0;
    String numStr = String.valueOf(number);
    
    for(char digitchar : numStr.toCharArray()){
        int digit = Character.getNumericValue(digitchar);
        count += closedPathsMap.getOrDefault(digit,0);
    }
    return count;
    }
    public static void main(String[]args){
        int number = 638;
        int result = closedPaths(number);
        
        System.out.println(result);
    }

}
public class Solution {
    public static void main(String[] args) throws IOException {
        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter bufferedWriter = new BufferedWriter(new FileWriter(System.getenv("OUTPUT_PATH")));

        int number = Integer.parseInt(bufferedReader.readLine().trim());

        int result = Result.closedPaths(number);

        bufferedWriter.write(String.valueOf(result));
        bufferedWriter.newLine();

        bufferedReader.close();
        bufferedWriter.close();
    }
}


class Result {
    

    /*
     * Complete the 'closedPaths' function below.
     *
     * The function is expected to return an INTEGER.
     * The function accepts INTEGER number as parameter.
     */

    public static int closedPaths(int number) {
         int[] closedPathsMap = {1,0,0,0,1,0,1,0,2,1};
        int sum =0;
        while( number>0){
            int digit = number%10;
            sum += closedPathsMap[digit];
            number/=10;
            
        }
        return sum;

    }
    public static void main(String[] args){
        System.out.println(closedPaths(630));
        
    }
    

}
public class Solution {
    public static void main(String[] args) throws IOException {
        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter bufferedWriter = new BufferedWriter(new FileWriter(System.getenv("OUTPUT_PATH")));

        int number = Integer.parseInt(bufferedReader.readLine().trim());

        int result = Result.closedPaths(number);

        bufferedWriter.write(String.valueOf(result));
        bufferedWriter.newLine();

        bufferedReader.close();
        bufferedWriter.close();
    }
}









5.	Break a Palindrome 

A palindrome reads the same from left or right, mom for example. There is a palindrome which must be modified, if possible. Change exactly one character of the string to another character in the range ascii[a-z] so that the string meets the following three conditions:
•	The new string is lower alphabetically than the initial string.
•	The new string is the lowest value string alphabetically that can be created from the original palindrome after making only one change.
•	The new string is not a palindrome.
 
Return the new string, or, if it not possible to create a string meeting the criteria, return the string IMPOSSIBLE.
 
Example
palindromeStr = 'aaabbaaa'
 
•	Possible strings lower alphabetically than 'aaabbaaa' after one change are ['aaaabaaa', 'aaabaaaa'].
•	'aaaabaaa' is not a palindrome and is the lowest string that can be created from palindromeStr.
 
Function Description 
Complete the function breakPalindrome in the editor below.
 
breakPalindrome has the following parameter(s):
    string palindromeStr:  the original string
 
Returns:
    string: the resulting string, or IMPOSSIBLE if one cannot be formed
 
Constraints
•	1 ≤ length of palindromeStr ≤ 1000
•	palindromeStr is a palindrome
•	palindromeStr contains only lowercase English letters
 
Input Format For Custom Testing
Sample Case 0
Sample Input For Custom Testing
STDIN      Function 
-----      -------- 
bab    →   palindromeStr  = 'bab' 

Sample Output
aab
Explanation
 
•	Possible strings lower alphabetically than 'bab' after one change are ['aab', 'baa'].
•	'aab' is not a palindrome and is the lowest string that can be created from palindromeStr.
 
Sample Case 1
Sample Input For Custom Testing
STDIN      Function
-----      --------
aaa    →   palindromeStr  = 'aaa'

Sample Output
IMPOSSIBLE
 Explanation
 
•	There are no strings lower alphabetically than 'aaa' after one change.
•	So, it is IMPOSSIBLE to create a string lower than 'aaa'.
Sample Case 2
Sample Input For Custom Testing
STDIN      Function
-----      --------
acca   →   palindromeStr  = 'acca'

Sample Output
aaca
Explanation
 
•	Possible strings lower alphabetically than 'acca' after one change are ['abca', 'aaca', 'acba', 'acaa'].
•	'aaca' is not a palindrome and is the lowest string that can be created from palindromeStr.

class Result {

    /*
     * Complete the 'breakPalindrome' function below.
     *
     * The function is expected to return a STRING.
     * The function accepts STRING palindromeStr as parameter.
     */

    public static String breakPalindrome(String palindromeStr) {
    // Write your code here
         int n=palindromeStr.length();
         if (n==1){
            return "IMPOSSIBLE";
         }
         char[] chars=palindromeStr.toCharArray();
        
        
        boolean allA = true;
        for(char c : chars){
            if(c!='a'){
                allA=false;
                break;
            }
        }
        if(allA){
        
            return (n%2==1) ? "IMPOSSIBLE" : new String(chars);
        }
        
        
         for(int i=0;i<n/2;i++){
            if (chars[i]!='a'){
                chars[i]='a';
return new String(chars);
            }
         }
chars[n-1]='b';
return new String(chars);
              }
}

    

public class Solution {
    public static void main(String[] args) throws IOException {
        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter bufferedWriter = new BufferedWriter(new FileWriter(System.getenv("OUTPUT_PATH")));

        String palindromeStr = bufferedReader.readLine();

        String result = Result.breakPalindrome(palindromeStr);

        bufferedWriter.write(result);
        bufferedWriter.newLine();

        bufferedReader.close();
        bufferedWriter.close();
    }
}





6.	Match Outcomes

Given the initial setup of a match between two players, evaluate the match's outcome. 
 
There are two players, and there is a number sequence of size n. Players alternate turns for n rounds. Each round, a player removes the first number from the sequence and adds its value to their score. After that, if the 'removed' number is even, the remaining sequence is reversed.
Determine the difference in scores between the two players after the game.
 
More precisely, suppose first_score and second_score are the final scores of the first and second player, respectively. The goal is to calculate the value of first_score - second_score.
 
Example
 
The number of elements is n = 5 and numSeq = [3, 6, 2, 3, 5].
•	1st round:  The first player picks 3, first_score = 3. The remaining sequence: [6, 2, 3, 5].
•	2nd round: The second player picks 6, second_score = 6. Since 6 is even, the remaining sequence is reversed: [5, 3, 2].
•	3rd round:  The first player picks 5, first_score = 3 + 5 = 8. The remaining sequence: [3, 2].
•	4th round:  Second player picks 3, second_score = 6 + 3 = 9. The remaining sequence: [2].
•	5th round (final): First player picks 2, second_score = 8 + 2 = 10. The remaining sequence: [].
 
The total difference between players' scores is first_score - second_score = 10 - 9 = 1.
 
Function Description 
Complete the function getScoreDifference in the editor.
 
getScoreDifference has the following parameter:
    numSeq: the given array of integers
 
Returns
    int: first_score - second_score
 
Constraints
•	1 ≤ n ≤ 105
•	1 ≤ numSeq[i] ≤ 104 for each 0 ≤ i < n
 
Input Format For Custom Testing
Sample Case 0
Sample Input For Custom Testing
STDIN         FUNCTION
-----         --------
4        →    numSeq[] size n = 4
2        →    numSeq = [2, 1, 4, 3]
1
4
3
Sample Output
2
Explanation
The game proceeds as follows:
•	1st round:  First player picks 2, first_score = 2. The remaining sequence is reversed (since 2 is even): [3, 4, 1].
•	2nd round:  Second player picks 3, second_score = 3. The remaining sequence: [4, 1].
•	3rd round:  First player picks 4, first_score = 2 + 4 = 6. The remaining sequence: [1].
•	4th round (final):  Second player picks 1, second_score = 3 + 1 = 4. The remaining sequence: [].
The difference between players' scores is 6 - 4 = 2.
Sample Case 1
Sample Input For Custom Testing
STDIN         FUNCTION
-----         --------
2        →    numSeq[] size n = 4
2        →    numSeq = [2, 2]
2
Sample Output
0
Explanation
 
Both the players pick identical elements.

class Result {

    /*
     * Complete the 'getScoreDifference' function below.
     *
     * The function is expected to return an INTEGER.
     * The function accepts INTEGER_ARRAY numSeq as parameter.
     */

    public static int getScoreDifference(List<Integer> numSeq) {
int n = numSeq.size();
        int[] arr = new int[n];

        // Convert List to Array
        for (int i = 0; i < n; i++) {
            arr[i] = numSeq.get(i);
        }

        int start = 0, end = n - 1;
        boolean reversed = false;
        boolean firstPlayerTurn = true;
        int firstScore = 0, secondScore = 0;

        while (start <= end) {
            int value;

            if (!reversed) {
                value = arr[start++];
            } else {
                value = arr[end--];
            }

            if (firstPlayerTurn) {
                firstScore += value;
            } else {
                secondScore += value;
            }

            if (value % 2 == 0) {
                reversed = !reversed;
            }

            firstPlayerTurn = !firstPlayerTurn;
        }

        return firstScore - secondScore;
    }

}

public class Solution {
    public static void main(String[] args) throws IOException {
        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter bufferedWriter = new BufferedWriter(new FileWriter(System.getenv("OUTPUT_PATH")));

        int numSeqCount = Integer.parseInt(bufferedReader.readLine().trim());

        List<Integer> numSeq = new ArrayList<>();

        for (int i = 0; i < numSeqCount; i++) {
            int numSeqItem = Integer.parseInt(bufferedReader.readLine().trim());
            numSeq.add(numSeqItem);
        }

        int result = Result.getScoreDifference(numSeq);

        bufferedWriter.write(String.valueOf(result));
        bufferedWriter.newLine();

        bufferedReader.close();
        bufferedWriter.close();
    }
}







7.	Piles Of Boxes

Alex has n piles of boxes with different heights. In each step, Alex can remove any number of boxes from the tallest pile to make its height equal to the next tallest pile. Determine the minimum number of steps needed to make all the piles the same height.
 
Example
n = 3
boxesInPiles = [ 5, 2, 1 ] 
 
 
In the first step, remove 3 boxes from boxesInPiles[0], and the new array is boxesInPiles' = [2, 2, 1].  Now reduce the two taller piles by 1 box each to match the height of the shortest pile.  This takes 2 steps because each step is performed on only one pile.  The number of steps required is 3.
 
Function Description 
 
Complete the function pilesOfBoxes in the editor with the following parameter(s):
     int boxesInPiles[n]: each boxesInPiles[i] represents the initial height of one pile
 Return
    long: the minimum number of steps required
 
Constraints
•	1 ≤ n ≤ 2 x 105
•	1 ≤ boxesInPiles[i] ≤ 2 x 106
 
Input Format Format for Custom Testing
Sample Case 0
Sample Input
STDIN    Function
-----    --------
5    →   boxesInPiles[] size n = 5
4    →   boxesInPiles = [4, 5, 5, 2, 4]
5
5
2
4
Sample Output
6
Explanation
 
 
1. 2 steps required to convert 2 piles of height 5 to 4. So, now we have 4 piles of height 4.
2. 4 steps are required to convert 4 piles of height 4 to 2.
The total number of steps required is 2 + 4 = 6 steps.
Sample Case 1
Sample Input
STDIN    Function
-----    --------
2    →   boxesInPiles[] size n = 2
886  →   boxesInPiles = [886, 777]
777 
Sample Output
1
Explanation
In 1 step, 109 boxes can be removed from the first pile to make both piles have a height of 886 - 109 = 777.

def pilesOfBoxes(arr):
    # Write your code here
    # analyze values from highest to lowest
    arr.sort(reverse = True)
    # get frequencies of elements
    bc = dict()
    for h in arr:
        if h in bc:
            bc[h] += 1
        else:
            bc[h] = 1
    # and initialize a "visited" dictionary
    done = dict()
    for h in bc:
        done[h] = 0
    # initialize current value, set it to visited
    cur = arr[0]
    done[cur] = 1
    ans = 0
    for i in range(1, len(arr)):
        # if not visited
        if not done[arr[i]]:
            # mark as visited
            done[arr[i]] = 1
            # add the current count of columns
            ans += bc[cur]
            # add number of columns so far to next value
            bc[arr[i]] += bc[cur]
            # and set current to the next value
            cur = arr[i]
    return anS

class Result {

    /*
     * Complete the 'pilesOfBoxes' function below.
     *
     * The function is expected to return a LONG_INTEGER.
     * The function accepts INTEGER_ARRAY boxesInPiles as parameter.
     */

    public static long pilesOfBoxes(List<Integer> boxesInPiles) {
        // Write your code here
        Collections.sort(boxesInPiles, Collections.reverseOrder());
        long steps = 0;

        for (int i = 1; i < boxesInPiles.size(); i++) {
            if (boxesInPiles.get(i) < boxesInPiles.get(i - 1)) {
                steps += i;
            }
        }

        return steps;
    }

}

public class Solution {
    public static void main(String[] args) throws IOException {
        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter bufferedWriter = new BufferedWriter(new FileWriter(System.getenv("OUTPUT_PATH")));

        int boxesInPilesCount = Integer.parseInt(bufferedReader.readLine().trim());

        List<Integer> boxesInPiles = IntStream.range(0, boxesInPilesCount).mapToObj(i -> {
            try {
                return bufferedReader.readLine().replaceAll("\\s+$", "");
            } catch (IOException ex) {
                throw new RuntimeException(ex);
            }
        })
            .map(String::trim)
            .map(Integer::parseInt)
            .collect(toList());

        long result = Result.pilesOfBoxes(boxesInPiles);

        bufferedWriter.write(String.valueOf(result));
        bufferedWriter.newLine();

        bufferedReader.close();
        bufferedWriter.close();
    }
}









8.	Game Winner

Two players are playing a game where white or black pieces are represented by a string, colors. The game rules are as follows:
•	Wendy moves first and then they take alternate turns.
•	With each move, Wendy may remove a white piece that has adjacent white pieces on both sides.
•	Likewise, with each move, Bob may remove any black piece that has adjacent black pieces on both sides.
•	After a piece is removed, the string is reduced in size by one piece. For instance, removing 'Y' from 'XYZ' results in 'XZ'.
•	When a player can no longer move, they have lost the game.
 
Example
colors = 'wwwbbbbwww'
 
Wendy removes the piece w at index 1, colors = 'wwbbbbwww'
Bob removes the piece b at index 3, colors = 'wwbbbwww'
Wendy removes the piece w at index 6, colors = 'wwbbbww'
Bob removes the piece b from index 3, colors = 'wwbbww'
Wendy has no other move, so Bob wins. Return 'bob'.
 
Determine who wins if Wendy and Bob both play with optimum skill. Return the string 'wendy' or 'bob'.
 
Function Description 
Complete the function gameWinner in the editor below.
 
gameWinner has the following parameter(s):
    string colors: each colors[i] represents the color located at the index of i within the string
 
Returns;
    string: the winner of the game, either 'wendy' or 'bob'.
   
Constraints
•	colors[i] is either 'w' or 'b'
•	1 ≤ size of colors ≤ 106
 
Input Format Format for Custom Testing
Sample Case 0
Sample Input
STDIN     Function 
-----     ----- 
wwwbb  →  colors = 'wwwbb'
 
Sample Output
wendy
 
Explanation
 
There are five colors in the string. Wendy can remove any of the white pieces in the first move. After that, the colors string becomes 'wwbb'. Bob has no move since there is no black piece with exactly two black adjacent pieces, so Wendy wins.

class Result {

    /*
     * Complete the 'gameWinner' function below.
     *
     * The function is expected to return a STRING.
     * The function accepts STRING colors as parameter.
     */

    public static String gameWinner(String colors) {
         int wendyMoves = 0, bobMoves = 0;
   // Count occurrences of 'www' and 'bbb'
        for (int i = 1; i < colors.length() - 1; i++) {
            if (colors.charAt(i - 1) == 'w' && colors.charAt(i) == 'w' && colors.charAt(i + 1) == 'w') {
                wendyMoves++;
            }
            if (colors.charAt(i - 1) == 'b' && colors.charAt(i) == 'b' && colors.charAt(i + 1) == 'b') {
                bobMoves++;
            }
        }

        // Wendy moves first, so if she has more moves, she wins
        return (wendyMoves > bobMoves) ? "wendy" : "bob";
    
    
    
                

    }

}

public class Solution { 
    public static void main(String[] args) throws IOException {
        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter bufferedWriter = new BufferedWriter(new FileWriter(System.getenv("OUTPUT_PATH")));

        String colors = bufferedReader.readLine();

        String result = Result.gameWinner(colors);

        bufferedWriter.write(result);
        bufferedWriter.newLine();

        bufferedReader.close();
        bufferedWriter.close();
    }
}


 public static String gameWinner(String colors) {
    // Write your code here
        if(colors.length() < 3) return "bob";
        
        int wendy = 0, bob = 0;
        for(int i = 0; i < colors.length() - 2; i++){
            String s = colors.substring(i, i + 3);
            if(s.equals("www")) wendy++;
            
            if(s.equals("bbb")) bob++;
            
        }
        return wendy > bob ? "wendy" : "bob";

    }

}

9.	Backspace String Compare 

Two strings are said to be the same if they are of the same length and have the same character at each index. Backspacing in a string removes the previous character in the string.
 
Given two strings containing lowercase English letters and the character '#' which represents a backspace key, determine if the two final strings are equal. Return 1 if they are equal or 0 if they are not. Note that backspacing an empty string results in an empty string.
 
Example
s1 = 'axx#bb#c' 
s2 = 'axbd#c#c'
 
In the first string, one 'x' and one 'b' are backspaced over. The first string becomes axbc. The second string also becomes axbc. The answer is 1.
 
Function Description
Complete the function compareStrings in the editor below.
 
compareStrings has the following parameter(s):
    string s1: the first string
    string s2: the second string
 
Returns
    int: either 0 or 1
 
 
Constraints
•	1 ≤  length of s1 ≤ 2*105
•	1 ≤  length of s2 ≤ 2*105
•	Both s1 and s2 contain lowercase English letters and/or the character '#' only.
 
Input Format For Custom Testing
Sample Case 0
Sample Input For Custom Testing
yf#c#
yy#k#pp##
Sample Output
1
Explanation
Both the strings s1 and s2 result in "y" after processing backspaces.
Sample Case 1
Sample Input For Custom Testing
hacc#kk#
hb##ackk##
Sample Output
0
Explanation
The first string becomes "hack" while the second string becomes "ac".


class Result {
    public static int compareStrings(String s1, String s2) {
        String processedS1=processString(s1);
        String processedS2=processString(s2);
        return processedS1.equals(processedS2) ? 1 : 0;
    // Write your code here

    }
    private static String processString(String str)
    {
        Stack<Character>stack=new Stack<>();
        for(char ch:str.toCharArray()){
            if(ch=='#'){
                if(!stack.isEmpty()){
                    stack.pop();
                }
            }else{
                stack.push(ch);
            }
        }
        StringBuilder result=new StringBuilder();
        for(char ch:stack){
            result.append(ch);
        }
        return result.toString();
    }

}
public class Solution {
    public static void main(String[] args) throws IOException {
        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter bufferedWriter = new BufferedWriter(new FileWriter(System.getenv("OUTPUT_PATH")));

        String s1 = bufferedReader.readLine();

        String s2 = bufferedReader.readLine();

        int result = Result.compareStrings(s1, s2);

        bufferedWriter.write(String.valueOf(result));
        bufferedWriter.newLine();

        bufferedReader.close();
        bufferedWriter.close();
    }
}















10.	Closest Numbers
Given an array of distinct integers, determine the minimum absolute difference between any two elements. Print all pairs of elements with that difference, ensuring the smaller number appears first in each pair, and the pairs are sorted in ascending order.
 
Example
numbers = [6,2,4,10]
The minimum absolute difference is 2 and the pairs with that difference are (2,4) and (4,6).
2 4
4 6
 
Function Description 
Complete the function closestNumbers in the editor.
 
closestNumbers has the following parameter(s):
    int numbers[n]:  an array of integers
 
Returns 
    NONE
Prints 
    distinct element pairs that share the minimum absolute difference, displayed in ascending order with each pair separated by one space on a single line
    
Constraints
•	2 ≤ n ≤ 105
•	-109 ≤ numbers[i] ≤ 109
 
Input Format for Custom Testing
Sample Case 0
Sample Input 0
STDIN      Function
-----      --------
4         →   numbers[] size n = 4
4         →   numbers = [4, 2, 1, 3]
2            
1            
3            
 
Sample Output 0
1 2
2 3
3 4
 
Explanation 0
The minimum absolute difference between any two elements in the array is 1, and there are three such pairs with this difference: (1, 2), (2, 3), and (3, 4).
 
Sample Case 1
Interviewer Guidelines
New
Private
Hint 1
Do we really need to check all the pairs to get the minimum difference?
Hint 2
Sort the array.
Solution
Concepts covered: 
Sorting, Arrays
 
Optimal Solution: 
First sort the array and check all the consecutive pairs of elements to find the minimum difference, diff. Then check each consecutive pair and print them if their difference is equal to diff.
 
The time complexity is O(NlogN), where N is total number of elements in the input array.
 
def closestNumbers(numbers):
    N = len(numbers)
    if N == 1:
        return;
    
    numbers.sort()
    diff = numbers[1] - numbers[0]
    
    for i in range(1,N):
        diff = min(diff, numbers[i] - numbers[i-1])
        
    for i in range(1,N):
        if numbers[i] - numbers[i-1] == diff:
            print (numbers[i-1], numbers[i])
 
Brute Force Approach: 
Compare each pair of elements in the given array to find the minimum difference. Then compare each pair again, printing those whose difference is equal to the minimum difference.
The time complexity of this approach is O(N2), where N is total number of elements in the input array.
 
Error Handling: 
1. Make sure to sort the input array.
2. Handle the case when array size is 1 separately.
Complexity Analysis
Time Complexity - O(NlogN).
Since we are sorting the array, the time complexity is O(NlogN), where N is the total number of elements in the input array.
Space Complexity - O(1).
No extra space is required.
 

class Result {

    public static void closestNumbers(List<Integer> numbers) {
        Collections.sort(numbers);
        
        // Initialize the minimum difference as a large value
        int minDiff = Integer.MAX_VALUE;

        // Calculate the minimum absolute difference
        for (int i = 1; i < numbers.size(); i++) {
            int diff = numbers.get(i) - numbers.get(i - 1);
            minDiff = Math.min(minDiff, diff);
        }

        // Print all pairs with the minimum absolute difference
        for (int i = 1; i < numbers.size(); i++) {
            if (numbers.get(i) - numbers.get(i - 1) == minDiff) {
                System.out.println(numbers.get(i - 1) + " " + numbers.get(i));
            }
        }
    }

}
public class Solution {
    public static void main(String[] args) throws IOException {
        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));

        int numbersCount = Integer.parseInt(bufferedReader.readLine().trim());

        List<Integer> numbers = IntStream.range(0, numbersCount).mapToObj(i -> {
            try {
                return bufferedReader.readLine().replaceAll("\\s+$", "");
            } catch (IOException ex) {
                throw new RuntimeException(ex);
            }
        })
            .map(String::trim)
            .map(Integer::parseInt)
            .collect(toList());

        Result.closestNumbers(numbers);

        bufferedReader.close();
    }
}







11.	Prime String
Given a string of length n containing digits [0-9], count the number of ways to split the string into prime numbers. The digits must stay in the given order, and the entire string must be used. Each resulting number must be within the range 2 to 106 inclusive and must not have leading zeros. Since the result can be large, return the count modulo (109 + 7).
 
Note: The initial string has no leading zeros.
 
Example
s = "11375"
This string can be split into primes 3 different ways: [11, 37, 5], [11,3, 7, 5], [113, 7, 5].
 
Function Description
Complete the function countPrimeStrings in the editor below.
 
countPrimeStrings has the following parameter(s):
    string s:  a string of digits
Return
    int: the number of ways the string can be split into primes, modulo 1000000007, (109+7)
 
Constraints
•	1 ≤ length of s ≤ 105
 
Input Format For Custom Testin
Sample Case 0
Sample Input For Custom Testing
STDIN     Function 
-----     -------- 
3175    → s = "3175"
Sample Output
3
Explanation
The 3 ways to split this string into prime numbers are [31, 7, 5], [3, 17, 5], [317, 5]. 3 modulo (109 + 7) = 3
Sample Case 1
Interviewer Guidelines
New
Private
Python 3 Solution
def countPrimeStrings(s): 
    MOD = 10**9 + 7 
    MAX = 10**6 
    L = len(s) 
    prime = [True for _ in range(MAX + 3)] 
    prime[0] = prime[1] = False 
    i = 2 
    while i * i <= MAX: 
        if prime[i]: 
            for j in range(i * i, MAX + 1, i): 
                prime[j] = False 
        i += 1 
    dp = [0 for _ in range(L + 1)] 
    dp[0] = 1 
    for l in range(1, L + 1): 
        for j in range(l - 1, max(-1, l - 7), -1): 
            num = int(s[j:l]) 
            if num > 10 ** 6: 
                break 
            if s[j] == '0': 
                continue 
            if prime[num]: 
                dp[l] = (dp[l] + dp[j]) % MOD 
    return dp[-1]
 















12.	Question - Merging Palindromes
Given two strings, identify all palindromes that can be formed from each string's letters. Select one palindrome from each set that, when combined and rearranged, creates the longest possible palindrome. If multiple palindromes of this maximum length exist, return the alphabetically smallest one.
 
Example
s1 = 'aabbc'
s2 = 'ddefefq'
 
All of the letters of the first string can make a palindrome. The choices using all letters are [abcba, bacab]. 
All of the letters of the second string can make a palindrome. The choices using all letters are [defqfed, dfeqefd, edfqfde, efdqdfe, fdeqedf, fedqdef]. 
The two longest results in s1 have a length of 5.
The six longest results in s2 have a length of 6.
From the longest results for s1 and s2, merge the two that form the lowest merged palindrome, alphabetically. In this case, choose abcba and defqfed.  The two palindromes can be combined to form a single palindrome if either the c or the q is discarded. The alphabetically smallest combined palindrome is abdefcfedba.
 
Function Description
Complete the function mergePalindromes in the editor below. The function must return a string.
 
mergePalindromes has the following parameter(s):
    string s1:  a string
    string s2:  a string
 
Constraints
•	1 ≤ | s1 | ≤ 105
•	1 ≤ | s2 | ≤ 105
•	s1 and s2 contain only lowercase English letters in the range ascii[a-z].
 
Input Format For Custom Testing


Sample Case 0
Sample Input For Custom Testing
STDIN    Function
-----    --------
aab    → s1 = 'aab'
cca    → s2 = 'cca'
Sample Output
acaca
Explanation
Characters ['a', 'a'] can be picked from the first string to form the palindrome 'aa'. Characters ['c', 'c', 'a'] can be picked from the second string to form the palindrome 'cac' and merged with 'aa' to form 'acaca'.
Sample Case 1
Interviewer Guidelines
New
Private
Python 3 Solution
def mergePalindromes(s1, s2):
    a = s1 
    b = s2 
    count_a =[0]*26 
    count_b=[0]*26 

    # count sort the string characters
    for ch in a: 
        count_a[ord(ch)-ord('a')]+=1 
    for ch in b: 
        count_b[ord(ch)-ord('a')]+=1 

    mid='' 
    res='' 
    # build res from a to z
    for i in range(26): 
        curr = chr(i+ord('a')) 
        # odd count in both strings
        if count_a[i]%2==1 and count_b[i]%2==1 and len(mid)<2: 
            mid=curr*2 
        # odd count in one string
        if (count_a[i]%2==1 or count_b[i]%2==1) and mid=='': 
            mid=curr 
        res+=(curr*(count_a[i]//2+count_b[i]//2))

    # add two instances of the middle character (even occurrences) 
    if len(mid) == 2: 
        res=''.join(sorted(res+mid[0] )) 
        return res+res[::-1] 

    # or add one instance of the middle character (odd occurrences)
    return res+mid+res[::-1]
 




13.Question - Vowel Substring
Given a string composed of lowercase letters within the ASCII range 'a'-'z', determine the number of substrings that consist solely of vowels, where each vowel appears at least once. The vowels are ['a', 'e', 'i', 'o', 'u']. A substring is defined as a contiguous sequence of characters within the string.
 
Example
s = 'aeioaexaaeuiou'
 
There is a substring to the left that is made of vowels, 'aeioae' which is followed by an 'x'. Since 'x' is not a vowel, it cannot be included in the substring, and this substring does not contain all of the vowels. It is not a qualifying substring. Moving to the right, there are four substrings that do qualify: 'aaeuiou', 'aaeuio', 'aeuiou' and 'aeuio'.
 
Function Description
Complete the function vowelSubstring in the editor with the following parameter(s):
    string s:  a string
 
Returns
    int: the number of substrings that consist of vowels only ('a', 'e,' i', 'o', 'u')  where every vowel appears at least once
 
Constraints
•	1 ≤ size_of(s) ≤ 105
•	s[i] is in the range ascii['a'-'z'] (where 0 ≤ i < size_of(s) ) 
 
Input Format For Custom Testing
Sample Case 0
Sample Input For Custom Testing
STDIN         Function
-----         --------
aaeiouxa  →   s = "aaeiouxa"
Sample Output
2
Explanation
s = "aaeiouxa"
 
There are two qualifying substrings: 
s[0:5] = "aaeiou"
s[1:5] = "aeiou"
Sample Case 1
Sample Input For Custom Testing
STDIN         Function
-----         --------
axyzaeiou →   s = "axyzaeiou"
Sample Output
1
Explanation
s = "axyzaeiou"
There is only one qualifying substring:
s[4:8] = "aeiou"

class Result {

    public static long vowelsubstring(String s) {
         Set<Character> vowels = new HashSet<>(Arrays.asList('a', 'e', 'i', 'o', 'u'));
        int n = s.length();
        int count = 0;

        // Start iterating through the string
        for (int i = 0; i < n; i++) {
            // If the character is a vowel, begin forming a substring
            if (vowels.contains(s.charAt(i))) {
                // Set to store vowels we encounter in the current substring
                Set<Character> foundVowels = new HashSet<>();
                
                // Iterate over the substring starting from 'i'
                for (int j = i; j < n; j++) {
                    // If we encounter a vowel, add it to the set
                    if (vowels.contains(s.charAt(j))) {
                        foundVowels.add(s.charAt(j));
                    } else {
                        // If we encounter a non-vowel character, break out of the loop
                        break;
                    }
                    
                    // If we have found all vowels at least once
                    if (foundVowels.size() == 5) {
                        count++;
                    }
                }
            }
        }

        return count;
    }
}

public class Solution {

    public static void main(String[] args) {
        // Reading input
        Scanner sc = new Scanner(System.in);
        String s = sc.nextLine().trim();
        
        // Get the result
        long result = Result.vowelsubstring(s);
        
        // Output the result
        System.out.println(result);
    }
}






13.Question - Analyzing Arrays
Consider a 1-based array of n integers, arr[n]. For each element arr[i] where 1 ≤ i < n, determine the value of arr[i]arr[i+1] modulo (109 + 7). Return the lowest index of the highest modulo value.
 
Example
arr = [3, 5, 4, 5, 2, 10]
 
index i	arr[i]arr[i+1] modulo (109 + 7)	result
1	35 modulo (109 + 7)	243
2	54 modulo (109 + 7)	625
3	45 modulo (109 + 7)	1024
4	52 modulo (109 + 7)	25
5	210 modulo (109 + 7)	1024
 
The greatest of these values is 1024 occurring at indices 3 and 5. Return the smaller index, 3.
 
Function Description
Complete the function powerArray in the editor.
 
powerArray has the following parameter:
    int arr[n]:  the integers to analyze
 
Returns:
    int: the smallest index element that results in the highest value
 
Constraints
•	1 ≤ n ≤ 105
•	1 ≤ arr[i] ≤ 100
 
Input Format For Custom Testing
Sample Case 0
Sample Input For Custom Testing
STDIN     Function
-----     --------
3     →   arr[] size n = 3
1     →   arr = [1, 2, 3]
2
3
Sample Output
2
Explanation
 
12 modulo 1000000007 = 1
23 modulo 1000000007 = 8
Sample Case 1
Interviewer Guidelines
New
Private
Hint 1
Make use of the constraints on the elements of the input array.
Hint 2
For each number in [1, 100], pre-compute its power up to 100, modulo 109+7 and store it in a 2-D array.
Solution
Concepts covered: 
Arrays, loops, modulo usage, pre-computation
 
Optimal Solution: 
Since the value of the array elements can be up to 100, we pre-compute the powers of all the numbers in the range [1, 100] up to 100 using modulo 109+7 in a two-dimensional array. Now when we process the array we can answer each power query in O(1) and keep track of the maximum value on the go.
The time complexity of the above approach is O(N), where N is the size of the input array.
def raisingPower(arr):
    mod = 1000000007
    maxVal = 0
    idx = 0
    n = len(arr)
    
    power = [[0 for x in range(101)] for y in range(101)]  
    
    for i in range(1, 101):
        power[i][0] = 1
        for j in range(1, 101):
            power[i][j] = (power[i][j-1]*i)%mod
    
    for i in range(n-1):
        if power[arr[i]][arr[i+1]] > maxVal:
            maxVal = power[arr[i]][arr[i+1]]
            idx = i
    
    return idx+1
 
Brute Force Approach: 
The straightforward approach is to calculate the power at each index i by looping up to the value at i + 1, taking modulo on the go and keeping track of the maximum value encountered.
The time complexity of this approach is O(N*Max(arri)), where N is the size of input array.
 
Error Handling: 
1. Make sure you use modulo properly to avoid integer overflow.

class Result {

	static final int MOD = 1000000007;

	// Function to find the smallest index of the highest modulo value
	public static int raisingPower(List<Integer> arr) {
		int n = arr.size();

		// Initialize variables to keep track of maximum modulo and the corresponding
		// index
		long maxModulo = 0;
		int resultIndex = 0;

		// Traverse the list and compute the modulos
		for (int i = 0; i < n - 1; i++) {
			// Compute the product of arr[i] and arr[i+1] modulo (10^9 + 7)
			long productModulo = (long) arr.get(i) * arr.get(i + 1) % MOD;

			// If we find a new max modulo, update maxModulo and resultIndex
			if (productModulo > maxModulo) {
				maxModulo = productModulo;
				resultIndex = i + 1; // 1-based index
			}
		}

		return resultIndex;
	}
}

public class Solution {

	public static void main(String[] args) throws IOException {
		// Reading input
		Scanner sc = new Scanner(System.in);
		int arrCount = Integer.parseInt(sc.nextLine().trim());

		List<Integer> arr = IntStream.range(0, arrCount).mapToObj(i -> {
			return sc.nextLine().replaceAll("\\s+$", "");
		}).map(String::trim).map(Integer::parseInt).collect(Collectors.toList());

		int result = Result.raisingPower(arr);

		// Output the result
		System.out.println(result);
	}
}













14. Question - Digit Sum
In a lottery game, tickets ranging from lowLimit to highLimit are distributed to participants. Each coupon code is equal to the sum of the digits of the ticket number. For example, coupon number 10 has a code of 1+0 = 1. Each participant holding a coupon code has a chance to win. The lottery prize is split among all winners.
 
Determine the number of ways to choose the maximum number of winners and the number of participants who will win the lottery.
 
Example
lowLimit = 1
highLimit = 10
 
•	Ticket numbers range from 1 to 10 and their corresponding coupon codes (the sum of their digits) are  [1, 2, 3, 4, 5, 6, 7, 8, 9, 1].
•	For the 8 coupon codes 2 to 9, each has 1 winner.
•	There is one way to have more winners.  For coupon code 1, there are 2 winners, ticket 1 and ticket 10 (1 + 0 = 1).
•	The answer is [1, 2]
 
Function Description
Complete the function waysToChooseSum in the editor below.
 
waysToChooseSum has the following parameter(s):
    long lowLimit: the starting number of the lottery coupons
    long highLimit: the ending number of the lottery coupons
Returns:     
    long[2]: the number of ways to choose the maximum number of winners and the number of participants who will win the lottery
 
Constraints
•	1 ≤ lowLimit < highLimit ≤ 1018
 
Input Format For Custom Testing
Sample Case 0
Sample Input For Custom Testing
STDIN    Function
-----    --------
1    →   lowLimit = 1
5    →   highLimit = 5
Sample Output
5
1
Explanation
 
•	The ticket numbers range from 1 to 5, and the corresponding coupon codes are [1, 2, 3, 4, 5].
•	For coupon codes 1 to 5, there are 5 ways to have 1 winner.
Sample Case 1
•	
•	
•	
Interviewer Guidelines
New
Private
Python 3 Solution using the Digit DP method
def waysToChooseSum(lowLimit, highLimit): 
    slow, shigh = str(lowLimit), str(highLimit) 
    
    if len(slow) < len(shigh): 
        slow = ('0' * (len(shigh) - len(slow))) + slow 
        
    n = len(shigh) 
    dp = [[[[-1] * (10 * n + 1) for i in range(2)] for j in range(2)] for k in range(n)] 
    
    def calcWinners(i, t1, t2, digitSum): 
        if digitSum < 0 or digitSum > 9 * (n - i): 
            return 0 
        if i == n: 
            return 1 if digitSum == 0 else 0 
        if dp[i][1 if t1 else 0][1 if t2 else 0][digitSum] != -1: 
            return dp[i][1 if t1 else 0][1 if t2 else 0][digitSum] 
        res = 0 
        for j in range(10): 
            if not t1 and j < int(slow[i]): 
                continue 
            if not t2 and j > int(shigh[i]): 
                continue 
            res += calcWinners(i + 1, t1 or j > int(slow[i]), t2 or j < int(shigh[i]), digitSum - j)
        dp[i][1 if t1 else 0][1 if t2 else 0][digitSum] = res 
        return res 
    
    maxWinners, numWays = 0, 0 
    
    for i in range(1 + 10 * n): 
        numWinners = calcWinners(0, False, False, i) 
        if numWinners > maxWinners: 
            maxWinners = numWinners 
            numWays = 1 
        elif numWinners == maxWinners: 
            numWays += 1 
            
    return [numWays, maxWinners]
 












15.Question - Who Is the closest?
Given a string that might have multiple occurrences of the same character, return the closest same character of any indicated character in the string. You are given the string s and n number of queries. In each query, you are given an index a (where 0 ≤ a < |s|) of a character, and you need to print the index of the closest same character. If there are multiple answers, print the smallest one, or if there is no such index print -1 instead.
 
For example, for the string s = babab, with a given query 2, there are two matching characters at indices 0 and 4, each 2 away, so we choose the lower of the two: 0. 
 
Function Description 
Complete the function closest in the editor below. The function must return an integer vector of size n that denotes the answer of each query.
 
closest has the following parameters: 
    s: the original string 
    queries: an array of n integers, where the value of each element queries[i] is an index of a character whose closest same character's index needs to be found.
 
Constraints
•	| s |, | queries | ≤ 105
•	1 ≤ n ≤ 105
•	s will contain only lowercase letters from the English alphabet, ascii[a-z]
 
Input Format For Custom Testing
Sample Case 0
Sample Input 0
hackerrank
4
4
1
6
8
Sample Output 0
-1
7
5
-1
Explanation 0
Query #0: Character at index-4 is 'e'. In this case, there is no other 'e' present in s, so we print -1.
Query #1: Character at index-1 is 'a'. In this case, there is only one closest index (index-7) that contains 'a'. 
Query #2: Character at index-6 is 'r'. In this case, there is only one closest index (index-5) that contains 'r'.
Query #3: Character at index-8 is 'n'. In this case, there is no other 'n' present in s, so we print -1.
Sample Case 1
Sample Input 1
aaaa
4
0
1
2
3
Sample Output 1
1
0
1
2
Explanation 1
Query #0: Character at index-0 is 'a'. In this case, there is only one closest index (index-1) that contains 'a'. 
Query #1: Character at index-1 is 'a'. In this case, there are two closest indexes (index-0 and index-2) that also contain 'a'. Since 0 is smaller than 2 we print 0. 
Query #2: Character at index-2 is 'a'. In this case, there are two closest indexes (index-1 and index-3) that also contain 'a'. Since 1 is smaller than 3 we print 1. 
Query #3: Character at index-3 is 'a'. In this case, there is only one closest index (index-2) that contains 'a'. 
Sample Case 2
Sample Input 2
sam
1
1
Sample Output 2
-1
Explanation 2
Query #0: Character at index-1 is 'a'. In this case, there is no other 'a' present in s so we print -1. 

class Result {

    /*
     * Complete the 'closest' function below.
     *
     * The function is expected to return an INTEGER_ARRAY.
     * The function accepts following parameters:
     *  1. STRING s
     *  2. INTEGER_ARRAY queries
     */

    public static List<Integer> closest(String s, List<Integer> queries) {
           // key = character, value = sorted list of indices where they occur
        Map<Character, List<Integer>> loc = new HashMap<>();

        // Store indices of each character in the string
        for (int i = 0; i < s.length(); i++) {
            char c = s.charAt(i);
            loc.computeIfAbsent(c, k -> new ArrayList<>()).add(i);
        }

        // List to store the closest characters for each query
        List<Integer> res = new ArrayList<>();

        // Process each query
        for (int q : queries) {
            char ch = s.charAt(q);
            List<Integer> ls = loc.get(ch);

            // Perform binary search to find the index of the query in the sorted array
            int low = 0, high = ls.size() - 1, idx = -1;
            while (high >= low) {
                int mid = (high + low) / 2 + (high + low) % 2;
                if (ls.get(mid) == q) {
                    idx = mid;
                    break;
                }
                if (ls.get(mid) < q) {
                    low = mid + 1;
                } else {
                    high = mid - 1;
                }
            }

            // Check outcomes:
            // No adjacent elements
            if (ls.size() < 2 || idx < 0) {
                res.add(-1);
            }
            // Index is at the first element
            else if (idx == 0) {
                res.add(ls.get(idx + 1));
            }
            // Index is at the last element
            else if (idx == ls.size() - 1) {
                res.add(ls.get(idx - 1));
            }
            // Index is somewhere in the middle
            else {
                if (ls.get(idx) - ls.get(idx - 1) > ls.get(idx + 1) - ls.get(idx)) {
                    res.add(ls.get(idx + 1));
                } else {
                    res.add(ls.get(idx - 1));
                }
            }
        }

        return res;
    }

}









16. Question -  Longest Even Length Word
Consider a string, sentence, of words separated by spaces where each word is a substring that consists of English alphabetic letters only. Find and return the first word in the sentence that has a length that is both an even number and has the greatest length of all even-length words in the sentence. If there are no even length words in the sentence, return '00'.
 
Example
sentence = "Time to write great code"
 
The lengths of the words are 4, 2, 5, 5, 4, in order. The longest even length words are Time and code. The one that occurs first is Time, the answer to return.
 
Function Description 
Complete the function longestEvenWord in the editor below.

longestEvenWord has the following parameter(s):
    string sentence:  a sentence string
 
Returns:
    string: the first occurrence of a string with maximal even number length, or the string '00' (zero zero) if there are no even length words
 
Constraints
•	1 ≤ length of sentence ≤ 105
•	The sentence string consists of spaces and letters in the range ascii[a-z, A-Z, ] only.
 
Input Format for Custom Testing
Sample Case 0
Sample Input 0
STDIN                                Function
--------------------------           -------------------------------
It is a pleasant day today    →      sentence = "It is a pleasant day today"

 
Sample Output 0
pleasant
 
Explanation 0
There are three even-length words: It (with length 2), is (2), and pleasant (8).
 
Sample Case 1
Sample Input 1
STDIN                                    Function
------------------------------           ------------------------------- 
You can do it the way you like    →     sentence = "You can do it the way you like"

 
Sample Output 1
like
 
Explanation 1
There are three words of even length: do (with length 2), it (2), and like (4).
 
class Result {

	public static String longestEvenWord(String sentence) {
		String[] words = sentence.split(" ");

		// Variables to keep track of the longest even length word
		String result = "00";
		int maxLength = -1;

		// Iterate over each word in the sentence
		for (String word : words) {
			// Check if the word length is even
			if (word.length() % 2 == 0) {
				// If it's the longest even length word, update the result
				if (word.length() > maxLength) {
					maxLength = word.length();
					result = word;
				}
			}
		}

		// Return the result
		return result;

	}

}

public class Solution {

	public static void main(String[] args) {
		// Reading input
		Scanner sc = new Scanner(System.in);
		String sentence = sc.nextLine();

		String result = Result.longestEvenWord(sentence);
		System.out.println(result);
	}
}





17. Question - Similar Numbers
Two numbers, without leading zeros, are similar if rearranging the digits gives matching numbers, i.e., numbers with the equal frequency of each digit. For example, the numbers 1100 and 1001 are similar, but 1100 and 0110 are not similar because 0110 has a leading zero.
 
Given two strings that represent long integers a and b, check their similarity. Based on the finding, determine one of the following:
 
•	If a and b are similar, find the total number of similar numbers to a.
•	If a and b are not similar, find the total number of similar numbers to b.
 
Example 
if a = 112 and b = 121, they are similar. Count the 3 numbers similar to a: {112, 121, 211}.
If a = 11 and b = 223, they are not similar. Count the 3 numbers similar to b: {223, 232, 322}. 
 
Function Description 
Complete the function findSimilar in the editor below.
 
findSimilar has the following parameter(s):
    string a:  a string representation of a long integer
    string b:  a string representation of a long integer
Returns:
     long int: long integer, the number of integers similar to a or b as required.
 
Constraints
•	1 ≤ numeric values of a and b ≤ 1015
•	The inputs do not contain ambiguous values. Specifically, there will be no leading zeros such as a = 002, b = 200. 
 
Input Format for Custom Testing
Sample Case 0
Sample Input 0
STDIN      Function 
-----      -------- 
1234   →   a = "1234"
2341   →   b = "2341"
 
Sample Output 0
24
 
Explanation 0
Given a = 1234 and b = 2341, they are similar (equal frequency of all digits). Count the numbers similar to a:
{1234, 1243, 1324, 1342, 1423, 1432, 2134, 2143, 2314, 2341, 2413, 2431, 3124, 3142, 3214, 3241, 3412, 3421, 4123, 4132, 4213, 4231, 4312, 4321}
The total number of similar numbers is 24.
 
Sample Case 1
Sample Input 1
STDIN    Function
-----    --------
1100 →   a = "1100" 
1001 →   b = "1001"
 
Sample Output 1
3
 
Explanation 1
Given a = 1100 and b = 1001, they are similar numbers. Count the numbers similar to a:
{1100, 1010, 1001}
The total number of similar numbers is 3.
Sample Case 2
Sample Input 2
STDIN      Function
-----      -------- 
1234   →   a = "1234"
1213   →   b = "1213"


 
Sample Output 2
12
 
Explanation 2
Given a = 1234 and b = 1213, they are not similar numbers. Count the numbers similar to b:
{1123, 1132, 1213, 1231, 1312, 1321, 2113, 2131, 2311, 3112, 3121, 3211}
The total number of similar numbers is 12.
Interviewer Guidelines
New
Private
Python 3 Solution
def findSimilar(a, b): 

    # note that if a and b are similar, permutations of a and b are the same
    # always work on b

    # count the digits of each type
    counts = [0] * 10
    for c in b:
        counts[int(c)] += 1
    
    # calculate the gross number of permutations
    ans = 1 
    for v in counts: 
        if v > 0:
            ans *= math.factorial(v) 
    ans = math.factorial(len(b)) // ans 
    
    # count the permutations that start with 0
    
    if counts[0] > 0: 
        ans2 = 1
        counts[0] -= 1 
        for v in counts:
            if v > 0:
                ans2 *= math.factorial(v) 
        ans2 = math.factorial(len(b) - 1)// ans2
    else:
        ans2 = 0
    
    ans -= ans2 
    return ans


















19. Question -  Shifting Strings
The following operations on a string are defined:
•	Left Shift: A single circular rotation of the string where the first character moves to the end and all other characters shift one position to the left. For example, abcde becomes bcdea after one left shift and cdeab after two left shifts.
•	Right Shift: A single circular rotation of the string where the last character moves to the beginning and all other characters shift one position to the right. For example, abcde becomes eabcd after one right shift and deabc after two right shifts.
 
Example
s = 'abcdefg'
leftShifts = 2
rightShifts = 4
 
The string abcdefg shifted left by 2 positions is cdefgab. The string cdefgab shifted right by 4 positions is fgabcde, the string to return.
 
Function Description 
Complete the function getShiftedString in the editor with the following parameter(s):
    string s:  the string to shift
    int leftShifts: number of shifts left
    int rightShifts:  number of shifts right
 
Returns
    string: a string shifted left or right
 
Constraints
•	1 ≤ length of s ≤ 105
•	0 ≤ leftShifts, rightShifts ≤ 109
•	String s consists of lowercase English alphabetic letters only, ascii[a-z].
 
Input Format for Custom Testing
Sample Case 0
Sample Input 0
STDIN           Function
-----           --------
abcd     →      s = "abcd"
1        →      leftShifts = 1
2        →      rightShifts = 2

 
Sample Output 0
dabc
 
Explanation 0
Initially, s is abcd.
1.	leftShifts = 1 : abcd → bcda
2.	rightShifts = 2 : bcda → abcd → dabc
The function then returns dabc.
 
Sample Case 1
Sample Input 1
STDIN           Function
-----           --------
a        →      s = "a"
0        →      leftShifts = 0
1        →      rightShifts = 1

 
Sample Output 1
a
 
Explanation 1
A one character string is unchanged regardless of the number of shifts performed.
 
Interviewer Guidelines
New
Private
Hint 1
Find out the resultant number of shifts.
Hint 2
If a string is shifted its length times in either direction, it becomes the original string. Use this information to reduce the total number of resultant shifts as much possible.
Solution
Concepts covered: 
Strings, Modulo
 
Optimal Solution: 
Observation 1: Equal number of left and right shifts cancel each other.
Observation 2: Since, a string shifted its length times in either direction becomes the original string, the actual number of shifts is resultantShifts % N, where N is the length of the string.
Observation 3: A string shifted X times towards left is same as the same string shifted N-X times towards right, where N is the length of the string.
 
So first we find the effective number of left shifts which is abs(leftShifts - rightShifts) % N if leftShifts ≥ rightShifts and N - abs(leftShifts - rightShifts) % N otherwise. Let's call this quantity shifts. Now, the answer will be a new string which will be the concatenation of s[x...N-1] and s[0...shifts-1].
The time complexity of this approach is O(N), where N is the length of the string.
def getShiftedString(s, leftShifts, rightShifts):
    n = len(s)
    shifts = (abs(leftShifts - rightShifts))%n
    if (leftShifts < rightShifts):
        shifts = n - shifts
    return s[shifts:n] + s[:shifts]
 
Brute Force Approach: 
Shift the string leftShifts number of times towards left and then shift the string rightShifts number of times towards the right. Output the final string.
The time complexity of the above approach is O(N*max(leftShifts, rightShifts)), where N is the length of the string.





20. Question -  Long Encoded String
Consider a string that consists of lowercase English letters (i.e., [a-z]) only. The following rules are used to encode all of its characters into the string s.
•	a is encoded as 1, b is encoded as 2, c is encoded as 3, …, and i is encoded as 9.
•	j is encoded as 10#, k is encoded as 11#, l is encoded as 12#, …, and z is encoded as 26#.
•	If any character occurs two or more consecutively, its count immediately follows the encoded character in parentheses, e.g. 'aa' is encoded as '1(2)'.  
 
 
Examples
 
•	String "abzx" is encoded as s = "1226#24#".
•	String "aabccc" is encoded as s = "1(2)23(3)".
•	String "bajj" is encoded as s = "2110#(2)".
•	String "wwxyzwww" is encoded as s = "23#(2)24#25#26#23#(3)".
 
Given an encoded string s, determine the character counts for each letter of the original, decoded string.  Return array of 26 integers where index 0 contains the number of 'a' characters, index 1 contains the number of 'b' characters, and so on.
 
Function Description
Complete the frequency function in the editor below. 
 
frequency has the following parameter:
    string s: an encoded string
 
Return
    int[26]: the character frequencies as described
 
Constraints
•	String s consists of decimal integers from 0 to 9, #'s, and ()'s only.
•	1 ≤ length of s ≤ 105
•	It is guaranteed that string s is a valid encoded string.
•	2 ≤ c ≤ 104, where c is a parenthetical count of consecutive occurrences of an encoded character.
 
Input Format For Custom Testing
Sample Case 0
Sample Input For Custom Testing
1226#24#
 
Sample Output 0
1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 1
 
Explanation 0
 
 
Sample Case 1
Sample Input 1
1(2)23(3)
 
Sample Output 1
2 1 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
 
Explanation 1
 
 
Sample Case 2
 
Sample Case 3
 
Interviewer Guidelines
New
Private
Solution
Skills: Loops and counters, arrays
 
The candidate should quickly understand how to best progress through the string. The primary check determines if the character value is one or two digits long. The next check is to see if the character is repeated. Note that in the solution below, the actual character values are never used.
 
Start by looking ahead 2 characters to see if there is a pound sign. If so, the code is 2 digits long, in the range [10 - 26]. If it is not a pound sign, the code is 1 digit, [0-9]. In either case, the code may be followed by a parenthesis. If there is one, read the integer up until the right parenthesis. Add this count to the appropriate element in the return array. Be sure to skip over special characters.
 
Optimal Solution: 

def frequency(s):
    n = len(s)
    i = 0
    answer = [0]*26
    while i < n:
        char = -1
        reps = 1
        # check for pound sign
        if i < n - 2 and s[i+2] == '#':
            # grab the next two characters and move ahead
            char = int(s[i:i+2])-1
            i += 3
        else:
            # grab the next one character and move ahead
            char = int(s[i])-1
            i += 1
        # check for parentheses
        if i < n and s[i] == '(':
            # skip the left parenthesis
            i += 1
            reps = 0
            # grab the integer between parens
            while i < n and s[i].isdigit():
                reps = reps * 10 + int(s[i])
                i += 1
            # skip the right parenthesis
            i += 1
        answer[char] += reps
    return answer
 21. Question - Nutrition Value
Given a list of food items arranged in a sequence, each item is assigned a value starting from 1 and increasing by 1 for each subsequent item. The value of an item represents the number of macronutrients it contains. For example, an item with a value of 1 contains 1 macronutrient, an item with a value of 2 contains 2 macronutrients, and so on. Items are chosen from left to right and a running sum is maintained.
 
Determine the highest possible total macronutrients that can be selected, ensuring that the running sum never equals the specified 'unhealthy' number k. Return the value modulo (109 + 7).
 
Example
n = 4
k = 6
 
Given n = 4 food items, their values are 1, 2, 3, and 4. Items 1, 2, and 3 have total macronutrients of 1 + 2 + 3 = 6, which matches the 'unhealthy' number k = 6. One of the three needs to be skipped. Thus, the best combination is chosen from the following list:
•	2 + 3 + 4 = 9
•	1 + 3 + 4 = 8
•	1 + 2 + 4 = 7 
 
Items 2 + 3 + 4 = 9 have the maximum number of macronutrients. Therefore, the answer is 9.
 
 
Function Description
Complete the maxNutrients function in the editor with the following parameters:
    int n: denotes the number of food items
    int k: denotes the unhealthy number
 
Returns
    int: represents the maximum total of macronutrients, modulo 1000000007 (109 + 7).
 
Constraints
•	1 ≤ n ≤ 2 × 109
•	1 ≤ k ≤ 4 × 1015
 
Input Format For Custom Testing
Sample Case 0
Sample Input
STDIN    Function
-----    ----- 
2     →  n = 2
2     →  k = 2

 
Sample Output
3
 
Explanation
The following sequence of n = 2 food items:
1.	Item 1 has 1 macronutrient.  Item 2 alone cannot be chosen because k = 2.
2.	1 + 2 = 3 provides the best outcome and avoids having exactly k = 2 macronutrients.
 
Sample Case 1
Sample Input
STDIN    Function
-----    -----
2     →  number of food items n = 2
1     →  unhealthy number k = 1
 
Sample Output
2
 
Explanation
1.	Do not choose item 1 because k = 1 and the running sum cannot equal k.
2.	The maximum total is achieved by choosing item 2.
 
Sample Case 2
Sample Input
STDIN    Function
-----    -----
3     →  number of food items n = 3
3     →  unhealthy number k = 3
 
Sample Output
5
 
Explanation
 
1.	Do not choose either 1 and 2 or 3 alone, because k = 3. 
2.	Items 1 and 3 or 2  and 3, can be combined.
2 + 3 = 5, is the better case.
Interviewer Guidelines
New
Private
There are two cases: 
1.	The running sum from 1 to n never equals k. 
2.	If the running sum ever equals k, one value has to be skipped. It is always optimal to skip the first element, 1.
We sum the integers from 1 to n.
We create a reference number to check if k can be represented as the sum of consecutive natural numbers starting from 1.
 
This works because the sum of the first m numbers is Sm = m(m+1)/2.
•	Solving Sm for m, we get m(m+1) = 2k.
•	Taking the square root approximates m, then ref * (ref + 1) is checked against 2*k.
•	If they are equal, k is an exact sum of some prefix array.

class Result {

   public static int maxNutrients(int n, long k) {
        // Modulo value
        int mod = 1000000007;

        // Calculate the reference value
        int ref = (int) Math.sqrt(2 * k);

        // Calculate the sum of the first n integers
        long res = (long) n * (n + 1) / 2;

        // Check the condition for k == 1 or ref * (ref + 1) == 2 * k
        if (k == 1 || (ref * (ref + 1)) == 2 * k) {
            return (int) ((res - 1) % mod);
        } else {
            return (int) (res % mod);
        }
    }


}




22. Question - Counting Binary Substrings
A substring is a group of contiguous characters in a string. For instance, all substrings of abc are [a, b, c, ab, bc, abc].
 
Given a binary representation of a number, determine the total number of substrings present that match the following conditions:
 
1.	The 0's and 1's are grouped consecutively (e.g., 01, 10, 0011, 1100, 000111, etc.).
2.	The number of 0's in the substring is equal to the number of 1's in the substring.
 
Example
 
s = 001101
 
The 4 substrings matching the two conditions include [0011, 01, 10, 01]. Note that 01 appears twice, from indices 1-2 and 4-5. There are other substrings, e.g. 001 and 011 that match the first condition but not the second.
 
Function Description 
Complete the function counting in the editor below.
 
counting has the following parameter(s):
    string s:  a string representation of a binary integer
 
Returns
    int:  the number of substrings of s that satisfy the two conditions
 
Constraints
•	5 ≤ |s| ≤ 5 × 105
•	each s[i] is either '0' or '1'
 
Input Format for Custom Testing
Sample Case 0
Sample Input 0
STDIN     Function Parameters 
-----     -------------------
00110  →  s = "00110"
 
Sample Output 0
3
 
Explanation 0
There are three substrings that satisfy both conditions:
1.	0011, which is a substring of the characters from s[0] to s[3].
2.	01, from s[1] to s[2].
3.	10, from s[3] to s[4].
 
class Result {

	public static int counting(String s) {
        List<Integer> counts = new ArrayList<>();
        int cur = 1;

        // Traverse the string to count consecutive characters
        for (int i = 1; i < s.length(); i++) {
            if (s.charAt(i) == s.charAt(i - 1)) {
                cur++;
            } else {
                counts.add(cur);
                cur = 1;
            }
        }

        // Append the last count
        counts.add(cur);

        // Calculate the result by adding the minimum of consecutive counts
        int ans = 0;
        for (int i = 1; i < counts.size(); i++) {
            ans += Math.min(counts.get(i), counts.get(i - 1));
        }

        return ans;
    }

}

public class Solution {
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		String str=sc.nextLine();
		int result = Result.counting(str);

		System.out.println(result);
	}
}


















23. Question – Simple Matrix Summation
Given an n x m matrix, a, where each a(i, j) is the value of the cell at the intersection of row i and column j, create another n x m matrix, b, using the following algorithm to set the values of each b(x, y) with zero-based indexing:
 
s = 0;

for (i = 0; i ≤ x; i += 1) {
    for (j = 0; j ≤ y; j += 1) {
        s = s + a(i, j);
    }
}

b(x, y) = s;
 
Note that the algorithm sets just one b(x, y) per execution and that 0 ≤ x < n and 0 ≤ y < m. It should be run for each element of b. Return the completed n × m matrix b.
 
Example
If matrix a is:
1 2 3
4 5 6
The following operations are performed:
Element 	Equation 		Values		b(x, y)
-------		-----------------------	-------------	------
b(0,0)		a(0,0)			1		1
b(0,1)		a(0,0)+a(0,1)		1+2		3
b(0,2)		a(0,0)+a(0,1)+a(0,2) 	1+2+3		6
b(1,0)		a(0,0)+a(1,0)		1+4		5
b(1,1)		a(0,0)+a(0,1)		1+2+4+5		12
		+a(1,0)+a(1,1)
b(1,2)		a(0,0)+a(0,1)+a(0,2)	1+2+3+4+5+6	21
		+a(1,0)+a(1,1)+a(1,2)
The final matrix b is:
1  3  6
5 12 21
 
Function Description
Complete the function findMatrix in the editor below.
 
findMatrix has the following parameter(s):
    int a[n][m]: a 2-dimensional array of integers
 
Returns:
    int[n][m]: the calculated 2-dimensional array of integers b 
 
Constraints
•	1 ≤ n, m ≤ 103
•	0 ≤ a(i, j) ≤ 103, where 0 ≤ i < n and 0 ≤ j < m.
Input Format for Custom Testing
Sample Case 0
Sample Input
STDIN     Function
-----     -----
2      →  number of rows in a[] n = 2
2      →  number of columns in a[] m = 2
1 2    →  first row of a[] = [1, 2]
3 4    →  second row of a[] = [3, 4]
 
Sample Output
1 3
4 10
 
Explanation
 
Find the following 2 × 2 matrix, b:
•	b(0, 0) = a(0, 0) = 1
•	b(0, 1) = a(0, 0) + a(0, 1) = 1 + 2 = 3
•	b(1, 0) = a(0, 0) + a(1, 0) = 1 + 3 = 4
•	b(1, 1) = a(0, 0) + a(0, 1) + a(1, 0) + a(1, 1) = 1 + 2 + 3 + 4 = 10
Sample Case 1
Sample Input
STDIN     Function
-----     -----
3      →  number of rows in a[] n = 3
3      →  number of columns in a[] m = 3
1 2 3  →  first row of a[] = [1, 2, 3]
4 5 6  →  second row of a[] = [4, 5, 6]
7 8 9  →  third row of a[] = [7, 8, 9]
 
Sample Output
1 3 6
5 12 21
12 27 45
 
Explanation
 
Find the following 3 × 3 matrix, b:
•	b(0, 0) = a(0, 0) = 1
•	b(0, 1) = a(0, 0) + a(0, 1) = 1 + 2 = 3
•	b(0, 2) = a(0, 0) + a(0, 1) + a(0, 2) = 1 + 2 + 3 = 6
•	b(1, 0) = a(0, 0) + a(1, 0) = 1 + 4 = 5
•	b(1, 1) = a(0, 0) + a(0, 1) + a(1, 0) + a(1, 1) = 1 + 2 + 4 + 5 = 12
•	b(1, 2) = a(0, 0) + a(0, 1) + a(0, 2) + a(1, 0) + a(1, 1) + a(1, 2) = 1 + 2 + 3 + 4 + 5 + 6 = 21
•	b(2, 0) = a(0, 0) + a(1, 0) + a(2, 0) = 1 + 4 + 7 = 12
•	b(2, 1) = a(0, 0) + a(0, 1) + a(1, 0) + a(1, 1) + a(2, 0) + a(2, 1) = 1 + 2 + 4 + 5 + 7 + 8 = 27
•	b(2, 2) = a(0, 0) + a(0, 1) + a(0, 2) + a(1, 0) + a(1, 1) + a(1, 2) + a(2, 0) + a(2, 1) + a(2, 2) = 1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 = 45
Interviewer Guidelines
New
Private
Python 3 Solution
def findMatrix(a): 
    n = len(a) 
    m = len(a[0]) 
    b = [[None] * m for _ in range(n)] 
    for i in range(n): 
        for j in range(m): 
            s = a[i][j] 
            if i != 0: 
                s += b[i-1][j] 
            if j != 0: 
                s += b[i][j-1] 
            if i != 0 and j != 0: 
                s -= b[i-1][j-1] 
            b[i][j] = s 
    return b














24. Question – Good Binary String
Question
Optimize a "good" binary string by rearranging its good substrings to create the largest possible numeric value.
 
In a good binary string:
1.	The number of 0's equals the number of 1's.
2.	For every prefix of the string, the number of 1's is greater than or equal to the number of 0's.
 
Rules:
•	A good string can contain multiple good substrings.
•	Two adjacent good substrings can be swapped if the resulting string remains good.
•	Two substrings are adjacent if the last character of the first substring is immediately before the first character of the second substring.
Perform zero or more swap operations on adjacent good substrings to form the binary string with the largest possible numeric value and return that value.
 
Example
 
binString = 1010111000
 
There are two good binary substrings, 1010 and 111000, among others. Swap these two substrings to get a larger value: 1110001010. This is the largest possible good string that can be formed.
 
Function Description
Complete the function largestMagical in the editor with the following parameters:
    str binString:  a binary string
 
Returns
    str: the largest possible binary value as a string
 
Constraints
•	Each character of binString is in {01}.
•	1 ≤ length of binString ≤ 50
•	binString is a good string.
 
Input Format For Custom Testing
Sample Case 0
Sample Input 0
STDIN          Function Parameters 
-----          -------------------
11011000  →    binString = "11011000"
Sample Output 0
11100100
Explanation 0
Choose two adjacent good substrings to swap: 10 and 1100. The resultant string, str = 11100100.
Sample Case 1
Sample Input 1
STDIN      Function Parameters
-----      -------------------
1100  →    binString = "1100"
Sample Output 1
1100
Explanation 1
The only good substring of binString is 1100. No operations can be applied to the string.
Sample Case 2
Sample Input For Custom Testing
STDIN          Function Parameters
-----          -------------------
1101001100 →   binString = "1101001100"
Sample Output
1101001100
Explanation
 
The only consecutive good substrings are 110100 and 1100. Note that 100 is not a good substring because it contains more zeroes than ones. If they are swapped, it results in a numerically smaller string. Thus, binString is already the numerically largest good string that can be formed.
Interviewer Guidelines
New
Private
Solution
Python Solution

def largestMagical(binString): 
    if binString == "": 
        return "" 
    ans = [] 
    cnt, i, j = 0, 0, 0
    while i < len(binString): 
        cnt += 1 if binString[i]=="1" else -1 
        if cnt == 0: 
            ans.append('1'+largestMagical(binString[j+1:i])+"0") 
            j = i+1 
        i += 1 
    ans.sort(reverse=True) 
    return ''.join(ans)

















25. Question - Are They Pangrams
A string is considered a pangram if it includes every letter of the English alphabet (a-z).
 
Given a list of strings, determine whether each string is a pangram. For each string, return "1" if it is a pangram and "0" otherwise.
 
Example
pangram = ['pack my box with five dozen liquor jugs', 'this is not a pangram']
 
•	The string 'pack my box with five dozen liquor jugs' is a pangram because it contains all the letters 'a' through 'z'.
•	The string 'this is not a pangram' is not a pangram.
•	Assemble a string of the two results, in order.  The result is '10'.
 
Function Description Complete the function isPangram in the editor below.
 
isPangram has the following parameter(s):
    string pangram[n]:  the sentences to check
 
Returns
    string: a string where each position represents the results of a test. Use '1' for true and '0' for false.
 
Constraints
•	1 ≤ n ≤ 100
•	Each string pangram[i] (where 0 ≤ i < n) is composed of lowercase letters and spaces.
•	1 ≤ length of pangram[i] ≤ 105
 
Input Format for Custom Testing
Sample Case 0
Sample Input 0
STDIN                                                            Function Parameters 
-----                                                            ------------------- 
4                                                             →  pangram[] size n = 4 
we promptly judged antique ivory buckles for the next prize   →  pangram[] = ["we promptly judged antique ivory buckles for the next prize",
we promptly judged antique ivory buckles for the prizes                       "we promptly judged antique ivory buckles for the prizes",
the quick brown fox jumps over the lazy dog                                   "the quick brown fox jumps over the lazy dog", 
the quick brown fox jump over the lazy dog                                    "the quick brown fox jump over the lazy dog" ]



 
Sample Output 0
1010
 
Explanation 0
pangram[0] = True
pangram[1] = False
pangram[2] = True
pangram[3] = False
•	The strings pangram[0] and pangram[2] are pangrams, and the others are not.
•	The result is '1010'
Sample Case 1Sample Input 1
•	
•	
Interviewer Guidelines
New
Private
Hint 1
How can you keep track of when a character has been seen? Answer: Have a seen array of 26 integers initialized to zero. As a character is seen, update the array at the index ord(character) - ord('a') to 1. Ignore spaces.
Hint 2
How will you know when all letters have been seen?
Answer: Each time you update the seen array, increment a counter.
Solution
Skills: Iterating through strings, problem solving, data structures (set or array)
Brute Force Approach: A simple solution that analyzes every character of the string is to create a set from the alphabet, create a set from the string, remove the space character from the set and get their intersection. If the intersection equals the alphabet set, the string is a pangram. Creating a set takes O(n) running time.
Optimal Solution:
The most efficient solution starts with an seen array of 26 zeros, and a counter initialized to 0. Iterate through the string, checking if a character has already been seen. If it has not, update the value in the seen array and increment the counter. When the counter equals 26, it is a pangram. If you reach the end of the string and the counter is less than 26, it is not a pangram. Note that the test cases are such that a solution will work even if they iterate through all characters in every string. A minor optimization is to break out of the loop when the counter reaches 26.
 
def isPangram(pangram):
    # Write your code here
    answer = ''
    for sentence in pangram:
        seen = [0] * 26
        count = 0
        for c in sentence:
            if not c == ' ':
                idx = ord(c) - ord('a')
                if seen[idx] == 0:
                    seen[idx] = 1
                    count += 1
                if count == 26:
                    break
        answer += '1' if count == 26 else '0'
    return answer        
 

25. Question – String transfer

Data, in the form of a binary string has to be sent across two servers in HackerLand. However, according to a new network control protocol, data can only be sent in the form of binary strings that have no two adjacent characters same. Such binary strings with no two adjacent characters same are called special strings. Any data to be transmitted is first broken into one/numerous subsequences that are special strings and then each special string is sent as a data packet across the connected servers.
 
Given a binary string that has to be sent across two servers, find the minimum number of data packets it will be broken into.
 
Note: A subsequence of a string is obtained by deleting some characters from the string while maintaining the order. For example, "011" is a subsequence of "0101" while "100" is not.
 
Example
Suppose input_str = "00100"
 
The given string can be broken into three subsequences that are special as follows: "0", "010", and "0". It is also the minimum number of special subsequences that the string can be broken into. Hence the output is 3.
 
Function Description
Complete the function getMinSubsequences in the editor below.
 
getMinSubsequences has the following parameter:
    str input_str:  a binary string
 
Returns
    int: The minimum number of subsequences that the string can be broken into
 
Constraints
•	1 ≤  length of input_str ≤ 105
 
Input Format For Custom Testing
Sample Case 0
Sample Input For Custom Testing
STDIN         FUNCTION
-----         --------
1101     →    input_str = "1101"  
Sample Output
2
Explanation
The string can be broken into two valid subsequences "1" and "101".
Sample Case 1
Sample Input For Custom Testing
STDIN         FUNCTION
-----         --------
11001010  →   input_str = "11001010" 
Sample Output
2
Explanation
The two subsequences are "101010" and "10".
class Result {

	public static int getMinSubsequences(String input_str) {
		int cnt_1 = 0, cnt_0 = 0;

		// Iterate over the input string
		for (int i = 0; i < input_str.length(); i++) {
			// Check if the current character is '0'
			if (input_str.charAt(i) == '0') {
				// If there are '1's to match with, reduce cnt_1
				if (cnt_1 > 0) {
					cnt_1 -= 1;
				}
				cnt_0 += 1;
			}
			// If the current character is '1'
			else {
				// If there are '0's to match with, reduce cnt_0
				if (cnt_0 > 0) {
					cnt_0 -= 1;
				}
				cnt_1 += 1;
			}
		}

		// Return the sum of remaining cnt_1 and cnt_0
		return cnt_0 + cnt_1;
	}
}

public class Solution {
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		String str = sc.nextLine();

		int result = Result.getMinSubsequences(str);
		System.out.println(result);
	}
}
 




26. Question –  Permutations Divisible by 8
Given an integer string, create all integer permutations of its digits. Determine if there is a permutation whose integer value is evenly divisible by 8, i.e. (permutation value) mod 8 = 0.
 
For example, the possible permutations of 123 are p = {123, 132, 213, 231, 312, 321}. Of these values, p[4] = 312 is divisible by 8 because 312 mod 8 = 0.
 
Function Description 
Complete the function checkDivisibility in the editor below. The function must return an array of result strings, either YES or NO, where each result[i] denotes whether a permutation of arr[i] is divisible by 8.
 
checkDivisibility has the following parameter(s):
    arr[arr[0],...arr[n-1]]:  an array of integer strings
 
Constraints
•	1 ≤ n ≤ 45
•	0 ≤ arr[i] ≤ 10110
•	All characters of arr[i] ∈ {0-9}
 
Input Format for Custom Testing
Input from stdin will be processed as follows and passed to the function.
 
The first line contains an integer n, the size of the array arr.
Each of the next n lines contains an integer as a string, arr[i], where 0 ≤ i < n.
 
Sample Case 0
Sample Input 0
STDIN   Function Parameters 
-----   -------------------
2    →  arr[] Size = 2
61   →  arr[] = [ 61, 75 ]
75                 
Sample Output 0
YES
NO
Explanation 0
Check the following n = 2 values:
•	arr[0] = 61. The permutation p = 16 is divisible by 8 so store YES in index 0 of the return array.
•	arr[1] = 75. The only permutations are p = 75 and p = 57, but neither of them is divisible by 8. Store NO in index 1 of the return array.
 











27. Question - River Records
A meteorologist maintains a record of water level readings taken on a nearby river.  One of the figures to determine is the maximum height above a previously recorded value that has been achieved to date. Given an array of integers, find the maximum difference between any element and any preceding smaller element without changing the order. If there is no such preceding element, return -1.
 
Example
arr = [5, 3, 6, 7, 4]
 
There are no earlier elements than arr[0].
There is no earlier reading with a value lower than arr[1].
There are two lower earlier readings with a value lower than arr[2] = 6:
•	arr[2] - arr[1] = 6 - 3 = 3
•	arr[2] - arr[0] = 6 - 5 = 1
There are three lower earlier readings with a lower value than arr[3] = 7:
•	arr[3] - arr[2] = 7 - 6 = 1
•	arr[3] - arr[1] = 7 - 3 = 4
•	arr[3] - arr[0] = 7 - 5 = 2
There is one lower earlier reading with a lower value than arr[4] = 4:
•	arr[4] - arr[1] = 4 - 3 = 1
 
The maximum trailing record is arr[3] - arr[1] = 4.
 
Example
arr = [4, 3, 2, 1]
 
No item in arr has a lower earlier reading, therefore return -1
 
Function Description 
Complete the function maximumTrailing in the editor below.
 
maximumTrailing has the following parameter(s):
    int arr[n]:  an array of integers
 
Returns:
    int: the maximum trailing difference, or -1 if no element in arr has a lower earlier value
 
Constraints
•	1 ≤ n ≤ 2 × 105
•	−106 ≤ arr[i] ≤ 106  and  0 ≤ i < n
 
Input Format For Custom Testing
Sample Case 0
Sample Input 0
STDIN         Function
-----         --------
7       →     arr[] size n = 7
2       →     arr = [2, 3, 10, 2, 4, 8, 1]
3       
10     
2      
4      
8       
1         
 
Sample Output
8
Explanation
 
Differences are calculated as:
•	3 - [2] = [1]
•	10 - [3, 2] = [7, 8]
•	4 - [2, 3, 2] = [2, 1, 2]
•	8 - [4, 2, 3, 2] = [4, 6, 5, 6]
The maximum trailing difference is 10 - 2 = 8.
Sample Case 1
Sample Input 1
STDIN         Function 
-----         -------- 
6       →     arr[] size n = 6
7       →     arr = [7, 9, 5, 6, 3, 2]
9       
5       
6       
3       
2       
Sample Output
2
Explanation
 
Differences are calculated as:
•	9 - [7] = 2
•	6 - [5] = 1
The maximum trailing difference is 2.




















28. Question - Largest Subset Sum
Question
For each number in an array, get the sum of its factors. Return an array of results.
 
Example
arr = [12]
 
The factors of arr[0] = 12 are [1, 2, 3, 4, 6, 12]. The sum of these factors is 28. Return the array [28].
 
 
Function Description 
Complete the function maxSubsetSum in the editor below.
 
maxSubsetSum has the following parameter(s):
    int arr[n]:  an array of integers
 
Returns
    long[n]:  the sums calculated for each arr[i]
 
Constraints
•	1 ≤ n ≤ 103
•	1 ≤ arr[i] ≤ 109
 
Input Format For Custom Testing
Sample Case 0
Sample Input 0
STDIN    Function
-----    --------
2    →   arr[] size n = 2
2    →   arr = [2, 4]
4
Sample Output 0
3 
7
 
Explanation 0
 
Factors of arr[0] = 2 are [1, 2] and their sum is 3.
Factors of arr[1] = 4 are [1, 2, 4] and their sum is 7.
Interviewer Guidelines
New
Private
Hint 1
What is the limit of numbers you need to test when finding all factors of a positive integer? Answer: the square root of the number
Solution
Concepts covered: 
Factorization, Math
 
Optimal Solution: 
For each number, iterate up to the square root of that number. If f is a factor of the number N then N/f is a factor as well. But if N is a perfect square f will be equal to N/f so we add it only once in our sum variable.
The time complexity of this approach is O(|k|*sqrt(MAX(ki))), where |k| is the number of elements in the list k.
def maxSubsetSum(k):
    ans = []
    for num in k:
        sum = 0
        sqrt_num = int(math.sqrt(num))
        for fac in range(1,sqrt_num+1):
            if num % fac == 0:
                sum += fac
                if num//fac != (fac):
                    sum += num//fac
        ans.append(sum)
    return ans
 
Brute Force Approach: 
For each number X in the list loop through [1, X] and take sum of the factors.
The time complexity of this approach is O(|k|*MAX(ki)), where |k| is the number of elements in the list k.
 
Error Handling: 
1.	Make sure you don't count the square root value twice in case the number is a perfect square.

29. Question – Count between
Given an array of integers and a series of ranges, determine the number of array elements in the ranges. The ranges are inclusive.
 
Example
arr = [1, 2, 2, 3, 4]
low = [0, 2]
high = [2, 4]
 
Queries are aligned by index.
1.	low = 0, high = 2:  There are 3 elements in the range: [1, 2, 2]
2.	low = 2, high = 4:  There are 4 elements in the range: [2, 2, 3, 4]
 
Return the array of answers, aligned by index with their queries: [3, 4].
 
Constraints
•	1 ≤ n ≤ 105
•	1 ≤ arr[j] ≤ 109
•	1 ≤ q ≤ 105
•	1 ≤ low[i] ≤ high[i] ≤ 109
 
Input Format For Custom Testing
Sample Case 0
Sample Input For Custom Testing
Sample Input 0
STDIN     Function
-----     --------
5    →    arr[] size n = 5
1    →    arr = [1, 3, 5, 6, 8]
3
5
6
8
1    →    low[] size q = 1
2    →    low = [2]
1    →    high[] size q = 1
6    →    high = [6]
 
Sample Output 0
3
 
Explanation 0
 
1.	There are 3 elements in the inclusive range [2, 6]: [3, 5, 6], so store 3 in index 0 of the return array.
 
Return the array [3].
Sample Case 1
Sample Input For Custom Testing
Sample Input 1
STDIN     Function
-----     --------
3    →    arr[] size n = 3
4    →    arr = [4, 8, 7]
8
7
2    →    low[] size q = 2
2    →    low = [2, 4]
4
2    →    high[] size q = 2
8    →    high = [8, 4]
4
Sample Output 1
3
1
 
Explanation 1
 
1.	There are 3 elements in the inclusive range [2, 8]: [4, 7,  8] so store 3 in index 0 of the return array.
2.	There is 1 element in the inclusive range [4, 4]: [1] so store 1 in index 1 of the return array.
 
Return the array [3, 1].
 
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;
import java.util.stream.Collectors;
import java.util.stream.IntStream;

class Result {

	public static List<Integer> countBetween(List<Integer> arr, List<Integer> low, List<Integer> high) {
		// Write your code here
		List<Integer> result = new ArrayList<>();

		// Iterate over each query
		for (int i = 0; i < low.size(); i++) {
			int count = 0;
			int l = low.get(i);
			int h = high.get(i);

			// Count elements in arr[] that are within the range [l, h]
			for (int num : arr) {
				if (num >= l && num <= h) {
					count++;
				}
			}
			result.add(count);
		}

		return result;

	}

}

public class Solution {
	public static void main(String[] args) throws IOException {
		Scanner sc = new Scanner(System.in);
		int arrCount = Integer.parseInt(sc.nextLine().trim());

		List<Integer> arr = IntStream.range(0, arrCount).mapToObj(i -> {
			return sc.nextLine().replaceAll("\\s+$", "");
		}).map(String::trim).map(Integer::parseInt).collect(Collectors.toList());

		int lowCount = Integer.parseInt(sc.nextLine().trim());

		List<Integer> low = IntStream.range(0, lowCount).mapToObj(i -> {
			return sc.nextLine().replaceAll("\\s+$", "");
		}).map(String::trim).map(Integer::parseInt).collect(Collectors.toList());

		int highCount = Integer.parseInt(sc.nextLine().trim());
		
		List<Integer> high = IntStream.range(0, highCount).mapToObj(i -> {
			return sc.nextLine().replaceAll("\\s+$", "");
		}).map(String::trim).map(Integer::parseInt).collect(Collectors.toList());

		List<Integer> result = Result.countBetween(arr, low, high);

		for (Integer i : result)
			System.out.println(i);
	}
}


29. Question – Inversion
A subsequence is formed by removing zero or more elements from a list while preserving the order. For instance, the subsequences of [1,2,3] are [1], [2], [3], [1,2], [1,3], [2,3], [1,2,3]. An inversion is a strictly decreasing subsequence of length 3. More precisely, given an array, p = p[n], an inversion in the array occurs whenever p[i] > p[j] > p[k] and i < j < k.
 
Determine the number of inversions within a given array.
 
Example 
n = 5
arr = [5,3,4,2,1].
 
The array inversions are:
	[5,3,2]
	[5,3,1]
	[5,4,2]
	[5,4,1]
	[5,2,1]
	[3,2,1]
	[4,2,1]
Example 2
n = 4
prices = [4,2,2,1].
 
The only inversion is [4, 2, 1] and there are two instances: indices 0, 1, 3 and indices 0, 2, 3. The arrays [4, 2, 2] and [ 2, 2, 1] are not considered inversions because they are not strictly decreasing.
 
Function Description 
Complete the function maxInversions in the editor with the following parameter(s):
    int prices[n]:  an array of integers
 
Returns
    long int: the number of inversions in the array
 
Constraints
•	1 ≤ n ≤ 5000
•	1 ≤ arr[i] ≤ 106, where 0 ≤ i < n
 
Input Format for Custom Testing
Sample Case 0
Sample Input 0
STDIN   Function Parameters 
-----   ------------------- 
5    →  arr[] size n = 5 
4    →  arr = [4, 1, 3, 2, 5]
1
3
2
5
 
Sample Output 0
1
 
Explanation 0
 
There is only one inversion in the array: (4, 3, 2).
 
Sample Case 1
Sample Input 1
STDIN   Function Parameters
-----   -------------------
5    →  arr[] size n = 5
15   →  arr = [15, 10, 1, 7, 8] 
10
1
7
8
 
Sample Output 1
3
 
Explanation 1
 
There are three inversions in the array: (15, 10, 1), (15, 10, 7), and (15, 10, 8).
 
import java.io.IOException;
import java.util.List;
import java.util.Scanner;
import java.util.stream.Collectors;
import java.util.stream.IntStream;

class Result {
	public static long maxInversions(List<Integer> arr) {
		// Write your code here
		int n = arr.size(); // Get the size of the list
		long inversionCount = 0;

		// Loop over each element in the array to check as the middle element of the
		// inversion
		for (int j = 1; j < n - 1; j++) {
			int leftGreaterCount = 0; // Count elements greater than arr[j] to the left
			int rightSmallerCount = 0; // Count elements smaller than arr[j] to the right

			// Count elements greater than arr[j] on the left side
			for (int i = 0; i < j; i++) {
				if (arr.get(i) > arr.get(j)) {
					leftGreaterCount++;
				}
			}

			// Count elements smaller than arr[j] on the right side
			for (int k = j + 1; k < n; k++) {
				if (arr.get(k) < arr.get(j)) {
					rightSmallerCount++;
				}
			}

			// Add to the inversion count the number of valid subsequences
			inversionCount += (leftGreaterCount * rightSmallerCount);
		}

		return inversionCount;
	}

}

public class Solution {
	public static void main(String[] args) throws IOException {
		Scanner sc = new Scanner(System.in);
		int arrCount = Integer.parseInt(sc.nextLine().trim());

		List<Integer> arr = IntStream.range(0, arrCount).mapToObj(i -> {
			return sc.nextLine().replaceAll("\\s+$", "");
		}).map(String::trim).map(Integer::parseInt).collect(Collectors.toList());

		long result = Result.maxInversions(arr);
		System.out.println(result);
	}
}


30. Question – No Pairs Allowed
For each word in a list of words, if any two adjacent characters are equal, change one of them. Determine the minimum number of substitutions so the final string contains no adjacent equal characters.
 
Example
words = ['add', 'boook', 'break']
 
1.	'add': change one d (1 change)
2.	'boook': change the middle o (1 change)
3.	'break': no changes are necessary (0 changes)
 
The return array is [1,1,0].
 
Function Description 
Complete the function minimalOperations in the editor below.
 
minimalOperations has the following parameter(s):
    string words[n]:  an array of strings
 
Returns:
    int[n]: each element i is the minimum substitutions for words[i]
 
Constraints
•	1 ≤ n ≤ 100
•	2 ≤ length of words[i] ≤ 105
•	Each character of words[i] is in the range ascii[a-z].
 
Input Format for Custom Testing
Input from stdin will be processed as follows and passed to the function.
 
The first line contains an integer n, the size of the array words.
Each of the next n lines contains a string words[i].
 
Sample Case 0
Sample Input 0
STDIN         Function Parameters 
-----         -------------------
5          →  words[] Size = 5
ab         →  words[] = [ 'ab','aab','abb', 'abab','abaaaba' ]
aab                        
abb                        
abab                      
abaaaba                    
 
Sample Output 0
0
1
1
0
1
 
Explanation 0
 
•	words = 'ab' is already acceptable, so 0 replacements are needed.
•	words = 'aab' Replace an 'a' with an appropriate character so 1 replacement.
•	words = 'abb' is not acceptable. Replace a 'b' with an appropriate character, again 1 replacement.
•	words = 'abab' is already acceptable so 0 replacements are needed.
•	words = 'abaaaba' is not acceptable. Replace the middle 'a'  in 'aaa', 1 replacement.
 
The return array is [0, 1, 1, 0, 1].
Interviewer Guidelines
New
Private
Hint 1
As you iterate through the string, which character(s) need to be tested for equivalence? For each character check only characters adjacent to it on the left.
Hint 2
If you replace a character, can you always assume the replacement differs from the character to its right as well?
Why, and how can you use this fact?
 
The characters left and right can either be the same or different. There are 25 or 24 letters available in all cases.
This allows you to skip over the next character after a replacement.
Solution
Concepts covered: This problem covers the concepts of strings and arrays.
 
Optimal Solution: 
For each string, start with the character at index 1. Compare each character to the one to its left, with one exception. If the two letters are equal, assume the character to its left remains the same and the current character is replaced. It can always be replaced with a character different from both adjacent characters, left and right. The next character after a replacement can be skipped.
 
def minimalOperations(words):
    ans = []
    for w in words:
        count = 0
        i = 1
        while i < len(w):
            # test for match
            if w[i] == w[i-1]:
                # yes: increment counter and skip the next character
                count += 1
                i += 2
            else:
                # no: move to the next character
                i += 1
        ans.append(count)
    return ans
 
Sub-optimal approach: For each string, iterate its characters, checking if they are equal to the one to their left. If the characters match, replace the current character with '#'. For example: string "abbca". We check pairs one by one, 'ab', 'bb', here characters are the same, so we replace the second character with '#'. Continue checking symbols one by one, '#c', 'ca'. This finishes the process.

def minimalOperations(words):
    
    ans = []
    
    for i in range(len(words)):
        # replacement counter
        cur_ans = 0
        # convert the string to a list so it is mutable
        cur_word = list(words[i])            
        
        for j in range(1, len(words[i])):
            # if characters match, replace the current character
            if cur_word[j-1] == cur_word[j]: 
                # replace with a character guaranteed to be different from the next character
                cur_word[j] = "#" 
                cur_ans += 1
                
        ans.append(cur_ans)
        
    return ans
Error Handling: 
1. The case of a zero length string must be handled separately.











31. The Coder friend

class Result {

    /*
     * Complete the 'winner' function below.
     *
     * The function is expected to return a STRING.
     * The function accepts following parameters:
     *  1. STRING erica
     *  2. STRING bob
     */

    public static String winner(String erica, String bob) {
        int [] s ={1,3,5};
        
        int e=0,b=0;
        for(int i=0;i<erica.length();i++){
            if(erica.charAt(i)== 'E'){
                e+=s[0];
            }
            else if (erica.charAt(i)=='M'){
                e+=s[1];
            }
            else if (erica.charAt(i)=='H'){
                e+=s[2];
            }
            
            if(bob.charAt(i)== 'E'){
                b+=s[0];
            }
            else if (bob.charAt(i)=='M'){
                b+=s[1];
            }
            else if (bob.charAt(i)=='H'){
                b+=s[2];
            }
            
        }
        
        if(e>b){
                return "Erica";
            }else if (b>e){
                return "Bob";
            }else{
                return "Tie";
            }

    }

}

public class Solution {
    public static void main(String[] args) throws IOException {
        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter bufferedWriter = new BufferedWriter(new FileWriter(System.getenv("OUTPUT_PATH")));

        String erica = bufferedReader.readLine();

        String bob = bufferedReader.readLine();

        String result = Result.winner(erica, bob);

        bufferedWriter.write(result);
        bufferedWriter.newLine();

        bufferedReader.close();
        bufferedWriter.close();
    }
}

Erica and Bob participate in a friendly Hackathon that allows each one to solve one question a day out of the three offered. There will be one easy, one medium and one hard question, with points awarded based on difficulty. The winner is the one with the highest score at the end of the competition based on the following scale:
 
Scoring table
Difficulty	Points
Easy (E)	1
Medium (M)	3
Hard (H)	5
 
 
 
 
 
 
 
 
 
There are two strings, erica and bob. Each character erica[i] and bob[i] represent the difficulties of the problems ("E","M",H") solved on day[i] by Erica and Bob. The scoring table associates the points for each question difficulty. Calculate the scores for Erica and Bob. Return the name of the winner: "Erica", "Bob" or "Tie" if they have the same score.
 
Example
erica=["E"]
bob=["E"]
 
Day	Erica's difficulty	Erica's score	Bob's difficulty	Bob's score
0	E	1	E	1
 
•	erica[0]="E". The first question solved by Erica in day 0 was easy "E" and Erica's score is 1
•	bob[0]="E". The first question solved by Bob in day 0 was easy "E" and Bob's score is also 1
•	Erica's and Bob's  scores are equal: Tie
 
Function Description 
Complete the function winner in the editor below.
 
winner has the following parameter(s):
    string erica[n]:  erica[i] denotes the difficulty of Erica's problem solved on day i
    string bob[n]:  bob[i] denotes the difficulty of Bob's problem solved on day i
 
Returns:
    string winnerName: a name of the winner Erica or Bob, or Tie if their scores are equal.
 
Constraints
•	0 < n < 105
 
Input Format For Custom Testing
Sample Case 0
Sample Input For Custom Testing
STDIN     Function 
-----     -------- 
EHH  →    erica=["E","H","H"]
EME  →    bob=["E","M","E"]
Sample Output
Erica
Explanation
              Erica's        Erica's     Bob's           Bob's 
Day           difficulty     Score       difficulty      Score
0             E              1           E               1
1             H              5           M               3
2             H              5           E               1
Total Scores                 11                          5

Erica wins.
Sample Case 1
Sample Input For Custom Testing
STDIN     Function
-----     --------
E    →    erica=["E'] 
H    →    bob=["H"]
Sample Output
Bob
 
Explanation
               Erica's      Erica's     Bob's       Bob's 
Day            difficulty   Score       difficulty  Score
0              E            1           H           5
Total Scores                1                       5
 
Bob wins.



32. Arranging coins

Given a number of coins, build a staircase where each row has 1 less coin than the one below. Determine how many complete rows the staircase can be.
 
Example
coins = [6]
 
¤
¤ ¤
¤ ¤ ¤
 
With 6 coins, a 3 row staircase can be built.
 
Function Description 
Complete the function arrangeCoins in the editor below.
 
arrangeCoins has the following parameter(s):
    int coins[n]:  an array of long integers each representing a number of coins available
 
Returns
    NONE
Output
    For each coins[i], print an integer that denotes the maximum number of complete rows that can be created. Each answer must be on a separate line.
 
Constraints
•	1 ≤ n ≤ 105
•	1 ≤ coins[i] ≤ 1015
 
Input Format for Custom Testing
Sample Case 0
Sample Input 0
STDIN    Function
-----    --------
4    →   coins[] size n = 4
2    →   coins = [2, 5, 8, 3]
5
8
3
 
Sample Output 0
1
2
3
2
 
Explanation 0
 
1.	coins[0] = 2
The coins can form the following rows:
2.	¤
¤
Because the 2nd row is incomplete,  print 1 on a new line.
 
3.	coins[1] = 5
The coins can form the following rows:
4.	¤
5.	¤ ¤
¤ ¤
Because the 3rd row is incomplete, print 2 on a new line.
 
6.	coins[2] = 8
The coins can form the following rows:
7.	¤
8.	¤ ¤
9.	¤ ¤ ¤
¤ ¤
Because the 4th row is incomplete, print 3 on a new line.
 
10.	coins[3] = 3
The coins can form the following rows:
11.	¤
¤ ¤
Because the 2nd row is complete, print 2 on a new line.
 
class Result {
    /*
     * Complete the 'arrangeCoins' function below.
     *
     * The function accepts LONG_INTEGER_ARRAY coins as parameter.
     */
    public static void arrangeCoins(List<Long> coins) {
        for (Long coinCount : coins) {
            long result = (long)((Math.sqrt(1 + 8.0 * coinCount) - 1) / 2);
            System.out.println(result);
        }
    }
}

public class Solution {
    public static void main(String[] args) throws IOException {
        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));

        int coinsCount = Integer.parseInt(bufferedReader.readLine().trim());

        List<Long> coins = new ArrayList<>();

        for (int i = 0; i < coinsCount; i++) {
            coins.add(Long.parseLong(bufferedReader.readLine().trim()));
        }

        Result.arrangeCoins(coins);

        bufferedReader.close();
    }
}

public static void arrangeCoins(List<Long> coins) {
        
        for(long coin: coins){
            long left = 0,right = (long) Math.sqrt(2*coin)+1;
            while (left<= right) {
                long mid = (left+right)/2;
                long totalCoins = mid*(mid+1)/2;
                
                if(totalCoins == coin){
                    System.out.println(mid);
                    break;
                }else if (totalCoins < coin){
                    left = mid + 1;
                }else{
                    right = mid - 1;
                }
            }
            
            if(left > right){
                System.out.println(right);
            }
        }
    // Write your code here

    }












33. Profit targets

A financial analyst is responsible for a portfolio of profitable stocks represented in an array. Each item in the array represents the yearly profit of a corresponding stock. The analyst gathers all distinct pairs of stocks that reached the target profit. Distinct pairs are pairs that differ in at least one element.
Given the array stocksProfit, find the number of distinct pairs of stocks where the sum of each pair's profits is exactly equal to the target profit.
 
Example
stocksProfit = [5, 7, 9, 13, 11, 6, 6, 3, 3]
target = 12 profit's target
 
•	There are 4 pairs of stocks that have the sum of their profits equals to the target 12 . Note that because there are two instances of 3 in stocksProfit there are two pairs matching (9, 3): stocksProfits indices 2 and 7, and indices 2 and 8, but only one can be included.
•	There are 3 distinct pairs of stocks: (5, 7), (3, 9), and (6, 6) and the return value is 3.
 
Function Description 
Complete the function stockPairs in the editor below.
 
stockPairs has the following parameter(s):
    int stocksProfit[n]: an array of integers representing the stocks profits
    long target: a value representing the yearly target profit
 
Returns:
    int: the total number of pairs determined
 
Constraints
•	1 ≤ n ≤ 5 × 105
•	0 ≤ stocksProfit[i] ≤ 109
•	0 ≤  target ≤ 5 × 109
 
Input Format for Custom Testing
Sample Case 0
Sample Input 0
STDIN      Function
-----      --------
6      →   stocksProfit[] size n = 6
1      →   stocksProfit = [1, 3, 46, 1, 3, 9]
3      
46    
1      
3      
9      
47     →   target = 47
Sample Output 0
1
Explanation 0
 
There are 4 pairs where stocksProfit[i] + stocksProfit[j] = 47
1.	(stocksProfit0] = 1, stocksProfit[2] = 46)
2.	(stocksProfit[2] = 46, stocksProfit[0] = 1)
3.	(stocksProfit[2] = 46, stocksProfit[3] = 1)
4.	(stocksProfit[3] = 1, stocksProfit[2] = 46)
Since all four pairs contain the same values, there is only 1 distinct pair of stocks : (1, 46).
Sample Case 1
Sample Input 1
STDIN      Function
-----      --------
7      →   stocksProfit[] size n = 7
6      →   stocksProfit = [6, 6, 3, 9, 3, 5, 1]
6      
3      
9      
3      
5      
1      
12     →   target = 12
Sample Output 1
2
Explanation 1
 
There are 5 pairs where stocksProfit[i] + stocksProfit[j] = 12:
1.	(stocksProfit[0] = 6, stocksProfit[1] = 6)
2.	(stocksProfit[1] = 6, stocksProfit[0] = 6)
3.	(stocksProfit[2] = 3, stocksProfit[3] = 9)
4.	(stocksProfit[3] = 9, stocksProfit[2] = 3)
5.	(stocksProfit[3] = 9, stocksProfit[4] = 3)
6.	(stocksProfit[4] = 3, stocksProfit[3] = 9)
The first 2 pairs are the same, as are the last 4. There are only 2 distinct pairs of stocks: (3, 9) and (6, 6).

class Result {

    /*
     * Complete the 'stockPairs' function below.
     *
     * The function is expected to return an INTEGER.
     * The function accepts following parameters:
     *  1. INTEGER_ARRAY stocksProfit
     *  2. LONG_INTEGER target
     */

    public static int stockPairs(List<Integer> stocksProfit, long k) {
    // Write your code here
        int[] arr = stocksProfit.stream().mapToInt(i->i).toArray();
        int N = stocksProfit.size();
    int result = 0;
    int j = N-1;
    Arrays.sort(arr);
    int i =0;
        while(i <j) {
            if(arr[i] + arr[j] ==k){
                
           
                while(i <j && arr[i] == arr[i+1]) {
                    i++;
                }
                while(i <j && arr[j] == arr[j-1]) {
                    j--;
                }
                i++;
                j--;
                result +=1;
                
            }
            else if (arr[i] + arr[j] <k) i++;
            else j--;
        }
        return result;
           
    }

}

public class Solution {
    public static void main(String[] args) throws IOException {
        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter bufferedWriter = new BufferedWriter(new FileWriter(System.getenv("OUTPUT_PATH")));

        int stocksProfitCount = Integer.parseInt(bufferedReader.readLine().trim());

        List<Integer> stocksProfit = IntStream.range(0, stocksProfitCount).mapToObj(i -> {
            try {
                return bufferedReader.readLine().replaceAll("\\s+$", "");
            } catch (IOException ex) {
                throw new RuntimeException(ex);
            }
        })
            .map(String::trim)
            .map(Integer::parseInt)
            .collect(toList());

        long target = Long.parseLong(bufferedReader.readLine().trim());

        int result = Result.stockPairs(stocksProfit, target);

        bufferedWriter.write(String.valueOf(result));
        bufferedWriter.newLine();

        bufferedReader.close();
        bufferedWriter.close();
    }
}

34. Minimum Sum

Given an array of integers, perform some number k of operations. Each operation consists of removing an element from the array, dividing it by 2 and inserting the ceiling of that result back into the array. Minimize the sum of the elements in the final array.
 
Example:
nums = [10, 20, 7] 
k = 4 
 
Pick	Pick/2	Ceiling	Result
Initial array	 	 	[10, 20, 7]
7	3.5	4	[10, 20, 4]
10	5	5	[5, 20, 4]
20	10	10	[5, 10, 4]
10	5	5	[5, 5, 4]
Table of Operations
                          
 
The sum of the final array is 5 + 5 + 4 = 14, and that sum is minimal.
 
Function Description
Complete the function minSum in the editor below.
 
minSum has the following parameters:
    int nums[n]:  an array of integers, indexed 0 to n-1
    int k:  an integer
Returns
    int:  the minimum sum of the array after k steps
 
Constraints
•	1 ≤ n ≤ 105
•	1 ≤ num[i] ≤ 104 (where 0 ≤ i < n)
•	1 ≤ k ≤ 2*106
 
Input Format For Custom Testing



Sample Case 0
Sample Input For Custom Testing
STDIN    Function
-----    --------
1    →   nums[] size n = 1
2    →   nums = [2]
1    →   k = 1
Sample Output
1
Explanation
 
In the first operation, the number 2 is reduced to 1.
Sample Case 1
Sample Input For Custom Testing
STDIN    Function
-----    --------
2    →   nums[] size n = 2
2    →   nums = [2, 3]
3
1    →   k = 1
Sample Output
4
Explanation
 
In the first operation, either of the numbers may be reduced.
•	If the number 2 gets reduced to 1, the sum of the array is 4.
•	If the number 3 gets reduced to 2 (3 divided by 2 equals 1.5, ceil(1.5) = 2), the sum of the array is 4.
 
The minimum sum of the array after one operation is 4.

class Result {

    /*
     * Complete the 'minSum' function below.
     *
     * The function is expected to return an INTEGER.
     * The function accepts following parameters:
     *  1. INTEGER_ARRAY num
     *  2. INTEGER k
     */

    public static int minSum(List<Integer> num, int k) {
      PriorityQueue<Integer> pq = new PriorityQueue<>(Collections.reverseOrder());
      pq.addAll(num);
      while(k > 0){
          int temp = (int) Math.ceil((double)pq.poll()/2);
          pq.add(temp);
          k--;
      }
      
      int sum=0;
      while(!pq.isEmpty()){
          sum += pq.poll();
      }
      
      return sum;

    }

}

public class Solution {
    public static void main(String[] args) throws IOException {
        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter bufferedWriter = new BufferedWriter(new FileWriter(System.getenv("OUTPUT_PATH")));

        int numCount = Integer.parseInt(bufferedReader.readLine().trim());

        List<Integer> num = IntStream.range(0, numCount).mapToObj(i -> {
            try {
                return bufferedReader.readLine().replaceAll("\\s+$", "");
            } catch (IOException ex) {
                throw new RuntimeException(ex);
            }
        })
            .map(String::trim)
            .map(Integer::parseInt)
            .collect(toList());

        int k = Integer.parseInt(bufferedReader.readLine().trim());

        int result = Result.minSum(num, k);

        bufferedWriter.write(String.valueOf(result));
        bufferedWriter.newLine();

        bufferedReader.close();
        bufferedWriter.close();
    }
}


35. Custom Sorted Array
In an array, elements at any two indices can be swapped in a single operation called a move. For example, if the array is arr = [17, 4, 8], swap arr[0] = 17 and arr[2] = 8 to get arr' = [8, 4, 17] in a single move. Determine the minimum number of moves required to sort an array such that all of the even elements are at the beginning of the array and all of the odd elements are at the end of the array.
 
Example
arr = [6, 3, 4, 5]
 
The following four arrays are valid custom-sorted arrays:
•	a = [6, 4, 3, 5]
•	a = [4, 6, 3, 5]
•	a = [6, 4, 5, 3]
•	a = [4, 6, 5, 3]
 
The most efficient sorting requires 1 move: swap the 4 and the 3.
 
Function Description 
Complete the function moves in the editor below.
 
moves has the following parameter(s):
    int arr[n]:  an array of positive integers
Returns
    int: the minimum number of moves it takes to sort an array of integers with all even elements at earlier indices than any odd element
 
Note: The order of the elements within even or odd does not matter.
 
Constraints
•	2 ≤ n ≤ 105
•	1 ≤ arr[i] ≤ 109, where 0 ≤ i < n.
•	It is guaranteed that array a contains at least one even and one odd element.
 
Input Format for Custom Testing
Sample Case 0
Sample Input 0
STDIN    Function
-----    -------
4    →   arr[] size n = 4
13   →   arr = [13, 10, 21, 20]
10
21
20
 
Sample Output 0
1
 
Explanation 0
Swap arr[0] and arr[3] to get the custom-sorted array arr' = [20, 10, 21, 13] in 1 move.
 
Sample Case 1
Sample Input 1
STDIN    Function
-----    --------
5    →   arr[] size n = 5
8    →   arr = [8, 5, 11, 4, 6]
5
11
4
6
 
Sample Output 1
2
 
Explanation 1
Perform the following moves on the array:
1.	Swap arr[1] and arr[3] to get the array arr' = [8, 4, 11, 5, 6].
2.	Swap arr[2] and arr[4] to get the array arr'' = [8, 4, 6, 5, 11].
 
It took two moves to get a valid custom-sorted array. This is minimal.

class Result {

    /*
     * Complete the 'moves' function below.
     *
     * The function is expected to return an INTEGER.
     * The function accepts INTEGER_ARRAY arr as parameter.
     */

    public static int moves(List<Integer> arr) {
        int n = arr.size();
        int even_count = 0;
        
        for(int val: arr) {
            if(val%2 == 0) {
                even_count += 1;
            }
        }
        
        int res = 0;
        for(int i=0; i<even_count; i++) {
            int val = arr.get(i);
            
            if(val%2 == 1) {
                res++;
            }
        }
        
        return res;
    }

}
public class Solution {
    public static void main(String[] args) throws IOException {
        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter bufferedWriter = new BufferedWriter(new FileWriter(System.getenv("OUTPUT_PATH")));

        int arrCount = Integer.parseInt(bufferedReader.readLine().trim());

        List<Integer> arr = IntStream.range(0, arrCount).mapToObj(i -> {
            try {
                return bufferedReader.readLine().replaceAll("\\s+$", "");
            } catch (IOException ex) {
                throw new RuntimeException(ex);
            }
        })
            .map(String::trim)
            .map(Integer::parseInt)
            .collect(toList());

        int result = Result.moves(arr);

        bufferedWriter.write(String.valueOf(result));
        bufferedWriter.newLine();

        bufferedReader.close();
        bufferedWriter.close();
    }
}


public static int moves(List<Integer> arr) {
    // Write your code here
            long evenCount = arr.stream().filter(i->i%2==0).count();
            long oddCount = arr.stream().filter(i->i%2!=0).count();
            int ans =0;
            for(int i = 0;i< evenCount;i++){
                    if(arr.get(i)%2!=0){
                        ans ++;
                    }
                }
            return ans;
    }

 public static int moves(List<Integer> arr) {
    
    int minimumSwapcount =0;
    
    int evenNumberCount=0;
    
    for (Integer num :  arr){
        if(num%2==0){
           if(arr.get(evenNumberCount)%2==1){
               minimumSwapcount++;
           }
           evenNumberCount++;
        }   
    }
     
    return minimumSwapcount;
    
    }

}



36. Degree of an array
Given an array of integers, its degree is defined as the number of occurrences of the element that occurs most frequently in the array. Given a list of integers, determine two properties:
1.	the degree of the array
2.	the length of the shortest sub-array that shares that degree
 
Example
arr = [1, 2, 1, 3, 2]
 
The array has a degree of 2 based on the occurrences of values 1 and 2. The subarray of degree 2 based on the 1's is [1, 2, 1] and based on 2's is [2, 1, 3, 2]. Their lengths are 3 and 4, so the shortest is length 3. Return the shortest length.
 
Function Description 
Complete the function degreeOfArray in the editor below. The function must return an integer denoting the minimum size of the subarray such that the degree of the subarray is equal to the degree of the array.
 
degreeOfArray has the following parameter(s):
    int arr[n]:  an array of integers indexed from 0 to n-1
 
Return
    int:  the minimum size of the subarrays that have a degree equal to the degree of the array
 
Constraints
•	2 ≤ n ≤ 105
•	1 ≤ arr[i]≤ 106
 
Input Format For Custom Testing
Sample Case 0
Sample Input
STDIN    Function
-----    --------
5    →   arr[] size n = 5
1    →   arr = [1, 2, 2, 3, 1]
2
2
3
1
Sample Output
2
Explanation
The array arr has a degree of 2 based on elements values 1 and 2 because each occurs two times. The subarrays with a degree of 2 are:
•	[1, 2, 2, 3, 1], which has a length of 5.
•	[2, 2], which has a length of 2.
 
Return minimum( 2, 5 ) = 2
Sample Case 1
Sample Input
STDIN    Function
_____    ________
6    →   arr[] size n = 6
1    →   arr = [1, 1, 2, 1, 2, 2]
1
2
1
2
2
Sample Output
4
Explanation
The array arr has a degree of 3 based on elements values 1 and 2 because each occurs three times. Subarrays with a degree of 3 are:
•	[1, 1, 2, 1], which has a length of 4.
•	[2, 1, 2, 2], which has a length of 4.
 
Return minimum(4, 4) = 4

class Result {

    /*
     * Complete the 'degreeOfArray' function below.
     *
     * The function is expected to return an INTEGER.
     * The function accepts INTEGER_ARRAY arr as parameter.
     */

    public static int degreeOfArray(List<Integer> arr) {
    // Write your code here
        Map<Integer,Integer> map1 = new HashMap<>(); 
        Map<Integer,Integer> map2 = new HashMap<>();
        Map<Integer,Integer> map3 = new HashMap<>();
        int result = arr.size();
        for(int i=0;i<arr.size();i++){
            int temp = arr.get(i);
            if(map1.get(temp) == null){
                map1.put(temp,i);
            }
            map2.put(temp,i);
            map3.put(temp,map3.getOrDefault(temp, 0)+1);
        }
        int degree = Collections.max(map3.values());
        for(int i:map3.keySet()){
            if(map3.get(i)==degree){
                result = Math.min(result,map2.get(i)- map1.get(i)+1);
            }
        }
        
        return result;
    }

}

public class Solution {
    public static void main(String[] args) throws IOException {
        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter bufferedWriter = new BufferedWriter(new FileWriter(System.getenv("OUTPUT_PATH")));

        int arrCount = Integer.parseInt(bufferedReader.readLine().trim());

        List<Integer> arr = IntStream.range(0, arrCount).mapToObj(i -> {
            try {
                return bufferedReader.readLine().replaceAll("\\s+$", "");
            } catch (IOException ex) {
                throw new RuntimeException(ex);
            }
        })
            .map(String::trim)
            .map(Integer::parseInt)
            .collect(toList());

        int result = Result.degreeOfArray(arr);

        bufferedWriter.write(String.valueOf(result));
        bufferedWriter.newLine();

        bufferedReader.close();
        bufferedWriter.close();
    }
}

public static int degreeOfArray(List<Integer> arr) {
        Map<Integer, Integer> map = new HashMap<>();
        Map<Integer, Integer> start = new HashMap<>();
        
        int degree = 0;
        int res = Integer.MAX_VALUE;
        
        for(int i=0; i<arr.size(); i++) {
            int a = arr.get(i);
            
            if(start.containsKey(a)) {
                map.put(a, map.get(a)+1);
            }
            else {
                start.put(a, i);
                map.put(a, 1);
            }
            
            if(map.get(a) > degree) {
                degree = map.get(a);
                res = i-start.get(a) + 1;
            }
            else if(map.get(a) == degree) {
                res = Math.min(res, (i -  start.get(a) + 1));
            }
        }
        
        // System.out.println(map);
        // System.out.println(start);
        
        return res;
    }


public static int degreeOfArray(List<Integer> arr) {
    // Write your code here
        HashMap<Integer, Integer> freq = new HashMap<>();
        for (int i : arr) {
            if (!freq.containsKey(i)) {
                freq.put(i, 0);
            }
            freq.put(i, freq.get(i) + 1);
        }
        // Get degree.
        int degree = -1;
        for (Map.Entry<Integer, Integer> entry : freq.entrySet()) {
            if (degree < entry.getValue()) {
                degree = entry.getValue();
            }
        }
        // Find min range
        int result = arr.size() + 1;
        for (Map.Entry<Integer, Integer> entry : freq.entrySet()) {
            if (entry.getValue() != degree) {
                continue;
            }
            int range = getRange(entry.getKey(), arr);
            if (result >= range) {
                result = range;
            }
        }
        return result;
    }


37. The Jungle Book

There are a number of animal species in the jungle.  Each species has one or more predators that may be direct or indirect.   Species X is said to be a predator of species Y if at least one of the following is true:
 
•	Species X is a direct predator of species Y.
•	If  species X is a direct predator of species Z, and Z is a direct predator of  Y , then species X is an indirect predator of species Y.  Indirect predation is transitive through any number of levels.
 
Each species has a maximum of 1 direct predator.  No two species will ever be mutual predators, and no species is a predator of itself.  Determine the minimum number of groups that must be formed to so that no species is grouped with its predators, direct or indirect.
 
Example
predators = [-1, 8, 6, 0, 7, 3, 8, 9, -1, 6]
 
Each position in predators represents a species and each element represents a predator of that species, or -1 if there are none. The graph of predation is below using zero based indexing. All labels are the indices within predators:
 
 
 
From the graph, a possible grouping is:
	[0,8]
	[3,1,6]
	[5,2,9]
	[7]
	[4]
A minimum of 5 groups are needed to satisfy all conditions.
 
Function Description 
Complete the function minimumGroups in the editor below.
 
minimumGroups has the following parameter(s):
    int predators[n]:  an array of integers where predator[i] represents the direct predator of the ith species or -1 if there is none.
Returns:
    int: the minimum number of groups formed given the rule that none of the species will associate with its predators
Constraints
•	1 ≤ n ≤ 103
•	-1 ≤ predators[i] < n
•	predators[i] ≠ i
 
Input Format for Custom Testing
Sample Case 0
 
Sample Input 0
STDIN    Function
-----    --------
3    →   predators[] size n = 3
-1   →   predators = [-1, 0, 1]  
0
1
 
Sample Output 0
3
 
Explanation 0
 
Each species has the following predators:
 
1.	Species 0 has no predators.
2.	Species 1's direct predator is species 0 and it has no indirect predators.
3.	Species 2's direct predator is species 1 and its indirect predator is species 0.
 
The animals form a minimum of three species groups:  [0], [1], [2].
 
Sample Case 1
Sample Input 1
STDIN    Function
-----    --------
4    →   predators[] size n = 4
1    →   predators = [1, -1, 3, -1]
-1
3
-1
 
Sample Output 1
2
 
Explanation 1
 
 
Each species has the following predators:
 
1.	Species 0's direct predator is species 1 and it has no indirect predators.
2.	Species 1 has no predators.
3.	Species 2's direct predator is species 3 and it has no indirect predators.
4.	Species 3 has no predators.
 
The animals form a minimal two species groups: [0, 2] and [1, 3].
 
class Result {

    /*
     * Complete the 'minimumGroups' function below.
     *
     * The function is expected to return an INTEGER.
     * The function accepts INTEGER_ARRAY predators as parameter.
     */

    public static int minimumGroups(List<Integer> predators) {
        // parent, [children]
        Map<Integer, List<Integer>> map = new HashMap<>();
        
        for(int i=0; i<predators.size(); i++) {
            List<Integer> children = map.getOrDefault(predators.get(i), 
                                                         new ArrayList<>());
            
            children.add(i);
            
            map.put(predators.get(i), children);
        }
        
        List<Integer> li = map.getOrDefault(-1, new ArrayList<>());
        Queue<Integer> q = new LinkedList<>();
        
        for(Integer i: li) {
            q.add(i);
        }
        q.add(null);
        
        int res = 0;
        
        while(q.peek() != null) {
            
            while(q.peek() != null) {
                int key = q.poll();
                li = map.getOrDefault(key, new ArrayList<>());
                
                for(Integer i: li) {
                    q.add(i);
                }
            }
            
            q.add(null);
            q.poll();
            
            res++;
        }
        
        return res;
    }

}

public class Solution {
    public static void main(String[] args) throws IOException {
        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter bufferedWriter = new BufferedWriter(new FileWriter(System.getenv("OUTPUT_PATH")));

        int predatorsCount = Integer.parseInt(bufferedReader.readLine().trim());

        List<Integer> predators = IntStream.range(0, predatorsCount).mapToObj(i -> {
            try {
                return bufferedReader.readLine().replaceAll("\\s+$", "");
            } catch (IOException ex) {
                throw new RuntimeException(ex);
            }
        })
            .map(String::trim)
            .map(Integer::parseInt)
            .collect(toList());

        int result = Result.minimumGroups(predators);

        bufferedWriter.write(String.valueOf(result));
        bufferedWriter.newLine();

        bufferedReader.close();
        bufferedWriter.close();
    }
}

public static int minimumGroups(List<Integer> predators) {
    // Write your code here
        int minGroups=0;
        Map<Integer, List<Integer>> speciesMap= new HashMap<>();
        Queue<Integer> queue= new LinkedList<>();
        for(int i=0;i< predators.size();i++){
            int predator= predators.get(i);
            if(predator==-1){
                queue.offer(i);
            } else {
                List<Integer> group= new ArrayList<>();
                if(speciesMap.containsKey(predator)){
                    group= speciesMap.get(predator);
                }
                group.add(i);
                speciesMap.put(predator, group);
            }
        }
        while(!queue.isEmpty()){
            minGroups++;
            int size= queue.size();
            for(int i=0;i<size;i++){
                int c= queue.poll();
                if(speciesMap.containsKey(c)){
                    for(int el: speciesMap.get(c)){
                        queue.offer(el);
                    }
                }
            }
        }
        
        return minGroups;
        
    }

}
















38. Maximum Substring

A substring is a contiguous sequence of characters within a string. Given a string determine the alphabetically maximum substring.
 
Example
s = 'baca'
 
The unique substrings: ['b', 'ba', 'bac', 'baca', 'a', 'ac', 'aca', 'c', 'ca']
Arranging the substrings alphabetically: ['a', 'ac', 'aca', 'b', 'ba', 'bac', 'baca', 'c', 'ca']
The maximum substring alphabetically: 'ca'
 
Function Description
Complete the function maxSubstring in the editor below.
 
maxSubstring has the following parameter(s):
    string s:  a string
 
Returns
    string: the maximum substring in s
 
Constraints
•	1 ≤ length of s ≤ 100
•	all characters of s are in the range ascii[a-z]
 
Input Format for Custom Testing
Sample Case 0
Sample Input
STDIN     Function
-----     -----
ba     →  s = 'ba'
 
Sample Output
ba
 
Explanation
s = 'ba'
The alphabetically-ordered set of unique substrings of s is ['a', 'b', 'ba'].
 
Sample Case 1
Sample Input
STDIN     Function
-----     -----
aaa    →  s = 'aaa'
 
Sample Output
aaa
 
Explanation
s = 'aaa'
The alphabetically-ordered set of unique substrings of s is ['a', 'aa', 'aaa'].
 
Sample Case 2
Sample Input
STDIN     Function
-----     -----
banana →  s = 'banana'
 
Sample Output
nana
 
Explanation
s = 'banana'
The alphabetically-ordered set of unique substrings of s is ['a', 'an', 'ana', 'anan', 'anana', 'b', 'ba', 'ban', 'bana', 'banan', 'banana', 'n', 'na', 'nan', 'nana'].
 
class Result {

    /*
     * Complete the 'maxSubstring' function below.
     *
     * The function is expected to return a STRING.
     * The function accepts STRING s as parameter.
     */

    public static String maxSubstring(String s) {
         String ans=s;
        for(int i=0;i<s.length();i++){
              if(s.substring(i).compareTo(ans)>0)
              {
                  ans=s.substring(i);
              }
          }
          return ans;
    }

}
public class Solution {
    public static void main(String[] args) throws IOException {
        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter bufferedWriter = new BufferedWriter(new FileWriter(System.getenv("OUTPUT_PATH")));

        String s = bufferedReader.readLine();

        String result = Result.maxSubstring(s);

        bufferedWriter.write(result);
        bufferedWriter.newLine();

        bufferedReader.close();
        bufferedWriter.close();
    }
}













39. Balanced array
Given an array of numbers, find the index of the smallest array element (the pivot), for which the sums of all elements to the left and to the right are equal. The array may not be reordered.
 
Example
arr=[1,2,3,4,6]
 
•	the sum of the first three elements, 1+2+3=6. The value of the last element is 6. 
•	Using zero based indexing, arr[3]=4 is the pivot between the two subarrays.
•	The index of the pivot is 3.
 
Function Description 
Complete the function balancedSum in the editor below.
 
balancedSum has the following parameter(s):
    int arr[n]:  an array of integers
Returns:
    int: an integer representing the index of the pivot
 
Constraints
•	3 ≤ n ≤ 105
•	1 ≤ arr[i] ≤ 2 × 104, where 0 ≤ i < n
•	It is guaranteed that a solution always exists.
Input Format for Custom Testing
Sample Case 0
Sample Input 0
STDIN     Function Parameters
-----     ------------------- 
4      →  arr[] size n = 4
1      →  arr = [1, 2, 3, 3] 
2
3
3
 
Sample Output 0
2
 
Explanation 0
•	The sum of the first two elements, 1+2=3. The value of the last element is 3. 
•	Using zero based indexing, arr[2]=3 is the pivot between the two subarrays.
•	The index of the pivot is 2.
Sample Case 1
Sample Input 1
STDIN     Function Parameters
-----     -------------------
3      →  arr[] size n = 3 
1      →  arr = [1, 2, 1] 
2
1
 
Sample Output 1
1
 
Explanation 1
•	The first and last elements are equal to 1. 
•	Using zero based indexing, arr[1]=2 is the pivot between the two subarrays.
•	The index of the pivot is 1.
 




















40. Prefix Hierarchy

Given a list of names, determine the number of names in that list for which a given query string is a prefix. The prefix must be at least 1 character less than the entire name string.
 
Example
names = ['jackson', 'jacques', 'jack']
query = ['jack']
 
The complete query string 'jack' is a prefix of jackson but not of jacques or jack. The prefix cannot contain the entire name string, so 'jack' does not qualify.
 
Function Description 
Complete the function findCompletePrefixes in the editor below. The function must return an array of integers that each denotes the number of names strings for which a query string is a prefix.
 
findCompletePrefixes has the following parameter(s):
    string names[n]:  an array of name strings
    string query[q]:  an array of query strings
 
Returns:
    int[q]: each value[i] is the answer to query[i]
Constraints
•	1 ≤ n ≤ 20000
•	2 ≤ length of names[i], query[i] ≤ 30,
•	1 ≤ sum of the lengths of all names[i] ≤ 5 x 105
•	1 ≤ q ≤ 200
 
Input Format For Custom Testing
Sample Case 0
Sample Input 0
STDIN         Function
-----         --------
10       →    names[] size n = 10
steve    →    names = ['steve','stevens','danny','steves','dan','john','johnny','joe','alex','alexander']
stevens
danny
steves
dan
john
johnny
joe
alex
alexander
5        →    query[] size q = 5
steve    →    query = ['steve','alex','joe','john','dan']
alex
joe
john
dan
Sample Output 0
2
1
0
1
1
Explanation 0
Query 1: steve appears as a prefix in two strings: stevens and steves.
Query 2: alex appears as a prefix in one string: alexander.
Query 3: joe does not appear as a prefix in any string.
Query 4: john appears as a prefix in one string: johnny.
Query 5: dan appears as a prefix in one string: danny.
















41. Merge 2 array
Given two sorted arrays, merge them to form a single, sorted array with all items in non-decreasing order.
 
Example
a = [1, 2, 3]
b = [2, 5, 5]
 
Merge the arrays to create array c as follows:
	a[0] < b[0] → c = [a[0]] = [1]
	a[1] = b[0] → c = [a[0], b[0]] = [1, 2]
	a[1] < b[1] → c = [a[0], b[0], a[1]] = [1, 2, 2]
	a[2] < b[1] → c = [a[0], b[0], a[1], a[2]]= [1, 2, 2, 3]
	No more elements in a → c = [a[0], b[0], a[1], a[2], b[1], b[2]] = [1, 2, 2, 3, 5, 5]
Elements were alternately taken from the arrays in the order given, maintaining precedence.
 
Function Description 
Complete the function mergeArrays in the editor below.
 
mergeArrays has the following parameter(s):
    int a[n]:  a sorted array of integers 
   int b[n]:  a sorted array of integers
 
Returns
    int[n]: an array of all the elements from both input arrays in non-decreasing order
 
Constraints
•	1 < n < 5 × 105
•	0 ≤ a[i], b[i] ≤ 109, where 0 ≤ i < n
 
Input Format for Custom Testing
Sample Case 0
Sample Input 0
STDIN      Function
-----      --------
4      →   a[] size n = 4
1      →   a = [1, 5, 7, 7]
1
5
7
7
4      →   b[] size n = 4
0      →   b = [0, 1, 2, 3]
1
2
3
 
Sample Output 0
0
1
1
2
3
5
7
7
 
Explanation
 
The mergedArray function returns the following merged, non-decreasing array: [ 0, 1, 1, 2, 3, 5, 7, 7 ]
Sample Case 1
Sample Input 1
STDIN      Function
-----      --------
5      →   a[] size n = 5
2      →   a = [2, 4, 5, 9, 9]
4
5
9
9
5      →   b[] size n = 5
0      →   b = [0, 1, 2, 3, 4]
1
2
3
4
 
Sample Output 1
0
1
2
2
3
4
4
5
9
9
 
Explanation
 
The mergedArray function returns the following merged, non-decreasing array: [0, 1, 2, 2, 3, 4, 4, 5, 9, 9]










42. Device Name system

Generate unique names for devices in a residential IoT (Internet of Things) system. The system should follow these rules:
•	If a device name is already in use, append an integer to make it unique. The integer starts at 1 and increments by 1 for each subsequent request for the same name.
•	Process each request in order and return an array of unique device names.
 
Example
n = 6 
devicenames = ['switch', 'tv', 'switch', 'tv', 'switch', 'tv']
 
The result is ['switch', 'tv', 'switch1', 'tv1', 'switch2', 'tv2'].
 
Function Description 
Complete the function deviceNamesSystem in the editor with the following parameter(s):
    string devicenames[n]:  an array of device name strings in the order requested.
 
Returns
    string[n]: an array of string device names in the order assigned
 
 
Constraints
•	1 ≤ n ≤ 104 
•	1 ≤ length of devicenames[i] ≤ 20
•	devicenames[i] contains only lowercase English letters in the range ascii[a-z].
Input Format for Custom Testing
Sample Case 0
Sample Input
STDIN        Function 
-----        -------- 
4        →   devicenames[] size n = 4
mixer    →   devicenames=["mixer","toaster","mixer","tv"] 
toaster
mixer
tv
 
Sample Output 0
mixer
toaster
mixer1
tv
 
Explanation 0
•	devicenames[0] = "mixer" is unique. uniqueDevicename[0]="mixer"
•	devicenames[1] = "toaster" is unique. uniqueDevicename[1]="toaster"
•	devicenames[2] = devicenames[0]. Add 1 at the end the previous unique device name "mixer", uniqueDevicename[2]="mixer1"
•	devicenames[3] = "tv" is unique. uniqueDevicename[3]="tv"
•	uniqueDevicenames = ["mixer", "toaster", "mixer1", "tv"]
 
Sample Case 1
Sample Input
STDIN     Function 
-----     -------- 
2    →    devicenames[] size n = 2 
tv   →    devicenames=["tv","lamp"] 
lamp
 
Sample Output 1
tv
lamp
 
Explanation 1
 
•	devicenames[0] = "tv" is unique. uniqueDevicename[0]="tv"
•	devicenames[1] = "lamp" is unique. uniqueDevicename[1]="lamp"
•	uniqueDevicenames = ["tv", "lamp"]
Sample Case 2
Sample Input
STDIN     Function
-----     --------
4     →   devicenames[] size n = 4
lamp  →   devicenames=["lamp","lamp","tv","lamp"] 
lamp
tv
lamp
 
Sample Output 2
lamp
lamp1
tv
lamp2
Explanation 2
 
•	devicenames[0] = "lamp" is unique. uniqueDevicename[0]="lamp"
•	devicenames[1] = devicenames[0]. Add 1 at the end the previous unique device name "lamp", uniqueDevicename[2]="lamp1"
•	devicenames[2] = "tv" is unique. uniqueDevicename[2]="tv"
•	devicenames[3] = devicenames[1]. Increment by 1 the number at the end of the previous unique device name "lamp1", uniqueDevicename[3]="lamp2"
•	uniqueDevicenames = ["lamp", "lamp1", "tv", "lamp2"]

class Result {

    /*
     * Complete the 'deviceNamesSystem' function below.
     *
     * The function is expected to return a STRING_ARRAY.
     * The function accepts STRING_ARRAY devicenames as parameter.
     */

    public static List<String> deviceNamesSystem(List<String> devicenames) {
        // Write your code here

        // time -> O(n)
        // space -> O(n)

        // create a set for unique device names
        Map<String, Integer> devices = new HashMap<>();
        List<String> deviceCount = new ArrayList<>();
       
        // add the device to the map
        for(String device : devicenames) {
            if(!devices.containsKey(device)) {
                devices.put(device, 0);
            }
        }

        // loop through input list and update the values stored in the map 
        for(int i = 0; i < devicenames.size(); i++) {
            String deviceName = devicenames.get(i);

            if(devices.containsKey(deviceName) && devices.get(deviceName) != 0) {
                deviceCount.add(deviceName + devices.get(deviceName));
            } else{
                deviceCount.add(deviceName);
            }
            
            devices.put(deviceName, devices.get(deviceName) + 1);
        }

        return deviceCount;

    }

}
public class Solution {
    public static void main(String[] args) throws IOException {
        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter bufferedWriter = new BufferedWriter(new FileWriter(System.getenv("OUTPUT_PATH")));

        int devicenamesCount = Integer.parseInt(bufferedReader.readLine().trim());

        List<String> devicenames = new ArrayList<>();

        for (int i = 0; i < devicenamesCount; i++) {
            String devicenamesItem = bufferedReader.readLine();
            devicenames.add(devicenamesItem);
        }

        List<String> result = Result.deviceNamesSystem(devicenames);

        for (int i = 0; i < result.size(); i++) {
            bufferedWriter.write(result.get(i));

            if (i != result.size() - 1) {
                bufferedWriter.write("\n");
            }
        }

        bufferedWriter.newLine();

        bufferedReader.close();
        bufferedWriter.close();
    }
}


 public static List<String> deviceNamesSystem(List<String> devicenames) {
    // Write your code here
        List<String> result = new ArrayList<>();
        Map<String,Integer> map = new HashMap<>();
        int index = 0;
        
        for (String s : devicenames) {
            if (map.containsKey(s)){
                map.put(s, map.get(s) + 1);
                index = map.get(s);
                result.add(s + index);
            } else {
                map.put(s, 0);
                result.add(s);
            }
        }
        
        return result;
    }

}

public static List<String> deviceNamesSystem(List<String> devicenames) {
        List<String> answer = new ArrayList<>();
        Map<String, Integer> deviceMap = new HashMap<>();
        for(String name : devicenames) {
            int count = deviceMap.getOrDefault(name, 0);
            String value = name;
            if(count != 0) value+=count;
            deviceMap.put(name, 1+count);
            answer.add(value);
        }
        return answer;
    }







44. Featured Product
An e-commerce site tracks the purchases made each day. The product that is purchased the most one day is the featured product for the following day. If there is a tie for the product purchased most frequently, those product names are ordered alphabetically ascending and the last name in the list is chosen.
 
Example
products = [‘redShirt’, ‘greenPants’, ‘redShirt’, ‘orangeShoes’, ‘blackPants’, ‘blackPants’]
 
•	greenPants and orangeShoes were purchased once.
•	redShirt and blackPants were each purchased 2 times on the given day.
•	After ordering the products alphabetically ascending, redShirt is the last product listed.
•	redShirt is the featured product for the following day.
 
Function Description
Complete the function featuredProduct in the editor below.
 
featuredProduct has the following parameter(s):
    string products[n]:  an array of strings where each represents a purchased product
 
Returns:
    string: the name of the featured product
 
Constraints
•	1 ≤ n ≤ 104
 
Input Format For Custom Testing
Sample Case 0
Sample Input
STDIN            Function 
-----            ----- 
10           →   products[] size n = 10
yellowShirt  →   products = ['yellowShirt', 'redHat', 'blackShirt', 'bluePants', 'redHat',\
redHat                       'pinkHat', 'blackShirt', 'yellowShirt', 'greenPants', 'greenPants']
blackShirt
bluePants
redHat
pinkHat
blackShirt
yellowShirt
greenPants
greenPants
Sample Output
yellowShirt
Explanation
•	pinkHat and bluePants were each purchased 1 time.
•	yellowShirt, blackShirt, redHat, and greenPants were each purchased 2 times.
•	yellowShirt is the last product listed after ordering the products alphabetically ascending: blackShirt, greenPants, redHat, yellowShirt
•	yellowShirt is the featured product.
 
Sample Case 1
Sample Input
STDIN       Function
-----       -----
8          →  products[] size n = 8
greenShirt →  products = ['greenShirt', 'bluePants', 'redShirt', 'blackShoes', 'redPants', 'redPants', 'whiteShirt', 'redShirt']
bluePants
redShirt
blackShoes
redPants
redPants
whiteShirt
redShirt
Sample Output
redShirt
Explanation
•	greenShirt, bluePants, blackShoes, and whiteShirt were each purchased 1 time.
•	redShirt and redPants were each purchased 2 times.
•	redShirt is the last product listed after ordering the products alphabetically ascending: redPants, redShirt.
•	redShirt is the featured product for the following day.

class Result {

    /*
     * Complete the 'featuredProduct' function below.
     *
     * The function is expected to return a STRING.
     * The function accepts STRING_ARRAY products as parameter.
     */

    public static String featuredProduct(List<String> products) {
    Map <String, Integer> map = new TreeMap<>(Collections.reverseOrder());
        for(String vote: products){
            if(map.containsKey(vote)){
                map.put(vote, map.get(vote)+1);
            } else {
                map.put(vote,1);
            }
        }
        return (Collections.max(map.entrySet(), Map.Entry.comparingByValue()).getKey());

    }

}
public class Solution {
    public static void main(String[] args) throws IOException {
        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter bufferedWriter = new BufferedWriter(new FileWriter(System.getenv("OUTPUT_PATH")));

        int productsCount = Integer.parseInt(bufferedReader.readLine().trim());

        List<String> products = IntStream.range(0, productsCount).mapToObj(i -> {
            try {
                return bufferedReader.readLine();
            } catch (IOException ex) {
                throw new RuntimeException(ex);
            }
        })
            .collect(toList());

        String result = Result.featuredProduct(products);

        bufferedWriter.write(result);
        bufferedWriter.newLine();

        bufferedReader.close();
        bufferedWriter.close();
    }
}

public static String featuredProduct(List<String> products) {
   Map<String,Integer> map =
                    new HashMap<String, Integer>();
        for (String str : products)
        {
            if (map.keySet().contains(str))
                map.put(str, map.get(str) + 1);
            else
                map.put(str, 1);
        }
        
        int maxValueInMap = 0;
        String winner = "";
        Map.Entry<String,Integer> entry;
        for (String key : map.keySet())
        {
            
            Integer val = map.get(key);
            
            if (val > maxValueInMap)
            {
                maxValueInMap = val;
                winner = key;
            }

            else if (val == maxValueInMap &&
                winner.compareTo(key) < 0)
                winner = key;
        }
        return winner;
    }
}



45. Password creation
A password manager wants to create new passwords using two strings given by the user, then combined to create a harder-to-guess combination. Given two strings, interleave the characters of the strings to create a new string. Beginning with an empty string, alternately append a character from string a and from string b. If one of the strings is exhausted before the other, append the remaining letters from the other string all at once. The result is the new password.
 
Example
If a = 'hackerrank' and b = 'mountain', the result is hmaocuknetrariannk.
 
Function Description
Complete the function newPassword in the editor below.
 
newPassword has the following parameter(s):
    string a:  the first string
    string b:  the second string
 
Returns:
    string: the merged string
 
Constraints
•	1 ≤ lengths of a, b ≤ 25000
•	All characters in a and b are lowercase letters in the range ascii['a'-'z']
 
Input Format For Custom Testing
Sample Case 0
Sample Input
STDIN     Function
-----     -----
abc    →  a = 'abc'
def    →  b = 'def'
 
Sample Output
adbecf
 
Explanation
 
Alternately taking characters from each string, the merged string is 'adbecf'.
Sample Case 1
 
Sample Input
STDIN     Function
-----     -----
cat     →  a = 'cat'
rabbit  →  b = 'rabbit'
 
Sample Output
craatbbit
 
Explanation
 
Alternately taking characters from each string, the merged string is 'craatbbit'. After a is exhausted, the remainder of b is concatenated to get 'craatbbit'.
class Result {

    /*
     * Complete the 'newPassword' function below.
     *
     * The function is expected to return a STRING.
     * The function accepts following parameters:
     *  1. STRING a
     *  2. STRING b
     */

    public static String newPassword(String a, String b) {
   String[] array1 = a.split("");
        String[] array2 = b.split("");
        StringBuilder sb = new StringBuilder("");
        for(int i=0; i< array1.length; i++) {
            sb.append(array1[i]);
            if(i < array2.length) {
                sb.append(array2[i]);
            }
        }
        if(array2.length > array1.length) {
            for(int i= array1.length; i< array2.length; i++) {
                sb.append(array2[i]);
            }
        } 
        return sb.toString();    

    }

}

ublic class Solution {
    public static void main(String[] args) throws IOException {
        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter bufferedWriter = new BufferedWriter(new FileWriter(System.getenv("OUTPUT_PATH")));

        String a = bufferedReader.readLine();

        String b = bufferedReader.readLine();

        String result = Result.newPassword(a, b);

        bufferedWriter.write(result);
        bufferedWriter.newLine();

        bufferedReader.close();
        bufferedWriter.close();
    }
}

46. Eliminate Substring
Given a string s with uppercase English letters, remove all occurrences of the string AWS until no more remain. After each removal, the prefix and suffix strings are concatenated. Return the final string. If the final string is empty, return -1 as a string.
 
Example 
s = "AWAWSSG"
•	AWAWSSG -> AWSG
•	AWSG -> G
 
Return the final string, G.
 
Function Description
Complete the function getFinalString in the editor below.
 
The function getFinalString has the following parameter:
    string s[n]:  a string of uppercase English characters
 
Return
    string: the string after removing all occurrences of "AWS" from the given string or "-1"
 
Constraints
•	1 ≤ |s| ≤ 105
•	The string contains only uppercase English letters.  
Input Format For Custom Testing
Sample Case 0
Sample Input For Custom Testing
STDIN      FUNCTION
-----      ----------
AAWSWS  →  string s = "AAWSWS"
Sample Output
-1
Explanation
 
•	AAWSWS -> AWS
•	AWS -> null
Sample Case 1
Sample Input For Custom Testing
STDIN       FUNCTION
-----       ----------
ABCDWS  →   string s = "ABCDWS"   
Sample Output
ABCDWS
Explanation
 
There is no AWS in s.

class Result {

    /*
     * Complete the 'getFinalString' function below.
     *
     * The function is expected to return a STRING.
     * The function accepts STRING s as parameter.
     */

    public static String getFinalString(String s) {
    // Write your code here
    StringBuilder sb = new StringBuilder(s);
    String s1 = "AWS";
    int length =s1.length(), index = sb.indexOf(s1);
        while(index!=-1) {
            sb.delete(index, index+length);
            index = sb.indexOf(s1);
        }
        return sb.length()>0?sb.toString():"-1";
    }

}

public class Solution {
    public static void main(String[] args) throws IOException {
        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter bufferedWriter = new BufferedWriter(new FileWriter(System.getenv("OUTPUT_PATH")));

        String s = bufferedReader.readLine();

        String result = Result.getFinalString(s);

        bufferedWriter.write(result);
        bufferedWriter.newLine();

        bufferedReader.close();
        bufferedWriter.close();
    }
}

47. Find sequence of sum

Given three integers, i, j, and k, a sequence sum to be the value of i + (i + 1) + (i + 2) + (i + 3) + … + j + (j − 1) + (j − 2) + (j − 3) + … + k (increment from i until it equals j, then decrement from j until it equals k). Given values i, j, and k, calculate the sequence sum as described.
 
Example
i = 5
j = 9
k = 6
 
Sum all the values from i to j and back to k: 5 + 6 + 7 + 8 + 9 + 8 + 7 + 6 = 56.
 
Function Description 
Complete the function getSequenceSum in the editor below.
 
getSequenceSum has the following parameter(s):
    int i, int j, int k:  three integers
 
Return
    long: the value of the sequence sum
 
Constraints
•	-108 ≤ i, j, k ≤ 108
•	i, k ≤ j
 
Input Format For Custom Testing
Sample Case 0
Sample Input 0
STDIN    Function
-----    --------
0    →   i = 0    
5    →   j = 5
-1   →   k = -1
 
Sample Output 0
24
 
Explanation 0
i = 0
j = 5
k = -1
0 + 1 + 2 + 3 + 4 + 5 + 4 + 3 + 2 + 1 + 0 + -1 = 24
 
Sample Case 1
Sample Input 1
STDIN      Function
-----      --------
-5    →    i = -5
-1    →    j = -1
-3    →    k = -3
 
Sample Output 1
-20
 
Explanation 1
i = -5
j = -1
k = -3
-5 + -4 + -3 + -2 + -1 + -2 + -3 = -20

public class Solution {


    // Complete the getSequenceSum function below.
    static long getSequenceSum(int i, int j, int k) {
        long sum = 0;
        for(int seqi = i; seqi < j ; seqi++ ){
            sum += seqi;
        }
        for(int seqj = j; seqj > k; seqj--){
            sum += seqj;
        }
        return sum + k;

    }

    public static void main(String[] args) throws IOException {
        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter bufferedWriter = new BufferedWriter(new FileWriter(System.getenv("OUTPUT_PATH")));

        int i = Integer.parseInt(bufferedReader.readLine().trim());

        int j = Integer.parseInt(bufferedReader.readLine().trim());

        int k = Integer.parseInt(bufferedReader.readLine().trim());

        long res = getSequenceSum(i, j, k);

        bufferedWriter.write(String.valueOf(res));
        bufferedWriter.newLine();

        bufferedReader.close();
        bufferedWriter.close();
    }
}

static long getSequenceSum(int i, int j, int k) {
        long sum = 0;
        for(int x= i; x<j; x++){
            sum+=x;
        }
        for(int y = j; y>=k; y--){
            sum+=y;
        }
        return sum;
    }














48. Compare String

Given three strings, concatenate the strings in alphabetically increasing order to create a single string.
 
For example, given firstString = one, secondString = two, thirdString = three, concatenated in ascending alphabetical order, the result = onethreetwo.
 
Function Description
 
Complete the function compareStrings in the editor below.
 
compareStrings has the following parameter(s):
    string firstString:  a string
    string secondString:  a string
    string thirdString:  a string
Returns:
    string: the concatenated string
Constraints
•	1 ≤ the lengths of firstString, secondString, thirdString ≤ 105
•	Each of the strings consists of lowercase English characters, ascii[a-z].
 
Input Format For Custom Testing
Sample Case 0
Sample Input For Custom Testing
STDIN            Function
-----            --------
hack        →    firstString = 'hack'
hacker      →    secondString = 'hacker'
hackerrank  →    thirdString = 'hackerrank'
Sample Output
hackhackerhackerrank
Explanation
In alphabetically increasing order, the given strings are hack, hacker, hackerrank.
Sample Case 1
Sample Input For Custom Testing
STDIN         Function
-----         --------
klmno    →    firstString = 'klmno'
abcde    →    secondString = 'abcde'
fghij    →    thirdString = 'fghij'
Sample Output
abcdefghijkmlno
Explanation
In alphabetically increasing order, the given strings are abcde, fghij, klmno.
Sample Case 2
Sample Input For Custom Testing
STDIN      Function
-----      --------
ab    →    firstString = 'ab'
ac    →    secondString = 'ac'
aa    →    thirdString = 'aa'
Sample Output
aaabac
 
In alphabetically increasing order, the given strings are aa, ab, ac

class Result {

    public static String compareStrings(String firstString, String secondString, String thirdString) {
        String returnString="";
        String strArr[] = {firstString, secondString, thirdString};
        boolean isSorted = false;
        while(!isSorted){
            isSorted =true;
            for(int i =0; i<strArr.length-1; i++){
                if(strArr[i].compareTo(strArr[1+i])>0){
                    isSorted = false;
                    String temp = strArr[i];
                    strArr[i]=strArr[i+1];
                    strArr[i+1]=temp;
                }
            }
        }
        for(String str:strArr){
            returnString+=str;
        }
        return returnString;
    }

}
public class Solution {
    public static void main(String[] args) throws IOException {
        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter bufferedWriter = new BufferedWriter(new FileWriter(System.getenv("OUTPUT_PATH")));

        String firstString = bufferedReader.readLine();

        String secondString = bufferedReader.readLine();

        String thirdString = bufferedReader.readLine();

        String result = Result.compareStrings(firstString, secondString, thirdString);

        bufferedWriter.write(result);
        bufferedWriter.newLine();

        bufferedReader.close();
        bufferedWriter.close();
    }
}


 public static String compareStrings(String firstString, String secondString, String thirdString) {
    // Write your code here
        int a = firstString.compareTo(secondString);
        int b = firstString.compareTo(thirdString);
        int c = secondString.compareTo(thirdString);
        String s1 = new String(firstString);
        String s2 = new String(secondString);
        String s3 = new String(thirdString);
        String temp = "";
        
        while(a>0||b>0||c>0){
            if (a>0){
                temp = s1;
                s1 = s2;
                s2 = temp;
            }
            else{
                if (c>0){
                    temp = s2;
                    s2 = s3;
                    s3 = temp;
                }
            }
            a = s1.compareTo(s2);
            b = s1.compareTo(s3);
            c = s2.compareTo(s3);
            //System.out.println(a+" "+b+" "+c);
            //System.out.println(s1+s2+s3);
        }
        return (s1+s2+s3);
    }

}


















49. Price check
There is a shop with old-style cash registers. Rather than scanning items and pulling the price from a database, the price of each item is typed in manually. This method sometimes leads to errors. Given a list of items and their correct prices, compare the prices to those entered when each item was sold. Determine the number of errors in selling prices.
 
Example
products = ['eggs', 'milk', 'cheese'] 
productPrices = [2.89, 3.29, 5.79]
productSold = ['eggs', 'eggs', 'cheese', 'milk'] 
soldPrice = [2.89, 2.99, 5.97, 3.29]. 
 
          Price
Product   Actual  Expected  Error
eggs      2.89    2.89
eggs      2.99    2.89      1
cheese    5.97    5.79      1
milk      3.29    3.29
 
The second sale of eggs has a wrong price, as does the sale of cheese. There are 2 errors in pricing.
 
Function Description 
Complete the function priceCheck in the editor below.
 
priceCheck has the following parameter(s):
    string products[n]:  each products[i] is the name of an item for sale
    string productPrices[n]:  each productPrices[i] is the price of products[i]
    string productSold[m]:  each productSold[j] is the name of a product sold
    float soldPrice[m]:  each soldPrice[j] contains the sale price recorded for productSold[j].
 
Returns:
    int: the number of sale prices that were entered incorrectly
 
Constraints
•	1 ≤ n ≤ 105
•	1 ≤ m ≤ n
•	1.00 ≤ productPrices[i], soldPrice[j] ≤ 100000.00, where 0 ≤ i < n, and 0 ≤ j < m
Input Format for Custom Testing
Sample Case 0
Sample Input 0
STDIN        Function 
-----        -------- 
4        →   products[] size n = 4
rice     →   products=['rice', 'sugar', 'wheat', 'cheese']
sugar
wheat
cheese
4        →  productPrices[] size n = 4
16.89    →  productPrices=[16.89, 56.92, 20.89, 345.99]
56.92
20.89
345.99
2        →  productSold[] size m = 2
rice     →  productSold =['rice', 'cheese']
cheese
2        →  soldPrice[] size m = 2
18.99    →  soldPrice =[18.99, 400.89]
400.89
Sample Output 0
2
Explanation 0
 
          Price
Product   Actual  Expected  Error
rice       18.99   16.89    1
cheese    400.89  345.99    1
 
The sales of rice and cheese were at the wrong prices. So, the number of sale prices that were entered incorrectly is 2.
 
 
Sample Case 1
Sample Input 1
STDIN         Function
-----         --------
3          →  n = 3 .The size of the products array
chocolate  →  products=[chocolate, cheese, tomato] 
cheese
tomato
3          →  n = 3 .The size of the productPrices array 
15.00      →  productPrices=[15.00, 300.90, 23.44] 
300.90 
23.44
3          →  m = 3 .The size of the productSold array 
chocolate  →  productSold=[chocolate, cheese, tomato]
cheese
tomato
3          →  m = 3 .The size of the soldPrice array 
15.00      →  soldPrice =[15, 300.90,10.00] 
300.90 
10.00
Sample Output 1
1
Explanation 1
 
            Price
Product     Actual   Expected  Error
chocolate    15.00    15.00
cheese      300.90   300.90
tomato       10.00    23.44    1
 
Only the tomato sale does not match the price list. So, the number of sale prices that were entered incorrectly is 1.

class Result {

    /*
     * Complete the 'priceCheck' function below.
     *
     * The function is expected to return an INTEGER.
     * The function accepts following parameters:
     *  1. STRING_ARRAY products
     *  2. FLOAT_ARRAY productPrices
     *  3. STRING_ARRAY productSold
     *  4. FLOAT_ARRAY soldPrice
     */

    public static int priceCheck(List<String> products, List<Float> productPrices, List<String> productSold, List<Float> soldPrice) {
    // Write your code here
        int numErrors = 0;
        HashMap<String,Float> map = new HashMap<String,Float>();
        for(int i = 0;i<products.size();i++){
            map.put(products.get(i),productPrices.get(i));
        }

        for(int j = 0;j<productSold.size();j++){
            if(!map.get(productSold.get(j)).equals(soldPrice.get(j))){
                numErrors++;
            }
        }

        return numErrors;

    }

}

public class Solution {
    public static void main(String[] args) throws IOException {
        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter bufferedWriter = new BufferedWriter(new FileWriter(System.getenv("OUTPUT_PATH")));

        int productsCount = Integer.parseInt(bufferedReader.readLine().trim());

        List<String> products = IntStream.range(0, productsCount).mapToObj(i -> {
            try {
                return bufferedReader.readLine();
            } catch (IOException ex) {
                throw new RuntimeException(ex);
            }
        })
            .collect(toList());

        int productPricesCount = Integer.parseInt(bufferedReader.readLine().trim());

        List<Float> productPrices = IntStream.range(0, productPricesCount).mapToObj(i -> {
            try {
                return bufferedReader.readLine().replaceAll("\\s+$", "");
            } catch (IOException ex) {
                throw new RuntimeException(ex);
            }
        })
            .map(String::trim)
            .map(Float::parseFloat)
            .collect(toList());

        int productSoldCount = Integer.parseInt(bufferedReader.readLine().trim());

        List<String> productSold = IntStream.range(0, productSoldCount).mapToObj(i -> {
            try {
                return bufferedReader.readLine();
            } catch (IOException ex) {
                throw new RuntimeException(ex);
            }
        })
            .collect(toList());

        int soldPriceCount = Integer.parseInt(bufferedReader.readLine().trim());

        List<Float> soldPrice = IntStream.range(0, soldPriceCount).mapToObj(i -> {
            try {
                return bufferedReader.readLine().replaceAll("\\s+$", "");
            } catch (IOException ex) {
                throw new RuntimeException(ex);
            }
        })
            .map(String::trim)
            .map(Float::parseFloat)
            .collect(toList());

        int result = Result.priceCheck(products, productPrices, productSold, soldPrice);

        bufferedWriter.write(String.valueOf(result));
        bufferedWriter.newLine();

        bufferedReader.close();
        bufferedWriter.close();
    }
}
 public static int priceCheck(List<String> products, List<Float> productPrices, List<String> productSold, List<Float> soldPrice) {
    // Write your code here
    int errors = 0;
    for(int i = 0; i < products.size(); i++){
        for(int j = 0; j < productSold.size(); j++){
            if(products.get(i).equals(productSold.get(j))){
                if(productPrices.get(i).compareTo(soldPrice.get(j))!=0){
                    errors++;
                }
            }
        }
    }
    return errors;
    }







50. Coding Friends
Sam and Kelly are programming buddies. Kelly resolves to practice more as Sam is ahead initially. They each solve a number of problems daily. Find the minimum number of days for Kelly to have solved more problems than Sam. If Kelly cannot surpass return -1.
 
Example
samDaily = 3
kellyDaily = 5
difference = 5
 
Initially, Sam has solved difference problems more than Kelly. Each day, they solve samDaily and kellyDaily problems each.
Day 1: samSolved = difference + samDaily = 5 + 3 = 8
            kellySolved = kellyDaily = 5
Day 2: samSolved = 8 + 3 = 11
            kellySolved = 5 + 5 = 10
Day 3: samSolved = 11 + 3 = 14
            kellySolved = 10 + 5 = 15
 
Sam is 5 problems ahead of Kelly and they solve 3 and 5 problems a day. Sam will be ahead by only 3 after the first day, 1 after the second, and Kelly will pass Sam on day 3.
 
Function Description 
Complete the function minNum in the editor below.
 
minNum has the following parameter(s):
    samDaily:  Number of problems Sam solves in a day
    kellyDaily:  Number of problems Kelly solves in a day
    difference:  Number of problems Sam is ahead to begin
Return
    int: the minimum number of days needed by Kelly to exceed Sam, or -1 if it is impossible
 
Constraints
•	1 ≤ samDaily, kellyDaily ≤ 100
•	0 ≤ difference ≤ 100
Input Format For Custom Testing
Sample Case 0
Sample Input 0
STDIN     Function
-----     --------
3    →    samDaily = 3
5    →    kellyDaily = 5
1    →    difference = 1
 
Sample Output 0
1
 
Explanation 0
Sam is 1 problem ahead of Kelly to begin. After 1 day passes, Kelly will have solved 5 problems while Sam will have only solved 1 + 3 = 4 problems.
Sample Case 1
Sample Input 1
STDIN     Function
-----     --------
4    →    samDaily = 4
5    →    kellyDaily = 5
1    →    difference = 1
 
Sample Output 1 
2
 
Explanation 1
Sam is 1 problem ahead of Kelly to begin. After 1 day passes, Kelly will have solved 5 problems while Sam will have also solved 1 + 4 = 5 problems. On the second day, Kelly will surpass Sam, 5 + 5 > 1 + 4 + 4.

class Result {
    public static int minNum(int samDaily, int kellyDaily, int difference) {
    // Write your code here
        if(samDaily == kellyDaily){
            return -1;
        }

        int sam = 0;
        int kelly = 0;
        int idx = 0;
        while(kelly <= sam){
            if(idx == 0){
               sam+=samDaily+difference; 
            } else {
                sam+=samDaily;
            }
            kelly+=kellyDaily;
            idx++;
        }
        return idx;
    }

}

public class Solution {
    public static void main(String[] args) throws IOException {
        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter bufferedWriter = new BufferedWriter(new FileWriter(System.getenv("OUTPUT_PATH")));

        int samDaily = Integer.parseInt(bufferedReader.readLine().trim());

        int kellyDaily = Integer.parseInt(bufferedReader.readLine().trim());

        int difference = Integer.parseInt(bufferedReader.readLine().trim());

        int result = Result.minNum(samDaily, kellyDaily, difference);

        bufferedWriter.write(String.valueOf(result));
        bufferedWriter.newLine();

        bufferedReader.close();
        bufferedWriter.close();
    }
}






51. Subarray sum
A subarray is any contiguous block of an array's elements. Given an array of integers, find the sum of all elements of all subarrays of that array.
 
Example
For example, a three element array [4, 5, 6] can be made into the following subarrays:
 
    1 element subarrays: [4], [5], [6]
    2 element subarrays: [4,5], [5,6]
    3 element subarrays: [4, 5, 6]
 
The sum of all subarrays is 4 + 5 + 6 + (4+5) + (5+6) + (4 + 5 + 6) = 50.
 
Function Description
 
subarraySum has the following parameter(s):
    int arr[n]: an array of integers to process
 
Returns:
    int: an integer representing the sum of all subarrays of the given array
 
Constraints
•	1 ≤ n ≤ 2 × 105
•	1 ≤ arr[i] ≤ 103, where 0 ≤ i < n
Input Format For Custom Testing
Input from stdin will be processed as follows and passed to the function:
 
The first line contains an integer n, the number of elements in arr.
Each of the n subsequent lines contains an integer describing arr[i] where 0 ≤ i < n.
Sample Case 0
 
Sample Input
STDIN     Function
-----     -----
3      →  arr[] size n = 3
1      →  arr = [1, 2, 3]
2
3
 
Sample Output
20
 
Explanation
We find the following six subarrays:
1.	[1]: The sum of all the elements of this subarray is 1.
2.	[2]: The sum of all the elements of this subarray is 2.
3.	[3]: The sum of all the elements of this subarray is 3.
4.	[1, 2]: The sum of all the elements of this subarray is 1 + 2 = 3.
5.	[2, 3]: The sum of all the elements of this subarray is 2 + 3 = 5.
6.	[1, 2, 3]: The sum of all the elements of this subarray is 1 + 2 + 3 = 6.
The sum of all the elements of all the subarrays is 1 + 2 + 3 + 3 + 5 + 6 = 20.
Sample Case 1
 
Sample Input
STDIN     Function
-----     -----
3      →  arr[] size n = 3
1      →  arr = [1, 1, 1]
1
1
 
Sample Output
10
 
Explanation
We find the following six subarrays:
1.	[1]: The sum of all the elements of this subarray is 1.
2.	[1]: The sum of all the elements of this subarray is 1.
3.	[1]: The sum of all the elements of this subarray is 1.
4.	[1, 1]: The sum of all the elements of this subarray is 1 + 1 = 2.
5.	[1, 1]: The sum of all the elements of this subarray is 1 + 1 = 2.
6.	[1, 1, 1]: The sum of all the elements of this subarray is 1 + 1 + 1 = 3.
The sum of all the elements of all the subarrays is 1 + 1 + 1 + 2 + 2 + 3 = 10.

class Result {

    public static long subarraySum(List<Integer> arr) {
    // Write your code here
        int n = arr.size();
        long sum = 0;
        for(int i=0; i<n; i++) {
            long num = n-i;
            int e = arr.get(i);
            sum += e * (i+1) * num;
        }
        return sum;
    }

}
public class Solution {
    public static void main(String[] args) throws IOException {
        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter bufferedWriter = new BufferedWriter(new FileWriter(System.getenv("OUTPUT_PATH")));

        int arrCount = Integer.parseInt(bufferedReader.readLine().trim());

        List<Integer> arr = IntStream.range(0, arrCount).mapToObj(i -> {
            try {
                return bufferedReader.readLine().replaceAll("\\s+$", "");
            } catch (IOException ex) {
                throw new RuntimeException(ex);
            }
        })
            .map(String::trim)
            .map(Integer::parseInt)
            .collect(toList());

        long result = Result.subarraySum(arr);

        bufferedWriter.write(String.valueOf(result));
        bufferedWriter.newLine();

        bufferedReader.close();
        bufferedWriter.close();
    }
}




52. Stay Positive
Consider an array of integers and a non-zero positive starting value x. A running sum is calculated by adding each element of the array to x consecutively. Determine the minimum value of x such that the running sum is at least 1 after every iteration.
 
Examples
arr = [-4, 3, 2, 1]
 
Let starting value x = 5
Running sums:
5 + (-4) = 1
1 + 3 = 4
4 + 2 = 6
6 + 1 = 7.
 
There is no value smaller than 5 that satisfies the condition.
 
arr = [3, -6, 5, -2, 1]
 
If the starting value is 4, running sums are [7, 1, 6, 4, 5]. This is the minimum starting value.
 
arr = [5]
 
The starting value of x is 1.
 
Function Description 
Complete the minStart function in the editor below. 
 
minStart has the following parameter(s):
    int arr[n]: an array of integers to sum
Return
    long:  the minimum initial value
 
Constraints
•	1 ≤ n ≤ 105
•	-106 ≤ arr[i][ ]≤ 106
 
Input Format For Custom Testing
Locked stub code in the editor reads the following input from stdin and passes it to the function:
The first line contains an integer, n, the number of elements in arr.
Each line i of the n subsequent lines (where 0 ≤ i < n) contains an integer, arr[i][.]
Sample Case 0
Sample Input For Custom Testing
STDIN     Function
-----     --------
5    →    arr[] size n = 5
-5   →    arr = [-5, 4, -2, 3, 1]
4
-2
3
1
Sample Output
6
Explanation
Starting with a value of 6 gives the following sums: 6 + -5 = 1 → 1 + 4 = 5 → 5 + -2 = 3 → 3 + 3 = 6 → 6 + 1 = 7. Any initial value less than 6 will fail at the first element.
Sample Case 1
Sample Input For Custom Testing
STDIN     Function
-----     --------
10    →   arr[] size n = 10
-5    →   arr = [-5, 4, -2, 3, 1, -1, -6, -1, 0, 5]
4
-2
3
1
-1
-6
-1
0
5
Sample Output
8
Explanation
Any initial value less than 8 will fail. For example, the running sums for an initial value of 7 is [2, 6, 4, 7, 8, 7, 1, 0, 0, 5].

class Result {

    public static long minHealth(List<Integer> dungeon) {
    // Write your code here
        long sum = 0;
        long min = 0;
        for(int val : dungeon) {
            sum += val;
            if(min > sum) min = sum;
        }
        long result = min * -1 + 1;
        return result;
    }

}

public class Solution {
    public static void main(String[] args) throws IOException {
        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter bufferedWriter = new BufferedWriter(new FileWriter(System.getenv("OUTPUT_PATH")));

        int dungeonCount = Integer.parseInt(bufferedReader.readLine().trim());

        List<Integer> dungeon = new ArrayList<>();

        for (int i = 0; i < dungeonCount; i++) {
            int dungeonItem = Integer.parseInt(bufferedReader.readLine().trim());
            dungeon.add(dungeonItem);
        }

        long result = Result.minHealth(dungeon);

        bufferedWriter.write(String.valueOf(result));
        bufferedWriter.newLine();

        bufferedReader.close();
        bufferedWriter.close();
    }
}



53. Maximum occurring character
Create a function that:
1.	Accepts a string as input
2.	Identifies the character that appears most frequently in the string
3.	Returns this character
Requirements:
•	The string will contain only ASCII characters from the ranges ('a'-'z', 'A'-'Z', '0'-'9').
•	The function must be case-sensitive ('A' and 'a' are different characters).
•	If there is a tie for the most frequent character, return the one that appears first in the string.
Example
findMostFrequentChar("abcABCabc") should return 'a'
findMostFrequentChar("1223334444") should return '4'
 
In the first example, characters 'a', 'b', and 'c' occur twice, and 'a' appears first.
 
Function Description
 
Complete the function maximumOccurringCharacter in the editor with the following parameter:
    string text:  the string to analyze
Returns
    char: the most common character that appears first in the string
 
Constraints
•	10 ≤ length of text ≤ 104
Input Format For Custom Testing
The first line contains a string, text, denoting the text to be analyzed.
Sample Case 0
Sample Input For Custom Testing
STDIN           Function 
-----           -------- 
helloworld  →   text = "helloworld"
Sample Output
l
Explanation
The character 'l' occurs 3 times.
Sample Case 1
Sample Input For Custom Testing
STDIN                                                     Function
-----                                                     --------
abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz →   text = "abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz"
Sample Output
a
Explanation
All characters in the string 'abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz' occur exactly twice. As 'a' has the lowest index, it is the answer.

class Result {

    public static char maximumOccurringCharacter(String text) {
    // Write your code here
        Map<Character, Integer> countMap = new HashMap<>();
        int currentMax = 1;
        for(char c : text.toCharArray()){
            if(countMap.containsKey(c)){
                countMap.put(c, countMap.get(c)+1);
                if(currentMax<countMap.get(c))
                    currentMax = countMap.get(c);
            }
            else{
                countMap.put(c, 1);
            }
        }
        for(char c : text.toCharArray()){
            if(countMap.get(c) == currentMax)
                return c;
        }
        return ' ';
    }

}
public class Solution {
    public static void main(String[] args) throws IOException {
        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter bufferedWriter = new BufferedWriter(new FileWriter(System.getenv("OUTPUT_PATH")));

        String text = bufferedReader.readLine();

        char result = Result.maximumOccurringCharacter(text);

        bufferedWriter.write(String.valueOf(result));
        bufferedWriter.newLine();

        bufferedReader.close();
        bufferedWriter.close();
    }
}

public static char maximumOccurringCharacter(String text) {
    // Write your code herege
        Map<Character, Integer> occur = new LinkedHashMap<>();
        int maxoccur = 0;
        for(char ch : text.toCharArray()) {
            Integer oc = occur.get(ch);
            if(oc == null)oc= 0;
            oc++;
            if(oc > maxoccur) maxoccur = oc;
            occur.put(ch, oc);
        }
        for(char ch : occur.keySet()) if(maxoccur == occur.get(ch)) return ch;
        return ' ';
    }








54. Find the factor
Determine the factors of a number (i.e., all positive integer values that evenly divide into a number) and then return the pth element of the list, sorted ascending. If there is no pth element, return 0.
 
Example
n = 20
p = 3
 
The factors of 20 in ascending order are {1, 2, 4, 5, 10, 20}. Using 1-based indexing, if p = 3, then 4 is returned. If p > 6, 0 would be returned.
 
Function Description 
Complete the function pthFactor in the editor.
 
pthFactor has the following parameter(s):
    long int n:  the integer whose factors are to be found
    long int p:  the index of the factor to be returned
 
Returns:
    long int: the value of the pth integer factor of n or, if there is no factor at that index, then 0 is returned
 
Constraints
•	1 ≤ n ≤ 1015
•	1 ≤ p ≤ 109
 
Input Format for Custom Testing
Input from stdin will be processed as follows and passed to the function.
 
The first line contains an integer n, the number to factor.
The second line contains an integer p, the 1-based index of the factor to return.
 
Sample Case 0
Sample Input 0
STDIN      Function
-----      --------
10     →   n = 10
3      →   p = 3
Sample Output 0
5
Explanation 0
Factoring n = 10 results in {1, 2, 5, 10}. Return the p = 3rd factor.
Sample Case 1
Sample Input 1
STDIN      Function 
-----      -------- 
10     →   n = 10 
5      →   p = 5
Sample Output 1
0
Explanation 1
Factoring n = 10 results in {1, 2, 5, 10}. There are only 4 factors and p = 5.
Sample Case 2
Sample Input 2
STDIN      Function
-----      --------
1     →   n = 1
1     →   p = 1
Sample Output 2
1
Explanation 2
Factoring n = 1 results in {1}. The p = 1st factor is returned.

class Result {

    public static long pthFactor(long n, long p) {
    // Write your code here
        List<Long> factors = new ArrayList<>();
        for (int i = 1; i <= Math.sqrt(n); i ++) {
            if (n % i == 0) {
                factors.add(new Long(i));
                if (i != n / i) {
                    factors.add(n / i);
                }
            }
        }
        Collections.sort(factors);
        return factors.size() < p ? 0 : factors.get((int) p - 1);
    }

}

public class Solution {
    public static void main(String[] args) throws IOException {
        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter bufferedWriter = new BufferedWriter(new FileWriter(System.getenv("OUTPUT_PATH")));

        long n = Long.parseLong(bufferedReader.readLine().trim());

        long p = Long.parseLong(bufferedReader.readLine().trim());

        long result = Result.pthFactor(n, p);

        bufferedWriter.write(String.valueOf(result));
        bufferedWriter.newLine();

        bufferedReader.close();
        bufferedWriter.close();
    }
}



55. Fizz Buzz
Given a number n, for each integer i in the range from 1 to n inclusive, print one value per line as follows:
 
•	If i is a multiple of both 3 and 5, print FizzBuzz.
•	If i is a multiple of 3 (but not 5), print Fizz.
•	If i is a multiple of 5 (but not 3), print Buzz.
•	If i is not a multiple of 3 or 5, print the value of i.
 
Function Description
Complete the function fizzBuzz in the editor below.
 
fizzBuzz has the following parameter(s):
    int n:  upper limit of values to test (inclusive)
Returns:    NONE
Prints:
    The function must print the appropriate response for each value i in the set {1, 2, ... n} in ascending order, each on a separate line.
 
Constraints
•	0 < n < 2 × 105
Input Format for Custom Testing
Input from stdin will be processed as follows and passed to the function.
 
The single integer n, the limit of the range to test: [1, 2, ...n].
Sample Case 0
Sample Input
STDIN    Function
-----    --------
15    →  n = 15
 
Sample Output
1     
2
Fizz
4
Buzz
Fizz
7
8
Fizz
Buzz
11
Fizz
13
14
FizzBuzz
 
Explanation
The numbers 3, 6, 9, and 12 are multiples of 3 (but not 5), so print Fizz on those lines.
The numbers 5 and 10 are multiples of 5 (but not 3), so print Buzz on those lines.
The number 15 is a multiple of both 3 and 5, so print FizzBuzz on that line.
None of the other values is a multiple of either 3 or 5, so print the value of i on those lines.
class Result {
    public static void fizzBuzz(int n) {
    for(int i=1; i<=n; i++){
        if(i% 15 == 0){
            System.out.println("FizzBuzz");
        }
        else if(i%3 == 0){
            System.out.println("Fizz");  
        } 
        else if (i % 5 == 0) {
            System.out.println("Buzz");
        }
        else{
            System.out.println(i);
        }
    }

    }

}

public class Solution {
    public static void main(String[] args) throws IOException {
        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));

        int n = Integer.parseInt(bufferedReader.readLine().trim());

        Result.fizzBuzz(n);

        bufferedReader.close();
    }
}
56. Collision Course
There are n particles numbered from 0 to n − 1 arranged in increasing order along the x-axis by their IDs. For instance:
 
All particles are released simultaneously, each traveling indefinitely in a straight line along the positive x-axis at a constant speed. When two particles collide, the faster particle passes through the slower one, and both continue moving without changing speed or direction. Given a list of speeds for particles arranged from left to right by position, compute the number of collisions involving the particle starting at index pos.
 
Example
n=2
speed = [2, 1]
pos = 0
 
The speeds are labeled on the particles. Particle 0 starts at position 0 on the x-axis and moves right at speed[0] = 2 units per second. At seconds 0 through 3, it is at positions [0, 2, 4, 6].
 
Particle 1 starts at position 1 on the x-axis and moves right at speed[1] = 1 unit per second. At seconds 0 through 3, it is at positions [1, 2, 3, 4].
 
Both particles are at position 2 at the same time, resulting in a collision. Particle 0 continues moving faster than particle 1 indefinitely, so they do not collide again. There is one collision.
 
Function Description 
Complete the function collision in the editor with the following parameter(s):
    int speed[n]:  each speed[i] indicates the speed of particle i
    int pos: index of the particle to count collisions for
 
Return
    int: the number of collisions occurring with particle pos
 
Constraints
•	1 ≤ n ≤ 105
•	1 ≤ speed[i] ≤ 109
•	0 ≤ pos < n
 
Input Format for Custom Testing
Sample Case 0
Sample Input 0
STDIN   Function 
-----   -------- 
8    →  speed[] size n = 8
6    →  speed = [6, 6, 1, 6, 3, 4, 6, 8] 
6
1
6
3
4
6
8
2    →  pos =  2
Sample Output 0
2
Explanation 0
n = 8
speed = [6, 6, 1, 6, 3, 4, 6, 8]
pos = 2
 
 

The particles at positions 0 and 1 are moving faster than the one at pos = 2 so they will collide with the particle.
The particle at position pos = 2 is moving slower than the particles at positions 3, 4, 5, 6 and 7, so it will never catch up with them.
 
Sample Case 1
Sample Input 1
STDIN    Function
-----    --------
10    →  speed[] size n = 10
8     →  speed = [8, 3, 6, 3, 2, 2, 4, 8, 1, 6]      
3
6
3
2
2
4
8
1
6
7     →  pos = 7
Sample Output 1
2
Explanation 1
n = 10
speed = [8, 3, 6, 3, 2, 2, 4, 8, 1, 6]
pos = 7
 
 
The particle at position pos = 7 will only collide with particles 8 and 9 as it passes them from behind. There are no other particles moving fast enough to collide with particle 7.
Sample Case 2
Sample Input 2
STDIN    Function
-----    --------
6     →  speed[] size n = 6
1     →  speed = [1, 3, 7, 4, 6, 4]       
3 
7 
4 
6 
4
3     →  pos = 3
 
3
Sample Output 2
1
Explanation 2
n = 6
speed = [1, 3, 7, 4, 6, 4]
pos = 3
 
  
 
Particles 0 and 1 are moving slower, so they will never catch up. Particle 3 is moving at less than or equal to the speeds of particles ahead of it, numbers 4 and 5, so it can never catch up. The only collision with particle 3 occurs for particle 2.

class Result {
    public static int collision(List<Integer> speed, int pos) {
    // Write your code here
        int count  = 0;
        int len = speed.size();
        int posSpeed = speed.get(pos);
        for(int i=0; i<len; i++) {
            if (speed.get(i) > posSpeed && i < pos) {
                count++;
            }
            if (speed.get(i) < posSpeed && i > pos) {
                count++;
            }
        }
        return count;

    }

}
public class Solution {
    public static void main(String[] args) throws IOException {
        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter bufferedWriter = new BufferedWriter(new FileWriter(System.getenv("OUTPUT_PATH")));

        int speedCount = Integer.parseInt(bufferedReader.readLine().trim());

        List<Integer> speed = new ArrayList<>();

        for (int i = 0; i < speedCount; i++) {
            int speedItem = Integer.parseInt(bufferedReader.readLine().trim());
            speed.add(speedItem);
        }

        int pos = Integer.parseInt(bufferedReader.readLine().trim());

        int result = Result.collision(speed, pos);

        bufferedWriter.write(String.valueOf(result));
        bufferedWriter.newLine();

        bufferedReader.close();
        bufferedWriter.close();
    }
}



57. Balanced or not
Determine if each string can be balanced within a given number of replacements.
 
A string consists solely of the characters '<' and '>'. The string is considered balanced if every '<' appears before a corresponding '>' character. The characters do not have to be adjacent, and each '<' and '>' forms a unique pair that cannot be part of another pair.
 
To balance a string, any '>' character can be replaced with the sequence '<>'. Given an array of expressions and a corresponding array of maximum replacements, determine if each string can be balanced. Return an array where the ith value is 1 if expressions[i] can be balanced using up to maxReplacements[i] replacements, or 0 otherwise.
 
Example
expressions = ['<<>>', '<>', '<><>', '>>', '<<>', '><><']
maxReplacements = [0, 1, 2, 2, 2, 2]
 
Process a series of expressions and their corresponding maxReplacements. Each of the first three expressions is balanced already. The string expressions[3] = '>>' can be balanced in two moves by replacing each > with a <> to make <><>. Neither of the last two strings can ever be balanced. The answer to return is [1, 1, 1, 1, 0, 0].
 
Function Description
Complete the function balancedOrNot in the editor with the following parameter(s):
    string expressions[n]:  the strings to check
    int maxReplacements[n]:  the maximum number of replacements available for each expressions[i]
 
Returns:
    int[n]: each element[i] contains a 1 if expressions[i] is balanced or a 0 if it is not
 
Constraints
•	1 ≤ n ≤ 102
•	1 ≤ length of expressions[i] ≤ 105
•	0 ≤ maxReplacements[i] ≤ 105
 
Input Format for Custom Testing
Sample Case 0
Sample Input
STDIN     Function
-----     -----
2      →  expressions[] size n = 2
<>>>   →  expressions = ['<>>>', '<>>>>']
<>>>>
2      →  maxReplacements[] size n = 2
2      →  maxReplacements = [2, 2]
2
Sample Output
1
0
Explanation
1.	For the string <>>> with maxReplacements[0] = 2, it becomes balanced after two replacements: <>>> → <><>> → <><><>.  The string was converted in ≤ maxReplacements[0] replacements.  Store a 1 in index 0 of the return array.
2.	For the string <>>>> with maxReplacements[1] = 2, it becomes balanced after three replacements: <>>>> → <><>>> → <><><>> → <><><><>.   There were not enough replacements available, so store a 0 in index 1 of the return array.
 
Return the array [1, 0] as the answer.
Sample Case 1
Sample Input
STDIN     Function
-----     -----
2      →  expressions[] size n = 2
<>     →  expressions = ['<>', '<>><']
<>><
2      →  maxReplacements[] size n = 2
1      →  maxReplacements = [1, 0]
0
Sample Output
1
0
Explanation
1.	For the string <> with maxReplacements[0] = 1, it is already balanced and needs no replacements. Store a 1 in index 0 of the return array.
2.	For the string <>>< with maxReplacements[1] = 0, the string is not balanced. It is impossible to balance the string because it ends in < and because there are 0 replacements available. Store a 0 in index 1 of the return array.
 
Return the array [1, 0] as the answer.
Sample Case 2
Sample Input
STDIN       Function
-----       --------
1        →  expressions[] size n = 1
<<<><><> →  expressions = ['<<<><><>']
1        →  maxReplacements[] size n = 1
2        →  maxReplacements = [2]
Sample Output
0
Explanation
1.	For string <<<><><> with maxReplacements[0] = 2, the string is not balanced. It is impossible to balance because there are more <than >. Store a 0 in index 0 of the return array.
 
Return the array [0] as the answer.

class Result {

    public static List<Integer> balancedOrNot(List<String> expressions, List<Integer> maxReplacements) {
    // Write your code here
        List<Integer> list = new ArrayList<>();
        int n = expressions.size();
        for(int i=0; i<n; i++) {
            String e = expressions.get(i);
            int m = maxReplacements.get(i);
            int m1 = 0;
            Stack<Character> s = new Stack<>();
            for(char c : e.toCharArray()) {
                if('<' == c) s.push(c);
                else if(s.size() != 0) s.pop();
                else m1++;
            }
            if(m1 <= m && s.size() == 0) list.add(1); else list.add(0);
        }
        
        return list;
    }

}
public class Solution {
    public static void main(String[] args) throws IOException {
        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter bufferedWriter = new BufferedWriter(new FileWriter(System.getenv("OUTPUT_PATH")));

        int expressionsCount = Integer.parseInt(bufferedReader.readLine().trim());

        List<String> expressions = IntStream.range(0, expressionsCount).mapToObj(i -> {
            try {
                return bufferedReader.readLine();
            } catch (IOException ex) {
                throw new RuntimeException(ex);
            }
        })
            .collect(toList());

        int maxReplacementsCount = Integer.parseInt(bufferedReader.readLine().trim());

        List<Integer> maxReplacements = IntStream.range(0, maxReplacementsCount).mapToObj(i -> {
            try {
                return bufferedReader.readLine().replaceAll("\\s+$", "");
            } catch (IOException ex) {
                throw new RuntimeException(ex);
            }
        })
            .map(String::trim)
            .map(Integer::parseInt)
            .collect(toList());

        List<Integer> result = Result.balancedOrNot(expressions, maxReplacements);

        bufferedWriter.write(
            result.stream()
                .map(Object::toString)
                .collect(joining("\n"))
            + "\n"
        );

        bufferedReader.close();
        bufferedWriter.close();
    }
}


58. Find the factor

Determine the factors of a number (i.e., all positive integer values that evenly divide into a number) and then return the pth element of the list, sorted ascending. If there is no pth element, return 0.
 
Example
n = 20
p = 3
 
The factors of 20 in ascending order are {1, 2, 4, 5, 10, 20}. Using 1-based indexing, if p = 3, then 4 is returned. If p > 6, 0 would be returned.
 
Function Description 
Complete the function pthFactor in the editor.
 
pthFactor has the following parameter(s):
    long int n:  the integer whose factors are to be found
    long int p:  the index of the factor to be returned
 
Returns:
    long int: the value of the pth integer factor of n or, if there is no factor at that index, then 0 is returned
 
Constraints
•	1 ≤ n ≤ 1015
•	1 ≤ p ≤ 109
 
Input Format for Custom Testing
Input from stdin will be processed as follows and passed to the function.
 
The first line contains an integer n, the number to factor.
The second line contains an integer p, the 1-based index of the factor to return.
 
Sample Case 0
Sample Input 0
STDIN      Function
-----      --------
10     →   n = 10
3      →   p = 3
Sample Output 0
5
Explanation 0
Factoring n = 10 results in {1, 2, 5, 10}. Return the p = 3rd factor.
Sample Case 1
Sample Input 1
STDIN      Function 
-----      -------- 
10     →   n = 10 
5      →   p = 5
Sample Output 1
0
Explanation 1
Factoring n = 10 results in {1, 2, 5, 10}. There are only 4 factors and p = 5.
Sample Case 2
Sample Input 2
STDIN      Function
-----      --------
1     →   n = 1
1     →   p = 1
Sample Output 2
1
Explanation 2
Factoring n = 1 results in {1}. The p = 1st factor is returned.

class Result {
    public static long pthFactor(long n, long p) {
    // Write your code here
    List<Long> list = new ArrayList<>();
   
        for(long i=1;i<=Math.sqrt(n);i++){
            if(n%i==0){
                list.add(i);
                list.add(n/i);
                
            }
        }
        
        Set<Long> set = new HashSet<>(list);
        list.clear();
        list.addAll(set);
        Collections.sort(list);
        
        if(list.size() > (int)(p-1)){
            return list.get((int)(p-1));
        }
        return 0;
    }

}

public class Solution {
    public static void main(String[] args) throws IOException {
        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter bufferedWriter = new BufferedWriter(new FileWriter(System.getenv("OUTPUT_PATH")));

        long n = Long.parseLong(bufferedReader.readLine().trim());

        long p = Long.parseLong(bufferedReader.readLine().trim());

        long result = Result.pthFactor(n, p);

        bufferedWriter.write(String.valueOf(result));
        bufferedWriter.newLine();

        bufferedReader.close();
        bufferedWriter.close();
    }
}

58. Number Complement
The complement of a number is defined here as the number's bitwise inversion from its highest-order 1-bit through its lowest-order bit. For example, the number n = 5 is represented as 000001012 in 8 bit binary. The highest order bit is in the 4's position. The binary complement of n = 1012 is 0102, which is 2 in decimal notation.
 
Function Description 
Complete the function getIntegerComplement in the editor below. The function must return the complement of n as a base 10 integer.
 
getIntegerComplement has the following parameter(s):
    n:  an integer in base 10
 
Constraints
•	0 ≤ n ≤ 105
 
Input Format for Custom Testing
Sample Case 0
Sample Input
50
 
Sample Output 0
13
Explanation 0
5010 in binary is 1100102. Invert each bit in the sequence to get 0011012 = 1310.
Sample Case 1
Sample Input
100
 
Sample Output 1
27
 
Explanation 1
10010 in binary is 11001002. Invert each bit in the sequence to get 00110112 = 2710.

class Result {

    public static int getIntegerComplement(int n) {
    // Write your code here
        String bin = Integer.toBinaryString(n);
        StringBuilder sb = new StringBuilder();
        boolean process = false;
        for (int i = 0; i < bin.length(); i++) {
            char c = bin.charAt(i);

            if (c == '1') {
                process = true;
            }
            if (process) {
                char next = c == '1' ? '0' : '1';
                sb.append(next);
            }
        }
        System.out.println(sb);
        return Integer.parseInt(sb.toString(), 2);
    }

}

public class Solution {
    public static void main(String[] args) throws IOException {
        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter bufferedWriter = new BufferedWriter(new FileWriter(System.getenv("OUTPUT_PATH")));

        int n = Integer.parseInt(bufferedReader.readLine().trim());

        int result = Result.getIntegerComplement(n);

        bufferedWriter.write(String.valueOf(result));
        bufferedWriter.newLine();

        bufferedReader.close();
        bufferedWriter.close();
    }
}



















59. Longest Even length word
Consider a string, sentence, of words separated by spaces where each word is a substring that consists of English alphabetic letters only. Find and return the first word in the sentence that has a length that is both an even number and has the greatest length of all even-length words in the sentence. If there are no even length words in the sentence, return '00'.
 
Example
sentence = "Time to write great code"
 
The lengths of the words are 4, 2, 5, 5, 4, in order. The longest even length words are Time and code. The one that occurs first is Time, the answer to return.
 
Function Description 
Complete the function longestEvenWord in the editor below.

longestEvenWord has the following parameter(s):
    string sentence:  a sentence string
 
Returns:
    string: the first occurrence of a string with maximal even number length, or the string '00' (zero zero) if there are no even length words
 
Constraints
•	1 ≤ length of sentence ≤ 105
•	The sentence string consists of spaces and letters in the range ascii[a-z, A-Z, ] only.
 
Input Format for Custom Testing
Input from stdin will be processed as follows and passed to the function.
 
A single line of space-separated strings denoting sentence.
 
Sample Case 0
Sample Input 0
STDIN                                Function
--------------------------           -------------------------------
It is a pleasant day today    →      sentence = "It is a pleasant day today"

 
Sample Output 0
pleasant
 
Explanation 0
There are three even-length words: It (with length 2), is (2), and pleasant (8).
 
Sample Case 1
Sample Input 1
STDIN                                    Function
------------------------------           ------------------------------- 
You can do it the way you like    →     sentence = "You can do it the way you like"

 
Sample Output 1
like
 
Explanation 1
There are three words of even length: do (with length 2), it (2), and like (4).
 
class Result {

    public static String longestEvenWord(String sentence) {
    // Write your code here
    int length = 0;
    String str = "";
    String [] strArr = sentence.split("\\s+");
    for(String s :strArr){
        //System.out.println(s);
        int strLen = s.length();
        if(strLen%2==0 && strLen>length){
            length=strLen;
            str = s;
        }
    }
    if(length == 0 && strArr.length ==1){
        str = "00";
    }
    return str;

    }

}

public class Solution {
    public static void main(String[] args) throws IOException {
        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter bufferedWriter = new BufferedWriter(new FileWriter(System.getenv("OUTPUT_PATH")));

        String sentence = bufferedReader.readLine();

        String result = Result.longestEvenWord(sentence);

        bufferedWriter.write(result);
        bufferedWriter.newLine();

        bufferedReader.close();
        bufferedWriter.close();
    }
}







60. Slowest Key Press
Engineers have redesigned a keypad used by ambulance drivers in urban areas. In order to determine which key takes the longest time to press, the keypad is tested by a driver. Given the results of that test, determine which key takes the longest to press.
 
Example
keyTimes = [[0, 2], [1, 5], [0, 9], [2, 15]]
 
Elements in keyTimes[i][0] represent encoded characters in the range ascii[a-z] where a = 0, b = 1, ..., z = 25. The second element, keyTimes[i][1] represents the time the key is pressed since the start of the test.   The elements will be given in ascending time order. In the example, keys pressed, in order are 0102[encoded] = abac at times 2, 5, 9, 15.  From the start time, it took 2 - 0 = 2 to press the first key, 5 - 2 = 3 to press the second, and so on. The longest time it took to press a key was key 2, or 'c', at 15 - 9 = 6. 
 
Function Description
Complete the function slowestKey in the editor below.
 
slowestKey has the following parameter(s):
    int keyTimes[n][2]:  the first column contains the encoded key pressed, the second contains the time at which it was pressed
 
Returns:
    char: the key that took the longest time to press
 
Constraints
•	1 ≤ n ≤ 105
•	0 ≤ keyTimes[i][0] ≤ 25 (0 ≤ i < n)
•	1 ≤ keyTimes[i][1] ≤ 108 (0 ≤ i < n)
•	There will only be one key with the worst time.
•	keyTimes is sorted in ascending order of keyTimes[i][1]
 
Input Format For Custom Testing
The first line contains an integer, n, the number of elements in keyTimes. The second line contains the integer 2, the number of columns in each keyTimes[i]. Each line i of the n subsequent lines (where 0 ≤ i < n) contains two space-separated integers, keyTimes[i][0] and keyTimes[i][1].
Sample Case 0
Sample Input For Custom Testing
STDIN    Function
-----    --------
3     →  keyTimes[] size n = 3
2     →  keyTimes[][] size columns = 2, always
0 2   →  keyTimes = [[0, 2], [1, 3], [0, 7]]
1 3
0 7
Sample Output
a
Explanation
The time taken to press 'a' in the worst case is 7 - 3 = 4. To press 'b' the worst case is 3 - 2 = 1.
Sample Case 1
Sample Input For Custom Testing
STDIN    Function
-----    --------
5     →  keyTimes[] size n = 5
2     →  keyTimes[][] size = 2
0 1   →  keyTimes = [[0, 1], [0, 3], [4, 5], [5, 6], [4, 10]]
0 3
4 5
5 6
4 10
Sample Output
e
Explanation
The time taken to press 'a' in the worst case is 3 - 1 = 2, for 'e' is 10 - 6 = 4, and for 'f' is 6 - 5 = 1. The letter 'e' is the slowest key.

class Result {

    public static char slowestKey(List<List<Integer>> keyTimes) {
        int max = Integer.MIN_VALUE;
        int last = 0;
        int ch = 0;
        for(List<Integer> list:keyTimes){
            
                int time = list.get(1) -last;
                if(time > max){
                    ch = list.get(0);
                    max = time;
                }
                
                last = list.get(1);
        }
        
        //System.out.print(ch);
        
        return (char)(ch + (int)'a');

    }

}

public class Solution {
    public static void main(String[] args) throws IOException {
        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter bufferedWriter = new BufferedWriter(new FileWriter(System.getenv("OUTPUT_PATH")));

        int keyTimesRows = Integer.parseInt(bufferedReader.readLine().trim());
        int keyTimesColumns = Integer.parseInt(bufferedReader.readLine().trim());

        List<List<Integer>> keyTimes = new ArrayList<>();

        IntStream.range(0, keyTimesRows).forEach(i -> {
            try {
                keyTimes.add(
                    Stream.of(bufferedReader.readLine().replaceAll("\\s+$", "").split(" "))
                        .map(Integer::parseInt)
                        .collect(toList())
                );
            } catch (IOException ex) {
                throw new RuntimeException(ex);
            }
        });

        char result = Result.slowestKey(keyTimes);

        bufferedWriter.write(String.valueOf(result));
        bufferedWriter.newLine();

        bufferedReader.close();
        bufferedWriter.close();
    }
}








61. Diverse group
A professional society is organizing a conference and needs to form a diverse group of 3 members.
 
The group must meet the following criteria:
•	Diversity Rule: The group must include at least one man and one woman.
•	Distinct Combinations: Two groups are considered distinct if they have at least one different member.
 
You are given:
•	m: The number of eligible men.
•	w: The number of eligible women.
 
Your task is to calculate the total number of distinct ways to select a diverse group of 3 members, following the diversity rule.
 
Example
m = 1
w = 3
There is m = 1 man available and there are w = 3 women. Label them m1, w1, w2, w3 for demonstration. There are 3 possible ways to form a diverse group: (m1, w1, w2), (m1, w1, w3) and (m1, w2, w3). The only other possible permutation is (w1, w2, w3), which does not include a man, so it is invalid.
 
Function Description
Complete the function diverseGroups in the editor with the following parameters:
    int m: the number of men available
    int w: the number of women available
 
Returns
    int: the number of ways to select a diverse group from m men and w women
 
Constraints
•	0 ≤ m, w ≤ 1000
 
Input Format For Custom Testing
The first line contains an integer m, that denotes the number of men.
The second line contains an integer w, that denotes the number of women.
 
Sample Case 0
Sample Input For Custom Testing
STDIN    Function 
-----    --------
3     →  number of men m = 3
0     →  number of women w = 0
Sample Output 0
0
Explanation 0
The number of women is 0 so there is no way to select a diverse group.
Sample Case 1
Sample Input For Custom Testing
STDIN    Function 
-----    -------- 
2     →  number of men m = 2
2     →  number of women w = 2
Sample Output 1
4
Explanation 1
In this case, m = 2 and w = 2. This yields 4 ways to select a diverse group: (m1, w1, w2), (m1, m2, w2), (m2, w1, w2), (m1, m2, w1).

class Result {
    public static int diverseDeputation(int m, int w) {
        if(w ==0)return 0;
        return (m*w*(m+w-2))/2;
    }    

}
public class Solution {
    public static void main(String[] args) throws IOException {
        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter bufferedWriter = new BufferedWriter(new FileWriter(System.getenv("OUTPUT_PATH")));

        int m = Integer.parseInt(bufferedReader.readLine().trim());

        int w = Integer.parseInt(bufferedReader.readLine().trim());

        int result = Result.diverseDeputation(m, w);

        bufferedWriter.write(String.valueOf(result));
        bufferedWriter.newLine();

        bufferedReader.close();
        bufferedWriter.close();
    }
}


 public static int diverseDeputation(int m, int w) {
    // Write your code here       
        if(m==0 || w==0) {
            return 0;
        }        
        
        return m*w*(m+w-2)/2;
    }










62. Circular array
A circular array behaves as if it were connected end-to-end, with the end of the array wrapping around to the start of the array. There are n nodes in the circular array, numbered consecutively from 1 to n.
 
There are m-1 paths from endNode[i] to endNode[i+1], where 0 ≤ i < m-1. The start node is endNode[i] and the end node of the path is endNode[i+1]. For each path, the start node, the end node, and all nodes in between are visited. Determine the node that is visited the most after all of the paths have been traversed. If there are multiple nodes sharing the highest number of visits, select the node with the lower index.
 
Example
n = 3
m = 4
endNode = [1, 3, 2, 3]
 
In the first path, start at endNode[0] = 1 and visit nodes 1, 2, and 3. In the second path, nodes 3, 1, 2, are visited, and in the third, visits are to nodes 2, 3. Nodes 2 and 3 were each visited 3 times. Return the lower numbered node, 2.
 
Function Description
Complete the function circularArray in the editor below.
 
circularArray has the following parameters:
    int n: the length of the circular array.
    int endNode[m]: each element endNode[i] (where 0 ≤ i < m-1) means when starting from position endNode[i], finish at position endNode[i+1].
 
Return
    int: the node number that is visited most; if there are multiple answers, return the minimum one
 
Constraints
•	1 ≤ n ≤ 105
•	2 ≤ m ≤ 105
•	1 ≤ endNode[i] ≤ n ( where  0 ≤ i < m )
•	endNode[i] != endNode[i+1] ( where  0 ≤ i <  m - 1  )
 
Input Format For Custom Testing
The first line contains an integer, n, the number of nodes in the circular array.
The second line contains an integer, m, the number of elements in endNode[].
Each line i of the m subsequent lines (where 0 ≤ i < m) contains an integer, endNode[i].
Sample Case 0
Sample Input
STDIN     Function
-----     -----
10     →  n = 10
4      →  endNode[] size m = 4
1      →  endNode = [1, 5, 10, 5]
5
10
5
 
Sample Output
5
 
Explanation
 
 
Node 5 is the most visited with a total of 3 visits. It appears in the first (1 → 5), second (5 → 10), and third (10 → 5) segments.
Sample Case 1
Sample Input
STDIN     Function
-----     -----
5      →  n = 5
2      →  size of endNode[] m = 2
1      →  endNode = [1, 5]
5
 
Sample Output
1
 
Explanation
 
 
Each node is only visited once. Node 1 is the lowest value of nodes with 1 visit. It appears in the only segment, (1 → 5).

class Result {
    public static int circularArray(int n, List<Integer> endNode) {
        List<Integer> s = new ArrayList<>(), e = new ArrayList<>();
        int highest = 1, n1 = endNode.size();
        for(int i=0; i<n1-1; i++) {
            int p1 = endNode.get(i), p2 = endNode.get(i+1);
            s.add(p1);
            e.add(p2);
        }
        s.sort(null);
        e.sort(null);
        for(int i = 0, j = 0; j< s.size(); j++) {
            if(s.get(j) <= e.get(i)) highest = s.get(j);
            else i++;
        }
        return highest;
    }

}
public class Solution {
    public static void main(String[] args) throws IOException {
        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter bufferedWriter = new BufferedWriter(new FileWriter(System.getenv("OUTPUT_PATH")));

        int n = Integer.parseInt(bufferedReader.readLine().trim());

        int endNodeCount = Integer.parseInt(bufferedReader.readLine().trim());

        List<Integer> endNode = IntStream.range(0, endNodeCount).mapToObj(i -> {
            try {
                return bufferedReader.readLine().replaceAll("\\s+$", "");
            } catch (IOException ex) {
                throw new RuntimeException(ex);
            }
        })
            .map(String::trim)
            .map(Integer::parseInt)
            .collect(toList());

        int result = Result.circularArray(n, endNode);

        bufferedWriter.write(String.valueOf(result));
        bufferedWriter.newLine();

        bufferedReader.close();
        bufferedWriter.close();
    }
}




63. Process tree
A sequence of processes is represented as a tree structure. Each process is numbered sequentially starting from 1. Process number n spawns n new child processes. For example:
•	Process 1 spawns 1 child process.
•	Process 2 spawns 2 child processes.
•	Process 3 spawns 3 child processes.
Given a specific process number, determine the process number of its parent.
 
Example
processNumber = 6 
 
From the diagram, the parent of 6 is 3.
 
 
 
Function Description
Complete the findParent function in the editor with the following parameter(s):
   int processNumber: the process number to query
 
Returns
    int: the process number of the parent
 
Constraints
•	2 ≤ processNumber ≤ 109
Input Format For Custom Testing
The first line contains an integer, processNumber.
Sample Case 0
Sample Input
STDIN     Function
-----     --------
6      →  processNumber = 6
 
Sample Output
3
 
Explanation
Refer to the graph in the problem statement. The child of 1 is 2. Children of 2 are 3 and 4. The children of 3 are 5, 6, and 7. Therefore, the process number of the parent process of the given process is 3. 

class Result {

    public static int findParent(int processNumber) {
    // Write your code here
        int p1 = 1;
        int p2 = 2;
        int p3 = 2;
        while(true) {
            p1++;
            p2 = p3 +1;
            p3 = p2 + (p1-1);
            if(p2 <= processNumber && processNumber <= p3) {
                return p1;
            }
        }
    }

}
public class Solution {
    public static void main(String[] args) throws IOException {
        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter bufferedWriter = new BufferedWriter(new FileWriter(System.getenv("OUTPUT_PATH")));

        int processNumber = Integer.parseInt(bufferedReader.readLine().trim());

        int result = Result.findParent(processNumber);

        bufferedWriter.write(String.valueOf(result));
        bufferedWriter.newLine();

        bufferedReader.close();
        bufferedWriter.close();
    }
}





















64. Grouping digits
Given an array of binary digits, 0 and 1, sort the array so that all zeros are at one end and all ones are at the other. Which end does not matter. To sort the array, swap any two adjacent elements. Determine the minimum number of swaps to sort the array.
 
Example
arr=[0,1,0,1]
 
With 1 move, switching elements 1 and 2, yields [0,0,1,1], a sorted array.
 
Function Description
Complete the function minMoves in the editor below.
 
minMoves has the following parameter(s):
    int arr[n]:  an array of binary digits
 
Returns
    int: the minimum number of moves necessary
 
Constraints
•	1 ≤ n ≤ 105
•	arr[i] is in the set {0,1}
 
Input Format for Custom Testing
Input from stdin will be processed as follows and passed to the function.
 
The first line contains an integer n, the size of the array arr[].
Each of the next n lines contains a binary digit as an integer, arr[i].
Sample Case 0
Sample Input
STDIN     Function
-----     -----
8      →  arr[i] size n = 8 
1      →  arr = [1, 1, 1, 1, 0, 0, 0, 0]
1                                
1                                
1                                
0                                
0                                
0                              
0                                              
 
Sample Output
0
 
Explanation
The array is already sorted, so no moves are necessary.
Sample Case 1
Sample Input
STDIN     Function
-----     -----
8      →  arr[i] size n = 8 
1      →  arr = [1, 1, 1, 1, 0, 1, 0, 1]
1                              
1                               
1                              
0                                              
1                               
0                                          
1                               
 
Sample Output
3
 
Explanation
Perform the following minimal sequence of 3 moves 1 1 1 1 0 1 0 1 → 1 1 1 1 1 0 0 1 → 1 1 1 1 1 0 1 0 → 1 1 1 1 1 1 0 0 to sort the array. Bold/red is the value at the new position.
Sample Case 2
Sample Input
STDIN     Function
-----     -----
8      →  arr[i] size n = 8  
1      →  arr = [1, 0, 1, 0, 0, 0, 0, 1]
0                                 
1                               
0                               
0                                
0                             
0                                 
1                               
 
Sample Output
6
 
Explanation
This is the minimal sequence of 6 moves 1 0 1 0 0 0 0 1 → 1 1 0 0 0 0 0 1 → 1 1 0 0 0 0 1 0 → 1 1 0 0 0 1 0 0 → 1 1 0 0 1 0 0 0 → 1 1 0 1 0 0 0 0 → 1 1 1 0 0 0 0 0.

class Result {
    public static int minMoves(List<Integer> avg) {
    // Write your code here
        int[] sums = {0, 0};
        int[] counts = {0, 0};

        for(int i=0; i<avg.size(); i++) {
            int val = avg.get(i);
            if(val == 0){
                sums[0] += i - counts[0]++;
            } else{
                sums[1] += i - counts[1]++;
            }
        }
        Arrays.sort(sums);
        return sums[0];
    }

}

public class Solution {
    public static void main(String[] args) throws IOException {
        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter bufferedWriter = new BufferedWriter(new FileWriter(System.getenv("OUTPUT_PATH")));
        int avgCount = Integer.parseInt(bufferedReader.readLine().trim());
        List<Integer> avg = IntStream.range(0, avgCount).mapToObj(i -> {
            try {
                return bufferedReader.readLine().replaceAll("\\s+$", "");
            } catch (IOException ex) {
                throw new RuntimeException(ex);
            }
        })
            .map(String::trim)
            .map(Integer::parseInt)
            .collect(toList());
        int result = Result.minMoves(avg);
        bufferedWriter.write(String.valueOf(result));
        buffeedWriter.newLine();
        bufferedReader.close();
        bufferedWriter.close();
    }
}
public static int minMoves(List<Integer> arr) {
        
        if(arr.size()<=1){
            return 0;
        }
        int oneCount=0;
        int zeroCount=0;
        int zeroCountBefore=0;
        
        int[] oneOrZeroLeft=new int[2];
        int first=0;
        int second=0;
        for(int i=0;i< arr.size();i++){
            if(arr.get(i)==0){
             zeroCount+=Math.abs(i-first);
             first++;
            }else{
                oneCount+=Math.abs(i-second);
                second++;
            }
        }
        
       return Math.min(zeroCount,oneCount);
}


 65. Binary Jumps
In a revised game of hopscotch, a child is trying to cross a line of tiles with a binary string painted on it. Consider the line of tiles to be like a 1D array, where each tile has either a 1 or a 0, and a consecutive series of tiles makes the whole string. The game starts with the child standing in front of the leftmost character of the string.
•	All jumps to reach the end of the string can only be on tiles with 0 or only be on tiles with 1. 
•	The game is won if the child can reach the end of the string, taking jumps with the minimum required power. The power of a jump is given by the number of tiles in the path of a jump as indicated in the diagram below. In 10101, the power of the jump from beginning to the first tile is 1, but from the first to the third tile is 2, and so on.
Find the minimum power the child's jump should have in order to win the game for different binary strings.
 
Note: The value on the last tile determines which tiles to jump on. This is because all tiles landed on must have the same value and the child must land on the last tile to complete the game. In one jump, the child can jump to the right, any distance from 1 to the value of the power of her jump.
 
Example
For the string 10101, the power of the jump needs to be minimum 2. 
 
 
Function Description
Complete the powerJump function in the editor below.
 
powerJump has only one parameter:
    string game: the binary string
 
Returns
    int: the minimum power jump needed to complete the game
 
Constraints
•	1 ≤ Length of game ≤ 100000
•	s[i] contains either '1' or '0'
 
Input Format For Custom Testing
Sample Case 0
Sample Input
STDIN     Function
-----     -----
11111  →  game = 11111
 
Sample Output
1
 
Explanation
Since all of the string elements are 1, the minimum power of the jump needs to be 1 to cross the string.
Sample Case 1
Sample Input
STDIN     Function
-----     -----
11101  →  game = 11101
 
Sample Output
2
 
Explanation
There is one gap of 2 along a path of 1's. The minimum power of the jump needs to be 2 to cross the string.

class Result {
    public static int powerJump(String game) {
    // Write your code here
        char lastchar = game.charAt(game.length()-1);
        int minPower = 1;
        int jumpCounter =1;
        for(int i=0; i< game.length(); i++){
            if(lastchar != game.charAt(i))
            {
                jumpCounter++;
            }else{
             if(jumpCounter > minPower){
                 minPower = jumpCounter;

             }
                jumpCounter=1;
            }
        }  
        return minPower;

    }

}

public class Solution {
    public static void main(String[] args) throws IOException {
        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter bufferedWriter = new BufferedWriter(new FileWriter(System.getenv("OUTPUT_PATH")));

        String game = bufferedReader.readLine();

        int result = Result.powerJump(game);

        bufferedWriter.write(String.valueOf(result));
        bufferedWriter.newLine();

        bufferedReader.close();
        bufferedWriter.close();
    }
}



66. Maximize the value
Rearrange an array of integers so that the calculated value U is maximized. Among the arrangements that satisfy that test, choose the array with minimal ordering. The value of U for an array with n elements is calculated as :
 
    U = arr[1]×arr[2]×(1÷arr[3])×arr[4]×...×arr[n-1] × (1÷arr[n]) if n is odd
    or
    U = arr[1]×arr[2]×(1÷arr[3])×arr[4]×...×(1÷arr[n-1]) × arr[n] if n is even
 
The sequence of operations is the same in either case, but the length of the array, n, determines whether the calculation ends on arr[n] or (1÷arr[n]). 
 
Arrange the elements to maximize U so the items are in the numerically smallest possible order.
 
Example
arr = [21, 34, 5, 7, 9]
 
To maximize U and minimize the order, arrange the array as [9, 21, 5, 34, 7] so U = 9 × 21 × (1÷5) × 34 × (1÷7) = 183.6. The same U can be achieved using several other orders, e.g. [21, 9, 7, 34, 5] = 21 × 9 × (1÷7) × 34 × (1÷5) = 183.6, but they are not in the minimum order.
 
Function Description
Complete the function rearrange in the editor.
 
rearrange has the following parameter(s):
    int arr[n]:  an array of integers
 
Returns
    int[n]: the elements of arr rearranged as described
 
Constraints
•	1 ≤ n ≤ 105
•	1 ≤ arr[i] ≤ 109
 
Input Format For Custom Testing
The first line contains an integer, n, the number of elements in arr.
Each line i of the n subsequent lines (where 1 ≤ i ≤ n) contains an integer, arr[i].
Sample Case 0
Sample Input For Custom Testing
STDIN    Function
-----    --------
4    →   arr[] size n = 4
1    →   arr = [1, 2, 3, 4]
2
3
4
Sample Output
2
3
1
4
Explanation
 
U = 2×3×(1÷1)×4 = 24. All other arrangements where U = 24 are numerically higher than this array, e.g. [2, 3, 1, 4] < [3, 4, 1, 2].
Sample Case 1
Sample Input For Custom Testing
STDIN    Function
-----    --------
2    →   arr[] size n = 2
4    →   arr = [4, 5]
5
Sample Output
4
5
Explanation
 
U is always 4×5 = 20, and [4, 5] < [5, 4].

class Result {
    public static List<Integer> rearrange(List<Integer> arr) {
    // Write your code here
    Collections.sort(arr);
    List<Integer> res= new ArrayList<>();
    int n= arr.size();
    if(n<3) {
        return arr;
    }
    int k=0;
    int j= n%2==0 ? ((n-1)/2): (n/2);
    res.add(arr.get(j++));
    res.add(arr.get(j++));
    for(int i=2; i<n; i++) {
        if(i%2==0) {
            res.add(arr.get(k++));
        } else {
            res.add(arr.get(j++));
        }
    }
    
    return res;

    }

}
public class Solution {
    public static void main(String[] args) throws IOException {
        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter bufferedWriter = new BufferedWriter(new FileWriter(System.getenv("OUTPUT_PATH")));

        int arrCount = Integer.parseInt(bufferedReader.readLine().trim());

        List<Integer> arr = IntStream.range(0, arrCount).mapToObj(i -> {
            try {
                return bufferedReader.readLine().replaceAll("\\s+$", "");
            } catch (IOException ex) {
                throw new RuntimeException(ex);
            }
        })
            .map(String::trim)
            .map(Integer::parseInt)
            .collect(toList());

        List<Integer> result = Result.rearrange(arr);

        bufferedWriter.write(
            result.stream()
                .map(Object::toString)
                .collect(joining("\n"))
            + "\n"
        );

        bufferedReader.close();
        bufferedWriter.close();
    }
}




67. Packet stream player
A stream of n packets arrives at a video player. This player can only play packets that are exactly 2n units long for some non-negative integer value of n (0 ≤ n). All packets are repackaged in order to the largest possible value of 2n units. The remaining part of a packet is added to the next arriving packet before it is repackaged. Find the size of the largest repackaged packet in the given stream.
 
Example
arrivingPackets = [13, 25, 12, 2, 8]
 
The first packet has 13 units. The maximum value of 2n that can be made has 2n = 23 = 8 units because the next size up is 2n = 24 = 16. 13 - 8 = 5 units are added to the next packet.
There are 5 + 25 = 30 units to repackage, 2n = 24 = 16 is the new size leaving 14  units.
14 + 12 = 26, the maximum units is 16 leaving 10 units.
10 + 2 = 12, the max units is 8 leaving 4 units, and so on.
 
The maximum repackaged size is 16 units.
 
Function Description
 
Complete the largestRepackaged function in the editor below.
 
largestRepackaged has the following parameter(s):
    int arrivingPackets: the sizes of the arriving packets
 
Returns
    long: the size of the largest packet that is streamed
 
Constraints
•	1 ≤ n ≤ 105
•	1 ≤ arrivingPackets[i] ≤ 109
 
Input Format For Custom Testing
The first line contains an integer, n, the size of arrivingPackets[].
Each line i of the n subsequent lines (where 0 ≤ i < n) contains an integer, arrivingPacket[i].
Sample Case 0
Sample Input For Custom Testing
STDIN    Function
-----    --------
3    →   arrivingPackets[] size n = 3
3    →   arrivingPackets = [3, 4, 3]
4 
3
Sample Output
4
Explanation
Previous Incoming Total  Maximum 2n  Remainder
              3      3     21 = 2         1
    1         4      5     22 = 4         1 
    1         3      4     22 = 4         0 
 
The packet of size 3 is repackaged to size 2. The remaining 1 is added to the next packet, and so on as shown above.
Sample Case 1
Sample Input For Custom Testing
STDIN    Function
-----    --------
5    →   arrivingPackets[] size n = 5
1    →   arrivingPackets = [1, 2, 4, 7, 5]
2
4
7
5
Sample Output
8
Explanation
Previous Incoming Total  Maximum 2n  Remainder
              1      1     20 = 1         0 
    0         2      2     21 = 2         0 
    0         4      4     22 = 4         0 
    0         7      7     22 = 4         3 
    3         5      8     23 = 8         0 
 
class Result {

    public static long largestRepackaged(List<Integer> arrivingPackets) {
    // Write your code here
        long result = 0;
        long last = 0;
        for(long n : arrivingPackets) {
            long n1 = n + last;
            long d = (long) (Math.log(n1)/ Math.log(2));
            long v = (long) Math.pow(2, d);
            
            result = Math.max(result, v);
            last = n1 - last;
        }   
        return result;
    }

}

public class Solution {
    public static void main(String[] args) throws IOException {
        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter bufferedWriter = new BufferedWriter(new FileWriter(System.getenv("OUTPUT_PATH")));

        int arrivingPacketsCount = Integer.parseInt(bufferedReader.readLine().trim());

        List<Integer> arrivingPackets = new ArrayList<>();

        for (int i = 0; i < arrivingPacketsCount; i++) {
            int arrivingPacketsItem = Integer.parseInt(bufferedReader.readLine().trim());
            arrivingPackets.add(arrivingPacketsItem);
        }

        long result = Result.largestRepackaged(arrivingPackets);

        bufferedWriter.write(String.valueOf(result));
        bufferedWriter.newLine();

        bufferedReader.close();
        bufferedWriter.close();
    }
}















68. Chairs Requirement
In this challenge, determine the minimum number of chairs to be purchased to accommodate all workers in a new business workroom. There is no chair at the beginning.
 
There will be a string array of simulations. Each simulation is described by a combination of four characters: C, R , U, and L
•	C - A new employee arrives in the workroom. If there is a chair available, the employee takes it. Otherwise, a new one is purchased.
•	R - An employee goes to a meeting room, freeing up a chair.
•	U - An employee arrives from a meeting room. If there is a chair available, the employee takes it. Otherwise, a new one is purchased.
•	L - An employee leaves the workroom, freeing up a chair.
 
Example
Given an array of strings representing the simulations
a = ["CRUL"]
 
In this case, there is only one simulation, CRUL, represented in the table below:
Action	Total	Available
_	0	0
C	1	0
R	1	1
U	1	0
L	1	1
 
•	  At first, there are 0 chairs.
•	"C" :  A new employee arrives in the workroom and one chair was purchased.
•	"R" :  An employee goes to the meeting room, freeing up a chair. 
•	"U" :  An employee arrives from the meeting room, took the chair available
•	"L" :  An employee leaves the workroom, freeing up a chair.
The minimum number of chairs to be purchased is one chair in this case. result=[1]
 
 
Function Description
Complete the minChairs function in the editor below.
 
minChairs has the following parameter(s):
    string simulations[n]:  an array of strings representing discrete simulations to process.
 
Returns:
    int[n]:  an array of integers denoting the minimal number of chairs required for each simulation.
 
Constraints
•	1 ≤ n ≤ 100
•	1 ≤ length of each simulations[i] ≤ 10000
 
Input Format For Custom Testing
The first line contains an integer, n, the size of the string array of simulations.
Each line i of the n subsequent lines (where 0 ≤ i < n) contains a string describing simulations[i].
Sample Case 0
Sample Input 0
STDIN       Function 
-----       -------- 
3       →   simulations[] size n = 3 
CCRUCL  →   simulations = ["CCRUCL","CRUC","CCCC"]
CRUC
CCCC
Sample Output 0
3
2
4
Explanation
For 1st simulation: CCRUCL
 
Action	Total	Available
_	0	0
C	1	0
C	2	0
R	2	1
U	2	0
C	3	0
L	3	1
 
•	  At first, there are 0 chairs.
•	"C" :  A new employee arrives in the workroom and one chair was purchased.
•	"C" :  A new employee arrives in the workroom and the second chair was purchased.
•	"R" :  An employee goes to the meeting room, freeing up a chair. 
•	"U" :  An employee arrives from the meeting room, took the chair available.
•	"C" :  A new employee arrives in the workroom and the third  chair was purchased.
•	"L" :  An employee leaves the workroom, freeing up a chair.
The minimal number of chairs required after the simulation is 3.
 
For 2nd simulation: CRUC
Action	Total	Available
_	0	0
C	1	0
R	1	1
U	1	0
C	2	0
•	  At first, there are 0 chairs.
•	"C" :  A new employee arrives in the workroom and one chair was purchased.
•	"R" :  An employee goes to the meeting room, freeing up a chair. 
•	"U" :  An employee arrives from the meeting room, took the chair available.
•	"C" :  A new employee arrives in the workroom and the second chair was purchased.
The minimal number of chairs required after the simulation is 2.
 
For 3rd simulation: CCC
Action	Total	Available
_	0	0
C	1	0
C	2	0
C	3	0
C	4	0
•	  At first, there are 0 chairs.
•	"C" :  A new employee arrives in the workroom and one chair was purchased.
•	"C" :  A new employee arrives in the workroom and the second chair was purchased.
•	"C" :  A new employee arrives in the workroom and the third chair was purchased.
•	"C" :  A new employee arrives in the workroom and the fourth chair was purchased.
The minimal number of chairs required after the simulation is 4. The result = [3,2,4]
 
Sample Case 1
Sample Input 1
STDIN       Function 
-----       -------- 
3       →   simulations[] size n = 3 
CCCRRR  →   simulations = ["CCCRRR","CC","CCRURC"]
CC
CCRURC

Sample Output 1
3
2
2
Explanation
For 1st simulation: CCCRRR
 
Action	Total	Available
_	0	0
C	1	0
C	2	0
C	3	0
R	3	1
R	3	2
R	3	3
 
•	  At first, there are 0 chairs.
•	"C" :  A new employee arrives in the workroom and one chair was purchased.
•	"C" :  A new employee arrives in the workroom and the second chair was purchased.
•	"C" :  A new employee arrives in the workroom and the third chair was purchased.
•	"R" :  An employee goes to the meeting room, freeing up a chair. 
•	"R" :  An employee goes to the meeting room, freeing up a the second chair. 
•	"R" :  An employee goes to the meeting room, freeing up a third chair. 
The minimal number of chairs purchased after the simulation is 3.
 
For 2nd simulation: CC
Action	Total	Available
_	0	0
C	1	0
C	2	0
•	  At first, there are 0 chairs.
•	"C" :  A new employee arrives in the workroom and one chair was purchased.
•	"C" :  A new employee arrives in the workroom and the second chair was purchased.
The minimal number of chairs purchased after the simulation is 2.
 
For 3rd simulation: CCRURC
Action	Total	Available
_	0	0
C	1	0
C	2	0
R	2	1
U	2	0
R	2	1
C	2	0
 
•	  At first, there are 0 chairs.
•	"C" :  A new employee arrives in the workroom and one chair was purchased.
•	"C" :  A new employee arrives in the workroom and the second chair was purchased.
•	"R" :  An employee goes to the meeting room, freeing up a chair. 
•	"U" :  An employee arrives from the meeting room, took the chair available.
•	"R" :  An employee goes to the meeting room, freeing up a chair. 
•	"C" :  A new employee arrives in the workroom, took the chair available.
The minimal number of chairs purchased after the simulation is 2.
 
The result = [3,2,2]
 
 
class Result {
    public static List<Integer> minChairs(List<String> simulations) {
    // Write your code here
   
            List<Integer> res = new ArrayList<>();
            
            for(String s:simulations){
               int max =0;
            int ava = 0;
            
                char[] chs = s.toCharArray();
                
                for(char ch:chs){
                    
                    if((ch == 'C' || ch == 'U') && ava > 0){
                        ava--;
                    }
                    else if ((ch == 'C' || ch == 'U') && ava == 0){
                        max++;
                    }
                    else if(ch == 'R' || ch == 'L'){
                        ava++;
                    }
 
                }
                res.add(max);
            }
            
            return res;
    

    }

}

public class Solution {
    public static void main(String[] args) throws IOException {
        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter bufferedWriter = new BufferedWriter(new FileWriter(System.getenv("OUTPUT_PATH")));

        int simulationsCount = Integer.parseInt(bufferedReader.readLine().trim());

        List<String> simulations = IntStream.range(0, simulationsCount).mapToObj(i -> {
            try {
                return bufferedReader.readLine();
            } catch (IOException ex) {
                throw new RuntimeException(ex);
            }
        })
            .collect(toList());

        List<Integer> result = Result.minChairs(simulations);

        bufferedWriter.write(
            result.stream()
                .map(Object::toString)
                .collect(joining("\n"))
            + "\n"
        );

        bufferedReader.close();
        bufferedWriter.close();
    }
}

















69. Duplicated Products
You are given a complex list of n products, each with a name, price, and weight. Find out how many duplicate products are present within the list. Duplicate products contain identical parameters for all fields in the list (i.e. name, price, and weight).
 
Example:
 
There are n = 5 products with attributes listed in three arrays, aligned by index.
 
name = [ball, bat, glove, glove, glove]
price = [2, 3, 1, 2, 1]
weight = [2, 5, 1, 1, 1]
 
A complete item description for item 0: (name[0], prices[0], weight[0]) is (ball, 2, 2)
Name     Price Weight
ball     2     2
bat      3     5
glove    1     1
glove    2     1
glove    1     1

The first two items are unique.
The two gloves at indices 2 and 4 are equal in all three attributes so there is 1 duplicate.
The last glove at index 3 has a different price from the other two, so it is not a duplicate.
 
There is 1 duplicate item in the original list.
 
Function Description 
 
Complete the function numDuplicates in the editor below. The function must return an integer denoting the number of duplicates within the product list.
 
numDuplicates has the following parameter(s):
    string name[n]: string array of size n, where names[i] denotes the name of the product at the index of i.
    int price[n]: int array of size n, where prices[i] denotes the price of the product at the index of i.
    int weight[n]: int array of size n, where weights[i] denotes the weight of the product at the index of i.
   
Constraints
•	1 ≤ n ≤ 105
•	name[i] is non-empty, has at most 10 characters, and all its characters are lowercase English letters, ascii[a-z]
•	1 ≤ price[i], weight[i] ≤ 1000
 
Input Format Format for Custom Testing
Input from stdin will be processed as follows and passed to the function:
 
In the first line there is a single integer n which is the length of name.
Each of the following n lines contains a string for name[i]
In the next line, n is repeated denoting the length of price.
Each of the following n lines contains an integer for price[i].
In the next line, n is repeated denoting the length of weight.
Each of the following n lines contains an integer for weight[i].
Sample Case 0
Sample Input
STDIN     Function
-----     --------
5    →    name[] size n = 5
ball →    name = ['ball', 'box', 'ball', 'ball', 'box']
box
ball
ball
box
5    →    price[] size n = 5
2    →    price = [2, 2, 2, 2, 2]
2
2
2
2
5    →    weight[] size n = 5
1    →    weight = [1, 2, 1, 1, 3]
2
1
1
3
Sample Output
2
Explanation
 
Name Price Weight
ball 2     1
box  2     2
ball 2     1
ball 2     1
box  2     3
 
The 3 balls have the same name, price and weight, so there are 2 duplicates. The two other products are boxes but they have different weights.
Sample Case 1
Sample Input
STDIN     Function
-----     --------
5    →    name[] size n = 5
ball →    name = ['ball', 'box', 'lamp', 'brick', 'pump']
box
lamp
brick
pump
5    →    price[] size n = 5
2    →    price = [2, 2, 2, 2, 2]
2
2
2
2
5    →    weight[] size n = 5
2    →    weight = [2, 2, 2, 2, 2]
2
2
2
2
Sample Output
0
Explanation
 
Name  Price Weight
ball  2     2
box   2     2
lamp  2     2
brick 2     2
pump  2     2
 
Each product is unique so there are no duplicates.

class Result {
    public static int numDuplicates(List<String> name, List<Integer> price, List<Integer> weight) {
    // Write your code here
    int n = name.size();
        Set<String> unique = new HashSet<String>();
        for (int i = 0; i < n; i++) {
            unique.add(name.get(i) + " "+ price.get(i) + " "+ weight.get(i));
        }
        return name.size() - unique.size();
    }

}

public class Solution {
    public static void main(String[] args) throws IOException {
        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter bufferedWriter = new BufferedWriter(new FileWriter(System.getenv("OUTPUT_PATH")));

        int nameCount = Integer.parseInt(bufferedReader.readLine().trim());

        List<String> name = IntStream.range(0, nameCount).mapToObj(i -> {
            try {
                return bufferedReader.readLine();
            } catch (IOException ex) {
                throw new RuntimeException(ex);
            }
        })
            .collect(toList());

        int priceCount = Integer.parseInt(bufferedReader.readLine().trim());

        List<Integer> price = IntStream.range(0, priceCount).mapToObj(i -> {
            try {
                return bufferedReader.readLine().replaceAll("\\s+$", "");
            } catch (IOException ex) {
                throw new RuntimeException(ex);
            }
        })
            .map(String::trim)
            .map(Integer::parseInt)
            .collect(toList());

        int weightCount = Integer.parseInt(bufferedReader.readLine().trim());

        List<Integer> weight = IntStream.range(0, weightCount).mapToObj(i -> {
            try {
                return bufferedReader.readLine().replaceAll("\\s+$", "");
            } catch (IOException ex) {
                throw new RuntimeException(ex);
            }
        })
            .map(String::trim)
            .map(Integer::parseInt)
            .collect(toList());

        int result = Result.numDuplicates(name, price, weight);

        bufferedWriter.write(String.valueOf(result));
        bufferedWriter.newLine();

        bufferedReader.close();
        bufferedWriter.close();
    }
}



















70. Complementing DNA Strand
A DNA string consists of four symbols: A, T, C, and G. Each symbol has a specific complement:
•	A and T complement each other
•	C and G complement each other
 
To find the reverse complement of a DNA string, you need to reverse the string and then replace each symbol with its complement.
 
Write a function that takes a DNA string as input and returns its reverse complement.
 
Example
s = GTCAG
•	Reverse the string GTCAG → GACTG.
•	Replace each symbol with its complement GACTG → CTGAC.
•	The reverse complement of the DNA string is CTGAC.
 
 
Function Description 
Complete the function dnaComplement in the editor with the following parameter(s):
    string s:  a string of DNA symbols
 
Returns
    string: the reverse complement of s
 
Constraints
•	1 ≤ length of s ≤ 1000
•	Each character s[i] is in the set [A,T,C,G]
 
Input Format for Custom Testing
Input from stdin will be processed as follows and passed to the function.
 
The line contains a string s.
Sample Case 0
Sample Input 0
STDIN            Function Parameters 
-----            -------------------
ACCGGGTTTT   →   string s = "ACCGGGTTTT"
Sample Output 0
AAAACCCGGT
Explanation 0
•	Reverse the string ACCGGGTTTT → TTTTGGGCCA
•	Replace each symbol by its complement TTTTGGGCCA → AAAACCCGGT.
Sample Case 1
Sample Input 1
STDIN            Function Parameters
-----            -------------------
ATGC       →     string s = "ATGC"
Sample Output 1
GCAT
Explanation 1
•	Reverse the string ATGC→ CGTA
•	Replace each symbol by its complement CGTA → GCAT
Sample Case 2
Sample Input 2
STDIN           Function Parameters
-----           -------------------
ATCGTA     →    string s = "ATCGTA"
Sample Output 2
TACGAT
Explanation 2
•	Reverse the string ATCGTA→ ATGCTA
•	Replace each symbol by its complement  ATGCTA → TACGAT

class Result {
    public static String dnaComplement(String s) {
    // Write your code here
    String reverse = new StringBuilder(s).reverse().toString();
    char[] res = new char[reverse.length()];
    for(int i =0; i<res.length; i++){
        char x = reverse.charAt(i);
        if(x == 'A')
            res[i] = 'T';
        else if(x == 'T')
            res[i] = 'A';
        else if(x == 'C')
            res[i] = 'G';
        else if(x == 'G')
            res[i] = 'C';
              
    }
    return new String(res);

    }

}
public class Solution {
    public static void main(String[] args) throws IOException {
        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter bufferedWriter = new BufferedWriter(new FileWriter(System.getenv("OUTPUT_PATH")));

        String s = bufferedReader.readLine();

        String result = Result.dnaComplement(s);

        bufferedWriter.write(result);
        bufferedWriter.newLine();

        bufferedReader.close();
        bufferedWriter.close();
    }
}


71. Minimum Moves
There are two arrays of integers, arr1 and arr2. One move is defined as an increment or decrement of one element in an array. Determine the minimum number of moves to match arr1 with arr2. No reordering of the digits is allowed.
 
Example
arr1 = [123, 543]
arr2 = [321, 279]
 
•	Match arr1[0]=123 with arr2[0]=321.
•	Increment 1 twice to get 3 (2 moves)
•	Decrement 3 twice to get 1 (2 moves).
•	4 moves are needed to match 123 with 321.
•	Match arr1[1]=543 with arr2[1]=279.
•	Decrement 5 three times to get 2 (3 moves)
•	Increment 4 three times to get 7 (3 moves)
•	Increment 3 six times to get 9 (6 moves).
•	12 moves are needed to match 543 with 279.
•	16 total moves are needed to match the arrays arr1 and arr2.
 
 
Function Description 
Complete the function minimumMoves in the editor below.
 
minimumMoves has the following parameter(s):
   int arr1[n]:  array to modify
   int arr2[n]:  array to match
 
Returns:
    int: te minimum number of moves to match arr1 with arr2
 
Constraints
•	1 ≤ n ≤ 105
•	1 ≤ arr1[i], arr2[i] ≤ 109
•	The lengths of arr1 and arr2 are equal, |arr1| = |arr2|.
•	The elements arr1[i] and arr2[i] have an equal number of digits.
 
Input Format for Custom Testing
The first line contains an integer n, the size of the array arr1.
The next n lines each contain an element arr1[i] where 0 ≤ i < n.
The next line contains an integer n, the size of the array arr2.
The next n lines each contain an element arr2[i] where 0 ≤ i < n.
Sample Case 0
Sample Input
STDIN     Function 
-----     -------- 
2     →   n = 2 
1234  →   arr1 = [1234, 4321]
4321
2     →   n = 2 
2345  →   arr2 = [2345, 3214] 
3214
Sample Output
10
Explanation
 
•	Match arr1[0]=1234 with arr2[0]=2345.
•	Increment 1 once to get 2 (1 move)
•	Increment 2 once to get 3 (1 move)
•	Increment 3 once to get 4 (1 move) 
•	Increment 4 once to get 5 (1 move).
•	4 moves are needed to match 1234 with 2345.
•	Match arr1[1]=4321 with arr2[1]=3214.
•	Decrement 4 once to get 3 (1 move)
•	Decrement 3 once to get 2 (1 move)
•	Decrement 2 once to get 1 (1 move)
•	Increment 1 three times to get 4 (3 moves)
•	6 moves are needed to match 4321 with 3214.
•	6+4=10 total moves are needed to match the arrays arr1 and arr2.
Sample Case 1
Sample Input
STDIN     Function     
-----     -------- 
1     →   n = 1 
2468  →   arr1 = [2468]
1     →   n = 1 
8642  →   arr2 = [8642] 

Sample Output
16
Explanation
•	Match arr1[0]=2468 with arr2[0]=8642.
•	Increment 2 six times to get 8 (6 moves)
•	Increment 4 twice to get 6 (2 moves)
•	Decrement 6 twice to get 4 (2 moves)
•	Decrement 8 six times to get 2  (6 moves).
•	16 moves are needed to match the arrays arr1 and arr2.

class Result {
    public static int minimumMoves(List<Integer> arr1, List<Integer> arr2) {
    // Write your code here
       int moves=0;
       for(int i=0; i < arr1.size(); i++){
           int n1= arr1.get(i);
           int n2= arr2.get(i);
           while(n1 >0 && n2 > 0){
               moves=moves + Math.abs(n1%10 -n2%10);
               n1=n1/10;
               n2=n2/10;
           }
       }
    
       return moves;

    }

}
public class Solution {
    public static void main(String[] args) throws IOException {
        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter bufferedWriter = new BufferedWriter(new FileWriter(System.getenv("OUTPUT_PATH")));

        int arr1Count = Integer.parseInt(bufferedReader.readLine().trim());

        List<Integer> arr1 = new ArrayList<>();

        for (int i = 0; i < arr1Count; i++) {
            int arr1Item = Integer.parseInt(bufferedReader.readLine().trim());
            arr1.add(arr1Item);
        }

        int arr2Count = Integer.parseInt(bufferedReader.readLine().trim());

        List<Integer> arr2 = new ArrayList<>();

        for (int i = 0; i < arr2Count; i++) {
            int arr2Item = Integer.parseInt(bufferedReader.readLine().trim());
            arr2.add(arr2Item);
        }

        int result = Result.minimumMoves(arr1, arr2);

        bufferedWriter.write(String.valueOf(result));
        bufferedWriter.newLine();

        bufferedReader.close();
        bufferedWriter.close();
    }
}

















72. Spreadsheet Notation Conversion
A spreadsheet application allows data to be organized and manipulated within rows and columns of a table. Each individual rectangle within the table is referred to as a cell. The following conventions apply to spreadsheets:
1.	Rows are numbered sequentially from top to bottom, starting at 1 and ending at 109.
2.	Columns are labeled sequentially from left to right, beginning with A and ending with ZZ. After Z, the sequence continues with AA, AB, and so on, resulting in a total of 702 columns per row. All column labels are capital letters.
3.	In spreadsheet notation, a cell at the intersection of row R and column C is denoted as RC. For example, the cell at row 7 and column AH is written as 7AH.
Cell numbers are long integers assigned sequentially to each cell from left to right and top to bottom.
 
 A portion of a spreadsheet where each cell contains its corresponding cell number.
 
Function Description 
Complete the function getSpreadsheetNotation in the editor with the following parameter(s):
    long int n:  cell number
 
Returns:
    string: a string representation of a cell number in spreadsheet notation
 
Constraints
•	1 ≤ n ≤ 1012
 
Input Format For Custom Testing
Input from stdin will be processed as follows and passed to the function.
 
The line contains a long integer n.
Sample Case 0
Sample Input 0
STDIN      Function Parameters 
-----      ------------------- 
27     →   n = 27
 
Sample Output 0
1AA
Explanation 0
 Each cell contains its corresponding cell number.
Cell n = 27 is located at the intersection of row 1 and column AA.
Sample Case 1
Sample Input 1
STDIN      Function Parameters
-----      ------------------- 
703    →   n = 703
 
Sample Output 1
2A
Explanation 1
 Each cell contains its corresponding cell number.
Cell n = 703 is located at the intersection of row 2 and column A.

class Result {
    public static String getSpreadsheetNotation(long columnNumber) {
    // Write your code here
        StringBuilder col = new StringBuilder();
        long reminder = columnNumber% 702;
        long prefix = columnNumber/702 +1;
        
        StringBuilder temp = new StringBuilder();
        int n = (int)reminder;
        if(n ==0){
            long rem = columnNumber/26;
            prefix = columnNumber/702;
            while (rem >0) {
                temp.append("ZZ"); rem = n%6;
            }
            
        }
        while (n >0) {
            int remo = n% 26;
            if(remo ==0){
                col.append("Z"); n = (n/26)-1;
            }
            else {col.append((char)((remo-1) + 'A')); n= n/26;}
        }
        col = col.reverse();
        
        return String.valueOf(prefix) + temp+ col;

    }

}

public class Solution {
    public static void main(String[] args) throws IOException {
        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter bufferedWriter = new BufferedWriter(new FileWriter(System.getenv("OUTPUT_PATH")));

        long n = Long.parseLong(bufferedReader.readLine().trim());

        String result = Result.getSpreadsheetNotation(n);

        bufferedWriter.write(result);
        bufferedWriter.newLine();

        bufferedReader.close();
        bufferedWriter.close();
    }
}


public static String getSpreadsheetNotation(long n) {
    // Write your code here
        long row = (n-1) / 702;
        long rem = n % 702;
         rem = rem == 0 ? 702 : rem;
        String result = "";
        while(rem > 0) {
            rem--;
            result = ((char)('A' + rem % 26)) + result;
            rem /= 26;
        }
        
        return (row + 1) + result;
    }





















73. Equal Levels
Two signals are being generated as part of a simulation. A program monitors the signals. Whenever the two signals become equal at the same time, the frequency is noted. A record is maintained for the maximum simultaneous frequency seen so far. Each time a higher simultaneous frequency is noted, this variable (maxequal) is updated to the higher frequency.
 
Note:
•	Both signals start at time t=0, but their durations might be different. In this case, the comparison of equality is performed only until the end of the shorter signal.
•	If both signals have equal frequencies at a given time but the frequency is less than or equal to the current maximum frequency, maxequal, is not updated.
 
The running times of both signals are given, denoted by n and m respectively. During the course of the simulation, how many times is the maxequal variable updated?
 
Example
signalOne = [1, 2, 3, 3, 3, 5, 4]
signalTwo = [1, 2, 3, 4, 3, 5, 4] 
 
 
 
Each of the first three signals match and are increasing, so maxequal is updated 3 times to 1, 2 and then 3.
At the fourth time, they are not equal.
At the fifth, they are equal to 3. Since maxequal contains 3 already, it is not updated.
At the sixth time, both signals are equal to 5. This is greater than maxequal = 3, so now maxequal = 5.
At the final time, signals are equal to 4. Since 4 is less than maxequal, it is not updated.
maxEqual was updated a total of 4 times.
 
Function Description
 
Complete the updateTimes function in the editor below.
 
updateTimes has the following parameter(s):
    int signalOne[n]: the frequencies of the first signal
    int signalTwo[m]: the frequencies of the second signal
Return
    int:  the number of updates
 
Constraints
•	1 ≤ n ≤ 105 
•	0 ≤ signalOne[i] ≤ 109
•	1 ≤ m ≤ 105
•	0 ≤ signalTwo[i] ≤ 109
 
Input Format For Custom Testing
The first line contains an integer, n, the running time of the first signal and the number of elements in signalOne.
Each line i of the n subsequent lines (where 0 ≤ i < n) contains the frequency of the signalOne[i].
The next line contains an integer, m, the running time of the second signal and the number of elements in signalTwo. 
Each line i of the m subsequent lines (where 0 ≤ i < m) contains the frequency of the signalTwo[i].
Sample Case 0
Sample Input For Custom Testing
STDIN     Function
-----     --------
5    →    signalOne[] size n = 5
1    →    signalOne = [1, 2, 3, 4, 1]
2
3
4
1
5    →    signalTwo[] size m = 5
5    →    signalTwo = [5, 4, 3, 4, 1]
4
3
4
1
Sample Output
2
Explanation
 
 
The frequencies are equal during three periods, with frequencies 3, 4 and 1.
The maximum frequency is updated twice at 3, and 4, since 4 is greater than 3.
It is not updated when their values are 1 because 1 is less than the current maxequal = 4.
Sample Case 1
Sample Input For Custom Testing
STDIN     Function
-----     --------
5    →    signalOne[] size n = 5
1    →    signalOne = [1, 2, 3, 4, 5]
2
3
4
5
5    →    signalTwo[] size m = 5
5    →    signalTwo = [5, 4, 3, 2, 1]
4
3
2
1
Sample Output
1
Explanation
   
 
The maximum frequency is updated once at 3, the only point where the signals match.

class Result {
    public static int updateTimes(List<Integer> signalOne, List<Integer> signalTwo) {
        int max = 0, current = 0, n = signalOne.size(), n2 = signalTwo.size();
        for(int i=0; i<n && i < n2; i++) {
            int s1 = signalOne.get(i), s2 = signalTwo.get(i);
            if(s1 == s2 && current < s1) {
                current = s1;
                max++;
            }
        }
        return max;
    }

}
public class Solution {
    public static void main(String[] args) throws IOException {
        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter bufferedWriter = new BufferedWriter(new FileWriter(System.getenv("OUTPUT_PATH")));

        int signalOneCount = Integer.parseInt(bufferedReader.readLine().trim());

        List<Integer> signalOne = new ArrayList<>();

        for (int i = 0; i < signalOneCount; i++) {
            int signalOneItem = Integer.parseInt(bufferedReader.readLine().trim());
            signalOne.add(signalOneItem);
        }

        int signalTwoCount = Integer.parseInt(bufferedReader.readLine().trim());

        List<Integer> signalTwo = new ArrayList<>();

        for (int i = 0; i < signalTwoCount; i++) {
            int signalTwoItem = Integer.parseInt(bufferedReader.readLine().trim());
            signalTwo.add(signalTwoItem);
        }

        int result = Result.updateTimes(signalOne, signalTwo);

        bufferedWriter.write(String.valueOf(result));
        bufferedWriter.newLine();

        bufferedReader.close();
        bufferedWriter.close();
    }
}




















74. Office Design
A company is repainting its office and would like to choose colors that work well together. They are presented with several various-priced color options presented in a specific order so that each color complements the surrounding colors. The company has a limited budget and would like to select the greatest number of consecutive colors that fit within this budget. Given the prices of the colors and the company's budget, what is the maximum number of colors that can be purchased for this repainting project?
 
Example
prices = [2, 3, 5, 1, 1, 2, 1]
money = 7
 
All subarrays that sum to less than or equal to 7:
Length 1 subarrays are [2], [3], [5], [1], [1], [2], [1]
Length 2 - [2, 3], [5, 1], [1, 1], [1, 2], [2, 1]
Length 3 - [5, 1, 1], [1, 1, 2], [1, 2, 1]
Length 4 - [1, 1, 2, 1]
 
The longest of these, or the maximum number of colors that can be purchased, is 4.
 
Function Description
 
Complete the function getMaxColors in the editor below.
 
getMaxColors has the following parameters:
    int prices[n]:  the prices of the various paint colors
    int money:  the amount of money the company can spend on paints
Returns:
    int: the maximum number of colors the company can purchase
 
Constraints
•	1 ≤ n ≤ 105
•	1 ≤ prices[i] ≤ 100
•	1 ≤ money ≤ 106
 
Input Format For Custom Testing
Sample Case 0
Sample Input For Custom Testing
STDIN     Function 
-----     --------
3     →   prices[] size n = 3
10    →   prices = [ 10, 10, 10 ] 
10
10
5     →   money = 5 
Sample Output
0
Explanation
There are 3 colors to choose from, each costing 10. With the company budget of 5, no colors can be purchased. Therefore, the answer is 0.
Sample Case 1
Sample Input For Custom Testing
STDIN     Function
-----     --------
3     →   prices[] size n = 3
5     →   prices = [ 5, 10, 10 ]
10
10
5     →   money = 5 
Sample Output
1
Explanation
With the company budget of 5, only 1 color (the first) can be purchased. Therefore, the answer is 1.

class Result {
    public static int getMaxColors(List<Integer> prices, int money) {
        // Write your code here
        int max=0;
        int left =0;
        int right =0;
        while(right < prices.size()){
            int temp = left;
            int total =0;
            while(temp<right){
                total+=prices.get(temp);
                if(temp+1==right){
                    total+=prices.get(right);
                    break;
                }
                temp++;
            }
            if(total<=money){
                max=Math.max(max, right-left+1);
            }
            if(total>money){
                left++;
            }
            else{
                right++;
            }
        }
        Collections.sort(prices);
        if(prices.get(0)>money){
            max=0;
        }
        return max;
    }

}

public class Solution {
    public static void main(String[] args) throws IOException {
        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter bufferedWriter = new BufferedWriter(new FileWriter(System.getenv("OUTPUT_PATH")));

        int pricesCount = Integer.parseInt(bufferedReader.readLine().trim());

        List<Integer> prices = IntStream.range(0, pricesCount).mapToObj(i -> {
            try {
                return bufferedReader.readLine().replaceAll("\\s+$", "");
            } catch (IOException ex) {
                throw new RuntimeException(ex);
            }
        })
            .map(String::trim)
            .map(Integer::parseInt)
            .collect(toList());

        int money = Integer.parseInt(bufferedReader.readLine().trim());

        int result = Result.getMaxColors(prices, money);
        bufferedWriter.write(String.valueOf(result));
        bufferedWriter.newLine();
        bufferedReader.close();
        bufferedWriter.close();
    }}

75. Sort an array
Given an array of integers, any array element can be moved to the end in one move. Determine the minimum number of moves required to sort the array in ascending order.
 
Example:
arr = [5, 1, 3, 2]
•	Move the value arr[2] = 3 to the end to get arr = [5, 1, 2, 3]. 
•	Move arr[0] = 5 to the end to achieve the sorted array, arr = [1, 2, 3, 5]. 
•	The minimum number of moves required to sort the array is 2.
 
Function Description
Complete the function getMinimumMoves in the editor with the following parameter:
    int  arr[n]: an array to sort
 
Returns
    int: the minimum number of moves needed to sort the array in ascending order
 
Constraints
•	1 ≤ n ≤ 105
•	0 ≤ arr[i] ≤ 106
•	array elements are distinct
 
Input Format For Custom Testing
The first line contains an integer, n, the size of arr.
Each line i of the next n lines (where 0 ≤ i < n) contains an integer, arr[i].
Sample Case 0
Sample Input For Custom Testing
STDIN      Function 
-----      -------- 
3      →   arr[] size n = 3 
1      →   arr = [1, 2, 3]
2 
3
Sample Output
0
Explanation
 
The array is already sorted, so no moves are necessary.
Sample Case 1
Sample Input For Custom Testing
STDIN     Function
-----     --------
3     →   arr[] size n = 3
1     →   arr = [1, 3, 2]
3
2
Sample Output
1
Explanation
 
•	Move the value arr[1] = 3 to the end to get arr = [1, 2, 3]. 
•	The minimum number of moves required to sort the array is 1.
class Result {

    /*
     * Complete the 'getMinimumMoves' function below.
     *
     * The function is expected to return an INTEGER.
     * The function accepts INTEGER_ARRAY arr as parameter.
     */

    public static int getMinimumMoves(List<Integer> arr) {
    // Write your code here
    int r=0;
    List<Integer> temp=new ArrayList<>();
    for(int y:arr)
    {
        temp.add(y);
    }
    Collections.sort(temp);
    r=arr.size();
    int j=0;
    for(int k:arr)
    {
        if(k==temp.get(j)){
        r--;
        j++;
        }
    }
    return r;

    }

}
public class Solution {
    public static void main(String[] args) throws IOException {
        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter bufferedWriter = new BufferedWriter(new FileWriter(System.getenv("OUTPUT_PATH")));

        int arrCount = Integer.parseInt(bufferedReader.readLine().trim());

        List<Integer> arr = IntStream.range(0, arrCount).mapToObj(i -> {
            try {
                return bufferedReader.readLine().replaceAll("\\s+$", "");
            } catch (IOException ex) {
                throw new RuntimeException(ex);
            }
        })
            .map(String::trim)
            .map(Integer::parseInt)
            .collect(toList());

        int result = Result.getMinimumMoves(arr);

        bufferedWriter.write(String.valueOf(result));
        bufferedWriter.newLine();

        bufferedReader.close();
        bufferedWriter.close();
    }
}


















76. Shifting Strings
The following operations on a string are defined:
•	Left Shift: A single circular rotation of the string where the first character moves to the end and all other characters shift one position to the left. For example, abcde becomes bcdea after one left shift and cdeab after two left shifts.
•	Right Shift: A single circular rotation of the string where the last character moves to the beginning and all other characters shift one position to the right. For example, abcde becomes eabcd after one right shift and deabc after two right shifts.
 
Example
s = 'abcdefg'
leftShifts = 2
rightShifts = 4
 
The string abcdefg shifted left by 2 positions is cdefgab. The string cdefgab shifted right by 4 positions is fgabcde, the string to return.
 
Function Description 
Complete the function getShiftedString in the editor with the following parameter(s):
    string s:  the string to shift
    int leftShifts: number of shifts left
    int rightShifts:  number of shifts right
 
Returns
    string: a string shifted left or right
 
Constraints
•	1 ≤ length of s ≤ 105
•	0 ≤ leftShifts, rightShifts ≤ 109
•	String s consists of lowercase English alphabetic letters only, ascii[a-z].
 
Input Format for Custom Testing
Input from stdin will be processed as follows and passed to the function.
 
The first line contains s, the string to shift.
The second line contains an integer, leftShifts.
The third line contains an integer, rightShifts.
 
Sample Case 0
Sample Input 0
STDIN           Function
-----           --------
abcd     →      s = "abcd"
1        →      leftShifts = 1
2        →      rightShifts = 2

 
Sample Output 0
dabc
 
Explanation 0
Initially, s is abcd.
1.	leftShifts = 1 : abcd → bcda
2.	rightShifts = 2 : bcda → abcd → dabc
The function then returns dabc.
 
Sample Case 1
Sample Input 1
STDIN           Function
-----           --------
a        →      s = "a"
0        →      leftShifts = 0
1        →      rightShifts = 1

 
Sample Output 1
a
 
Explanation 1
A one character string is unchanged regardless of the number of shifts performed.
 
class Result {
    public static String getShiftedString(String s, int leftShifts, int rightShifts) {
    int size = s.length();
    s = shift_left(s, leftShifts%size);
    s = shift_right(s, size, rightShifts%size);
    return s;
    }
    private static String shift_left(String s, int leftShifts)
    {
        return s.substring(leftShifts) + s.substring(0, leftShifts);
    }
    private static String shift_right(String s, int size, int rightShifts)
    {
        return shift_left(s, size-rightShifts);
    }

}

public class Solution {
    public static void main(String[] args) throws IOException {
        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter bufferedWriter = new BufferedWriter(new FileWriter(System.getenv("OUTPUT_PATH")));

        String s = bufferedReader.readLine();

        int leftShifts = Integer.parseInt(bufferedReader.readLine().trim());

        int rightShifts = Integer.parseInt(bufferedReader.readLine().trim());

        String result = Result.getShiftedString(s, leftShifts, rightShifts);

        bufferedWriter.write(result);
        bufferedWriter.newLine();

        bufferedReader.close();
        bufferedWriter.close();
    }
}

 public static String getShiftedString(String s, int leftShifts, int rightShifts) {
    // Write your code here
    s= leftRotate(s, leftShifts%s.length());
    return rightRotate(s, rightShifts%s.length());

    }
    static String leftRotate(String str, int d){
        return str.substring(d) + str.substring(0,d);
    }
    static String rightRotate(String str, int d){
        return leftRotate(str, str.length()-d);
    }

}






77. Count Duplicate elements
Given an integer array, numbers, count the number of elements that occur more than once.
 
Example
numbers = [1, 3, 3, 4, 4, 4]
 
There are two non-unique elements: 3 and 4.
 
Function Description
Complete the function countDuplicate in the editor below.
 
countDuplicate has the following parameter(s):
    int numbers[n]:  an array of integers
 
Returns:
    int: an integer that denotes the number of non-unique values in the numbers array
 
Constraints
•	3 ≤ n ≤ 1000
•	1 ≤ numbers[i] ≤ 1000, 0 ≤ i < n
 
Input Format Format for Custom Testing
Input from stdin will be processed as follows and passed to the function.
 
The first line contains an integer n, the size of the numbers array.
Each of the next n lines contains an integer, numbers[i], where 0 ≤ i < n.
Sample Case 0
Sample Input
STDIN     Function
-----     -----
8      →  numbers[] size n = 8 
1      →  numbers = [1, 3, 1, 4, 5, 6, 3, 2]
3
1
4
5
6
3
2 
Sample Output
2
Explanation
The values 1 and 3 occur more than once, therefore the answer is 2. 
Sample Case 1
Sample Input
STDIN     Function
-----     -----
6      →  numbers[] size n = 6
1      →  numbers = [1, 1, 2, 2, 2, 3]
1
2
2
2
3
Sample Output
2
Explanation
The values 1 and 2 occur more than once, therefore the answer is 2. 

class Result {
    public static int countNonUnique(List<Integer> numbers) {
    // Write your code here
    int result =0;
    HashMap<Integer, Integer> map= new HashMap<Integer,Integer>();

    for(int n :numbers) {
        if(map.containsKey(n)){
            int v= map.get(n);
            if(v==1){
                result= result+1 ;
                
            }
            map.put(n,v+1);
            

        }
        else{
              map.put(n,1);
        }
    }


   return result;
    }

}

public class Solution {
    public static void main(String[] args) throws IOException {
        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter bufferedWriter = new BufferedWriter(new FileWriter(System.getenv("OUTPUT_PATH")));

        int numbersCount = Integer.parseInt(bufferedReader.readLine().trim());

        List<Integer> numbers = new ArrayList<>();

        for (int i = 0; i < numbersCount; i++) {
            int numbersItem = Integer.parseInt(bufferedReader.readLine().trim());
            numbers.add(numbersItem);
        }

        int result = Result.countNonUnique(numbers);

        bufferedWriter.write(String.valueOf(result));
        bufferedWriter.newLine();

        bufferedReader.close();
        bufferedWriter.close();
    }
}



















78. Restructured array

A two-dimensional array is represented as a one-dimensional array of integers. The first integer of the array denotes the length of each row of the 2D array. The remaining integers are the elements of the array, arranged row by row.
 
Multiple queries will be made about the 2D array. Each query contains the row and column coordinates of an element to retrieve.
 
Example:
arr = [5, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
queries = [[1, 1], [1, 2], [2, 1], [2, 2]]
 
The first value, arr[0] = 5, represents the length of each row of the 2D array. The next 10 elements, arr[1] through arr[10], form 2 rows of a 2D array as illustrated below. The coordinates of the top left element, arr[1], are (1, 1).
 
1 2 3 4 5 
6 7 8 9 10 
Processing each query:
1.	The value at position [1, 1] is 1.
2.	The value at position [1, 2] is 2.
3.	The value at position [2, 1] is 6.
4.	The value at position [2, 2] is 7.
The return array is [1, 2, 6, 7].
 
Function Description
Complete the function getElements in the editor with the following parameter(s):
    int arr[n]:  an array of integers
    int queries[q][2]:  the row and column positions queried
 
Returns
    int[q]: an array of answers to each query, aligned with queries by index
 
Constraints
•	1 ≤ n ≤ 1000
•	1 ≤ r ≤ 100
•	-100 ≤ arr[i] ≤ 100  where 1 ≤ i < n
•	1 ≤ q ≤ n - 1
•	1 ≤ queries[i][0] ≤ rows where 0 ≤ i < q
•	1 ≤ queries[i][1] ≤ columns where 0 ≤ i < q
 
Input Format for Custom Testing
The first line contains an integer n, the number of integers in the array arr.
Each line i of the next n lines (where 0 ≤ i < n) contains an integer denoting arr[i].
The next line contains an integer q, the number of queries which is also the size of queries array.
The next line contains the integer 2, the number of elements required to define each query which is also the number of columns of queries array.
Each line i of the next q lines (where 0 ≤ i < q) contains two space-separated integers denoting queries[i].
 
Sample Case 0
Sample Input
STDIN    Function
-----    --------
13    →  arr[] size n = 13
4     →  arr = [4, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]
1
2
3
4
5
6
7
8
9
10
11
12
2     →  queries[] size q = 2 (rows) 
2     →  queries[][] size = 2 (columns, always)
3 2   →  queries = [[3, 2], [2, 1]]
2 1
 
Sample Output
10
5
 
Explanation
Rows are arr[0] = 4 columns each. The representation of the array as a 2D array is:
1  2  3  4
5  6  7  8
9 10 11 12
The element at (3, 2) is 10, and at (2, 1) is 5.
 
Sample Case 1
Sample Input
STDIN    Function
-----    --------
11    →  arr[] size n = 11
2     →  arr = [2, 4, 1, 34, 12, -33, 78, 44, 65, -14, -92]
4
1
34
12
-33
78
44
65
-14
-92
4     →  queries[] size n = 4
2     →  queries[][] size rows = 2
4 1   →  queries = [[4, 1], [3, 2], [5, 1], [1, 1]]
3 2
5 1
1 1
 
Sample Output
44
78
-14
4
 
Explanation
The representation of the array as a 2D array is:
   4   1
  34  12
 -33  78
  44  65
 -14 -92
The element at (4, 1) is 44, at (3, 2) is 78, and so on.
 

class Result {
    public static List<Integer> getElements(List<Integer> arr, List<List<Integer>> queries) {
    // Write your code here
    List<List<Integer>> inpList = new ArrayList<>();
    List<Integer> response = new ArrayList<>();
    int len = arr.get(0);
    List<Integer> tmp = new ArrayList<>();
    for(int a = 1; a<arr.size();a++ ){
        tmp.add(arr.get(a));
        if((a%len)==0){
            inpList.add(tmp);
            tmp = new ArrayList<>();
        }
    }
    for(int i=0;i<queries.size();i++){
        int first = queries.get(i).get(0);
        int sec = queries.get(i).get(1);
        response.add(inpList.get(first-1).get(sec-1));
        
    }
    return response;
    }

}
public class Solution {
    public static void main(String[] args) throws IOException {
        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter bufferedWriter = new BufferedWriter(new FileWriter(System.getenv("OUTPUT_PATH")));

        int arrCount = Integer.parseInt(bufferedReader.readLine().trim());

        List<Integer> arr = IntStream.range(0, arrCount).mapToObj(i -> {
            try {
                return bufferedReader.readLine().replaceAll("\\s+$", "");
            } catch (IOException ex) {
                throw new RuntimeException(ex);
            }
        })
            .map(String::trim)
            .map(Integer::parseInt)
            .collect(toList());

        int queriesRows = Integer.parseInt(bufferedReader.readLine().trim());
        int queriesColumns = Integer.parseInt(bufferedReader.readLine().trim());

        List<List<Integer>> queries = new ArrayList<>();

        IntStream.range(0, queriesRows).forEach(i -> {
            try {
                queries.add(
                    Stream.of(bufferedReader.readLine().replaceAll("\\s+$", "").split(" "))
                        .map(Integer::parseInt)
                        .collect(toList())
                );
            } catch (IOException ex) {
                throw new RuntimeException(ex);
            }
        });

        List<Integer> result = Result.getElements(arr, queries);

        bufferedWriter.write(
            result.stream()
                .map(Object::toString)
                .collect(joining("\n"))
            + "\n"
        );

        bufferedReader.close();
        bufferedWriter.close();
    }
}












1.	Springboot: Music Streaming
This project is a practical assessment designed to evaluate understanding and skills in working with RESTful APIs using Spring Boot.
 
Below are examples of the JSON data for this project.:
 
Example of Artist data JSON Object
{
  "id": 1,
  "artistName": "Alex Doe",
  "bio": "Alex Doe is a popular artist...",
  "genre": "Pop",
  "origin": "USA",
  "formedYear": "2000",
  "socialLink": "https://www.alexdoe.com",
  "image": "https://www.alexdoe.com/image.jpg",
  "tracksProduced": [
    {
      "id": 1,
      "title": "Track 1",
      "albumName": "Album 1",
      "releaseDate": "2022-01-01",
      "duration": "3:30",
      "genre": "Pop",
      "description": "This is a description of Track 1",
      "playCount": 1000,
      "fileUrl": "https://www.alexdoe.com/track1.mp3",
      "coverImage": "https://www.alexdoe.com/track1.jpg"
    }
  ]
}
 
Example of Playlist data JSON Object
{
  "id": 1,
  "name": "My Playlist",
  "description": "This is my favorite playlist",
  "tracks": [
    {
      "id": 1,
      "name": "Track 1",
      "duration": "3:45",
      "artist": {
        "id": 1,
        "name": "Artist 1"
      }
    },
    {
      "id": 2,
      "name": "Track 2",
      "duration": "4:30",
      "artist": {
        "id": 2,
        "name": "Artist 2"
      }
    }
  ]
}
 
Example of Track data JSON Object
{
  "id": 1,
  "title": "Track 1",
  "albumName": "Album 1",
  "releaseDate": "2022-01-01",
  "duration": "3:30",
  "genre": "Pop",
  "description": "This is a description of Track 1",
  "playCount": 1000,
  "fileUrl": "https://www.alexdoe.com/track1.mp3",
  "coverImage": "https://www.alexdoe.com/track1.jpg",
  "artist": {
    "id": 1,
    "artistName": "Alex Doe",
    "bio": "Alex Doe is a popular artist...",
    "genre": "Pop",
    "origin": "USA",
    "formedYear": "2000",
    "socialLink": "https://www.alexdoe.com",
    "image": "https://www.alexdoe.com/image.jpg"
  }
}
 
Implement the following APIs:
 
ArtistController
•	POST /music/platform/v1/artists - Create a new artist.
•	GET /music/platform/v1/artists - Get all artists.
•	GET /music/platform/v1/artists/{artistId} - Get an artist by ID.
•	PUT /music/platform/v1/artists/{artistId} - Update an artist by ID.
•	DELETE /music/platform/v1/artists/{artistId} - Delete an artist by ID.
 
PlayListController
•	GET /music/platform/v1/playlists/{playlistId} - Get a playlist by ID.
•	POST /music/platform/v1/playlists - Create a new playlist.
•	DELETE /music/platform/v1/playlists/{playlistId} - Delete a playlist by ID.
 
TrackController
•	GET /music/platform/v1/tracks - Get all tracks.
•	POST /music/platform/v1/tracks - Create a new track.
•	GET /music/platform/v1/tracks/{trackId} - Get a track by ID.
•	PUT /music/platform/v1/tracks/{trackId} - Update a track by ID.
•	DELETE /music/platform/v1/tracks/{trackId} - Delete a track by ID.
 
Complete the project so that it passes all the test cases when running the provided unit tests. The project, by default, supports the use of the H2 database.
 
Example Requests and Responses
POST request to /music/platform/v1/artists
Request data JSON Object:
{
  "artistName": "Alex Doe",
  "bio": "Alex Doe is a popular artist...",
  "genre": "Pop",
  "origin": "USA",
  "formedYear": "2000",
  "socialLink": "https://www.alexdoe.com",
  "image": "https://www.alexdoe.com/image.jpg"
}
Response JSON Object:
{
  "id": 1,
  "artistName": "Alex Doe",
  "bio": "Alex Doe is a popular artist...",
  "genre": "Pop",
  "origin": "USA",
  "formedYear": "2000",
  "socialLink": "https://www.alexdoe.com",
  "image": "https://www.alexdoe.com/image.jpg"
}
 
GET request to /music/platform/v1/artists
Response JSON Object:
[
  {
    "id": 1,
    "artistName": "Alex Doe",
    "bio": "Alex Doe is a popular artist...",
    "genre": "Pop",
    "origin": "USA",
    "formedYear": "2000",
    "socialLink": "https://www.alexdoe.com",
    "image": "https://www.alexdoe.com/image.jpg"
  }
]
 
GET request to /music/platform/v1/artists/{artistId}
Response JSON Object:
{
  "id": 1,
  "artistName": "Alex Doe",
  "bio": "Alex Doe is a popular artist...",
  "genre": "Pop",
  "origin": "USA",
  "formedYear": "2000",
  "socialLink": "https://www.alexdoe.com",
  "image": "https://www.alexdoe.com/image.jpg"
}
 
PUT request to /music/platform/v1/artists/{artistId}
Request data JSON Object:
{
  "artistName": "Alex Doe",
  "bio": "Alex Doe is a popular artist...",
  "genre": "Pop",
  "origin": "USA",
  "formedYear": "2000",
  "socialLink": "https://www.alexdoe.com",
  "image": "https://www.alexdoe.com/image.jpg"
}
Response JSON Object:
{
  "id": 1,
  "artistName": "Alex Doe",
  "bio": "Alex Doe is a popular artist...",
  "genre": "Pop",
  "origin": "USA",
  "formedYear": "2000",
  "socialLink": "https://www.alexdoe.com",
  "image": "https://www.alexdoe.com/image.jpg"
}
 
DELETE request to /music/platform/v1/artists/{artistId}
No response data. Returns a 204 No Content status.
 
POST request to /music/platform/v1/playlists:
Request data JSON Object:
{
  "name": "My Playlist",
  "description": "This is my favorite playlist"
}
Response JSON Object:
{
  "id": 1,
  "name": "My Playlist",
  "description": "This is my favorite playlist"
}
 
GET request to /music/platform/v1/playlists/{playlistId}
Response JSON Object:
{
  "id": 1,
  "name": "My Playlist",
  "description": "This is my favorite playlist"
}
 
DELETE request to /music/platform/v1/playlists/{playlistId}
No response data. Returns a 204 No Content status.
 
POST request to /music/platform/v1/tracks
Request data JSON Object:
{
  "title": "Track 1",
  "albumName": "Album 1",
  "releaseDate": "2022-01-01",
  "duration": "3:30",
  "genre": "Pop",
  "description": "This is a description of Track 1",
  "playCount": 1000,
  "fileUrl": "https://www.alexdoe.com/track1.mp3",
  "coverImage": "https://www.alexdoe.com/track1.jpg"
}
Response JSON Object:
{
  "id": 1,
  "title": "Track 1",
  "albumName": "Album 1",
  "releaseDate": "2022-01-01",
  "duration": "3:30",
  "genre": "Pop",
  "description": "This is a description of Track 1",
  "playCount": 1000,
  "fileUrl": "https://www.alexdoe.com/track1.mp3",
  "coverImage": "https://www.alexdoe.com/track1.jpg"
}
 
GET request to /music/platform/v1/tracks
Response JSON Object:
[
  {
    "id": 1,
    "title": "Track 1",
    "albumName": "Album 1",
    "releaseDate": "2022-01-01",
    "duration": "3:30",
    "genre": "Pop",
    "description": "This is a description of Track 1",
    "playCount": 1000,
    "fileUrl": "https://www.alexdoe.com/track1.mp3",
    "coverImage": "https://www.alexdoe.com/track1.jpg"
  }
]
 
GET request to /music/platform/v1/tracks/{trackId}
Response JSON Object:
{
  "id": 1,
  "title": "Track 1",
  "albumName": "Album 1",
  "releaseDate": "2022-01-01",
  "duration": "3:30",
  "genre": "Pop",
  "description": "This is a description of Track 1",
  "playCount": 1000,
  "fileUrl": "https://www.alexdoe.com/track1.mp3",
  "coverImage": "https://www.alexdoe.com/track1.jpg"
}
 
PUT request to /music/platform/v1/tracks/{trackId}
Request data JSON Object:
{
  "title": "Track 1",
  "albumName": "Album 1",
  "releaseDate": "2022-01-01",
  "duration": "3:30",
  "genre": "Pop",
  "description": "This is a description of Track 1",
  "playCount": 1000,
  "fileUrl": "https://www.alexdoe.com/track1.mp3",
  "coverImage": "https://www.alexdoe.com/track1.jpg"
}
Response JSON Object:
{
  "id": 1,
  "title": "Track 1",
  "albumName": "Album 1",
  "releaseDate": "2022-01-01",
  "duration": "3:30",
  "genre": "Pop",
  "description": "This is a description of Track 1",
  "playCount": 1000,
  "fileUrl": "https://www.alexdoe.com/track1.mp3",
  "coverImage": "https://www.alexdoe.com/track1.jpg"
}
 
DELETE request to /music/platform/v1/tracks/{trackId}
No response data. Returns a 204 No Content status.















2.	Springboot: Sports health Coaching
This project is a practical assessment designed to evaluate understanding and skills in working with RESTful APIs using Spring Boot.
 
Here is an example of a customer JSON object:
{
  "id": 1,
  "height": 180,
  "weight": 80,
  "coach": {
    "id": 1,
    "name": "Alex Doe"
  }
}
 
Here is an example of a coach JSON object:
{
  "id": 1,
  "name": "Alex Doe"
}
 
The project consists of two empty controller classes, CustomerController and CoachController, that must be implemented. The controllers should have the following endpoints:
 
CustomerController
POST request to /api/customer:
•	Create a new customer.
•	Accepts a JSON body with height, weight, and coach_id fields.
•	Return the created record with a 201 Created status.
GET request to /api/customer:
•	Return a list of all customer records in the database sorted by id in ascending order.
GET request to /api/customer/{id}:
•	Return a customer record with the given id.
•	If the customer record exists, return the record with a 200 OK status.
•	If the customer record does not exist, return a 404 Not Found status.
 
CoachController
POST request to /api/coach:
•	Create a new coach.
•	Accepts a JSON body with name field.
•	Return the created record with a 201 Created status.
GET request to /api/coach:
•	Return a list of all coach records in the database sorted by id in ascending order.
•	Return the list with a 200 OK status.
GET request to /api/coach/{id}:
•	Return a coach record with the given id.
•	If the coach record exists, return the record with a 200 OK status.
•	If the coach record does not exist, return a 404 Not Found status.
 
Please ensure that all endpoints handle errors appropriately and return the correct HTTP status codes so that all unit tests pass.
 
Example Requests and Responses
POST request to /api/customer:
Request data JSON Object:
{
  "height": 180,
  "weight": 80,
  "coach_id": 1
}
Response JSON Object:
{
  "id": 1,
  "height": 180,
  "weight": 80,
  "coach": {
    "id": 1,
    "name": "Alex Doe"
  }
}
 
GET request to /api/customer:
Response JSON Object:
[
  {
    "id": 1,
    "height": 180,
    "weight": 80,
    "coach": {
      "id": 1,
      "name": "Alex Doe"
    }
  }
]
 
GET request to /api/customer/{id}:
Response JSON Object:
{
  "id": 1,
  "height": 180,
  "weight": 80,
  "coach": {
    "id": 1,
    "name": "Alex Doe"
  }
}
 
POST request to /api/coach:
Request data JSON Object:
{
  "name": "Alex Doe"
}
Response JSON Object:
{
  "id": 1,
  "name": "Alex Doe"
}
 
GET request to /api/coach:
Response JSON Object:
[
  {
    "id": 1,
    "name": "Alex Doe"
  },
  {
    "id": 2,
    "name": "Sam"
  }
]
 
GET request to /api/coach/{id}:
Response JSON Object:
{
  "id": 1,
  "name": "Alex Doe"
}



3.	SpringBoot: Music Track API’s
In this project, you'll be working with a team to create a music streaming platform. Your main task is to develop a REST API that shares details about music tracks. You need to ensure this API can receive, show, and query data like track title, album, description, and play count. Your work will be judged on how accurately and efficiently the application handles and processes this data.
 
Music track data is represented as a JSON object, each describing various properties of a music track. The following properties are included:
•	id: The unique integer ID of the object(Long).
•	title: The title of the track(String).
•	albumName: The corresponding album name of the track(String).
•	releaseDate: The release date of the track, formatted as YYYY-MM-DD(Date).
•	playCount: An integer value denoting how many times a user has played this track(Integer).
 
Example of a music track data JSON object:
 
{
  "title": "Lost in Echoes",
  "albumName": "Echoes of the Unknown",
  "releaseDate": "2021-07-15",
  "playCount": 5000
}
 
The REST service must expose the endpoint /music/platform/v1/tracks, enabling the management of music track records as follows:
 
POST request to /music/platform/v1/tracks:
•	Creates a new music track record.
•	It expects a valid music track data object as its body payload, excluding the id property.
•	The service assigns a unique long id to the added object.
•	The response includes the created record with its unique id, and the response code is 201.
 
GET request to /music/platform/v1/tracks:
•	Responds with a list of all music track records and a response code of 200.
 
GET request to /music/platform/v1/tracks/search:
•	Responds with music track records filtered by title, Consider track title is unique. (Eg - /music/platform/v1/tracks/search?title=Henry)
•	The response code is 200. It accepts query string parameter title.
•	Records are returned based on matching title.
 
DELETE request to /music/platform/v1/tracks/{trackId}:
•	Deletes the record with the specified track id if it exists in the database with the status code of 204.
 
Your task is to ensure the project meets all test case criteria when running the provided rspec tests. The project uses H2 database by default. Start by implementing the POST request to music/platform/v1/tracks, as testing other methods requires the POST functionality to work correctly.
 
Example requests and responses
POST request to /music/platform/v1/tracks
Request body:
{
   "title":"Lost in Echoes",
   "albumName":"Echoes of the Unknown",
   "releaseDate":"2021-07-15",
   "playCount":5000
}
The response code is 201, and when converted to JSON, the response body is:
{
   "id":1,
   "title":"Lost in Echoes",
   "albumName":"Echoes of the Unknown",
   "releaseDate":"2021-07-15",
   "playCount":5000
}
This adds a new object to the collection with the given properties and id 1.
 
GET request to /music/platform/v1/tracks
The response code is 200, and when converted to JSON, the response body (assuming that the below objects are all objects in the collection) is as follows:
[
   {
      "id":1,
      "title":"Lost in Echoes",
      "albumName":"Echoes of the Unknown",
      "releaseDate":"2021-07-15",
      "playCount":5000
   },
   {
      "id":2,
      "title":"Bravos",
      "albumName":"Unknown",
      "releaseDate":"2021-07-16",
      "playCount":100
   }
]
      
 
GET request to /music/platform/v1/tracks/search
The response code is 200, and when converted to JSON, the response body (assuming that the below objects are all objects with title is "Lost in Echoes" also unique) is as follows:
{
   "id":1,
   "title":"Lost in Echoes",
   "albumName":"Echoes of the Unknown",
   "releaseDate":"2021-07-15",
   "playCount":5000
}

DELETE request to music/platform/v1/tracks/1
Assuming that the object with id 1 exists, then the response code is 204 and the response body is empty.

4.	Springboot: Artist Management API’S
In this challenge, implement a simple REST API to manage a collection of Artist data.
 
Each artist is a JSON entry with the following keys:
•	id: the unique ID of the event (Long).
•	firstName: first name of the artist (String).
•	lastName: last name of the artist (String).
 
Here is an example of an artist JSON object:
{
      "firstName": "Dasun",
      "lastName": "Anushka"
}
 
 
An implementation of the Artist model is provided. Implement a REST service that exposes the /v1/artists endpoints, which allows for managing the collection of artists' records in the following way:
 
POST request to /v1/artists:
•	CCreates a new artist data record.
•	The response code is 201, and the response body is the created record, including its unique id.
 
GET request to /v1/artists:
•	The response code is 200.
•	The response body is a list of matching records, ordered by their ids in increasing order.
 
GET request to /v1/artists/{artistId}:
•	Returns a record with the given id and status code 200.
•	If there is no record with the given id, the response code is null.
 
DELETE request to /v1/artists/{artistId}:
•	Delete the record with the given id and return status code 204.
 
Complete the project so that it passes all the test cases when running the provided unit tests. The project, by default, supports the use of the H2 database.
 
Example requests and responses
POST request to /v1/artists
Request body:
{
         "firstName": "Dasun",
         "lastName": "Anushka"
}
The response code is 201, and when converted to JSON, the response body is:
{
        "id" : 1,
        "firstName": "Dasun",
        "lastName": "Anushka"
}
This adds a new object to the collection with the given properties and id 1.
 
GET request to /v1/artists
The response code is 200, and when converted to JSON, the response body (assuming that the objects are in the collection) is as follows:
[
        {
          "id" : 1,
          "firstName": "Dasun",
          "lastName": "Anushka"
        },
        {
          "id": 2,
          "firstName": "Anushka",
          "lastName": "Lakmal"
        },
        {
          "id": 3,
          "firstName": "Era",
          "lastName": "Jaye"
        }
  ]
      
 
GET request to /v1/artists/1
The response code is 200, and when converted to JSON, the response body is as follows:
[
        {
          "id" : 1,
          "firstName": "Dasun",
          "lastName": "Anushka"
        }
  ]
      
    
If an object with id 1 does not exist, the response is null.
 
DELETE request to /v1/artists/1
Assuming that an object with id 1 exists, the response code is 204, and the response body is empty.













5.	SpringBoot: Playlist Management API’S
Implement a simple REST API to manage a collection of music playlist data.
 
Each PlayList is a JSON entry with the following keys:
•	id: the unique ID of the event (Long).
•	name: name of the play list (String).
•	tracksCount: initial number of tracks in the play list (Integer).
 
Here is an example of a PlayList JSON object:
{
      "name": "Henry1s list",
      "tracksCount": 10
}
An implementation of the PlayList model is provided. Implement a REST service that exposes the v1/playlists endpoints, which allows for managing the collection of PlayList records in the following way:
 
POST request to /v1/playlists:
•	Create a new playlist data record.
•	The response code is 201, and the response body is the created record, including its unique id.
 
GET request to /v1/playlists:
•	The response code is 200.
•	The response body is a list of matching records, ordered by their ids in increasing order.
 
GET request to /v1/playlists/{playListId}:
•	Return a record with the given id and status code 200.
•	If there is no record with the given id, the response code is null.
 
DELETE request to /v1/playlists/{playListId}:
•	Delete the record with the given id and return status code 204.
 
Complete the project so that it passes all the test cases when running the provided unit tests. The project, by default, supports the use of the H2 database.
 
Example requests and responses
POST request to /v1/playlists
Request body:
{
      "name": "Henry1s list",
      "tracksCount": 10
}
The response code is 201, and when converted to JSON, the response body is:
{
      "id": 1,
      "name": "Henry1s list",
      "tracksCount": 10
}
This adds a new object to the collection with the given properties and id 1.
 
GET request to /v1/playlists
The response code is 200, and when converted to JSON, the response body (assuming that the objects are all in the collection) is as follows:
[
   {
      "id":1,
      "name":"Henry1s list",
      "tracksCount":10
   },
   {
      "id":2,
      "name":"Bera",
      "tracksCount":10
   },
   {
      "id":3,
      "name":"Namal",
      "tracksCount":10
   }
]
      
 
GET request to /v1/playlists/1
The response code is 200, and when converted to JSON, the response body is as follows:
{
   "id":1,
   "name":"Henry1s list",
   "tracksCount":10
}
      
    
 
DELETE request to /v1/playlists/1
Assuming that the object with id 1 exists, the response code is 204, and the response body is empty.


















6.	SpringBoot: Track Information API’s
Develop a REST API that shares details about music tracks for a music streaming platform. This API can receive, show, and query data like the track title, album, description, and play count. The work is judged based on how accurately and efficiently the application handles and processes this data.
 
Music track data is represented as a JSON object, each describing various properties of a music track. The following properties are included:
•	id: The unique integer ID of the object (Long).
•	title: The title of the track (String).
•	albumName: The corresponding album name of the track (String).
•	releaseDate: The release date of the track, formatted as YYYY-MM-DD (Date).
•	playCount: An integer value denoting how many times a user has played this track (Integer).
 
Example of a music track data JSON object:
 
{
  "title": "Lost in Echoes",
  "albumName": "Echoes of the Unknown",
  "releaseDate": "2021-07-15",
  "playCount": 5000
}
 
The REST service must expose the endpoint /music/platform/v1/tracks, enabling the management of music track records as follows:
 
POST request to /music/platform/v1/tracks:
•	Creates a new music track record.
•	It expects a valid music track data object as its body payload, excluding the id property.
•	The service assigns a unique long id to the added object.
•	The response includes the created record with its unique id, and the response code is 201.
 
GET request to /music/platform/v1/tracks:
•	Responds with a list of all music track records and a response code of 200.
 
DELETE request to /music/platform/v1/tracks/{trackId}:
•	Deletes the record with the specified track id if it exists in the database.
 
GET request to /music/platform/v1/tracks/sorted:
•	Provides a list of music track records sorted by title.
•	The response code is 200.
•	The system defaults to sorting by title in ascending order.
 
Ensure the project meets all test case criteria when running the provided rspec tests. It uses the H2 database by default. Start by implementing the POST request to music/platform/v1/tracks, as testing other methods requires the POST functionality to work correctly.
 
Example requests and responses
POST request to /music/platform/v1/tracks
Request body:
{
   "title":"Lost in Echoes",
   "albumName":"Echoes of the Unknown",
   "releaseDate":"2021-07-15",
   "playCount":5000
}
The response code is 201, and when converted to JSON, the response body is:
{
   "id":1,
   "title":"Lost in Echoes",
   "albumName":"Echoes of the Unknown",
   "releaseDate":"2021-07-15",
   "playCount":5000
}
This adds a new object to the collection with the given properties and id 1.
 
GET request to /music/platform/v1/tracks
The response code is 200, and when converted to JSON, the response body, assuming these objects are in the collection, is as follows:
[
   {
      "id":1,
      "title":"Lost in Echoes",
      "albumName":"Echoes of the Unknown",
      "releaseDate":"2021-07-15",
      "playCount":5000
   },
   {
      "id":2,
      "title":"Bravos",
      "albumName":"Unknown",
      "releaseDate":"2021-07-16",
      "playCount":100
   }
]
 
DELETE request to /music/platform/v1/tracks/1
Assuming that the object with id 1 exists, the response code is 204, and the response body is empty.
 
GET request to /music/platform/v1/tracks/sorted
The response code is 200, and when converted to JSON, the response body, the returned collection sorted by its title ascending order, is as follows:
[
   {
      "id":1,
      "title":"Abacus",
      "albumName":"Echoes of the Unknown",
      "releaseDate":"2021-07-15",
      "playCount":5000
   },
   {
      "id":2,
      "title":"Bravos",
      "albumName":"Unknown",
      "releaseDate":"2021-07-16",
      "playCount":100
   }
]





















7.	School API’s
In this project, there is a teacher and student management system for a typical school where a teacher has many students and a student has many teachers. Here we are using a hibernate many-to-many relationship to manage such information.
 
Here is an example of a teacher data JSON object:
{
    "id": 1,
    "name": "Mark",
    "students": "[]"
}
 
Here is an example of a student data JSON object:
{
    "id": 1,
    "name": "Salo",
    "teachers": "[]"
}
 
The application should adhere to the following API format and response codes in SchoolController:
 
POST /school/teacher/{teacherId}/addStudent:
•	Assume that the given teacherId already exists in the database.
•	The request body will have a student instance. It might be a new student or an existing one.
•	Assume that the given student has never been added to the given teacher.
•	Return the teacher instance after adding the student, along with status code 201.
 
GET school/teacher/{teacherId}/students:
•	Assume that the given teacherId already exists in the database.
•	Return the list of students associated with that teacherId and status code 200.
 
GET /school/student/{studentId}/teachers:
•	Assume the given studentId exists in the database.
•	Return the list of teachers associated with the studentId and status code 200.

















8.	Event API
In this project, data is given regarding various events, including their name, location, duration, and cost. Your task is to implement several REST endpoints to handle this data.
 
Here is an example of an event data JSON object:
{
    "id":1,
    "name": "Soft Summit",
    "location": "Xton City",
    "duration": 8,
    "cost": 30
}
 
The application should adhere to the following API format and response codes:
 
GET /event/{id}:
•	Return the event entry with the given ID and status code 200.
•	If the requested event entry doesn't exist, then status code 404 should be returned.
GET /event/top3?by={by}:
•	Return the top 3 event entries sorted by the given field and status code 200.
•	For example: /event/top3?by=cost returns the top 3 entries by cost.
•	If by is an invalid attribute (other than cost or duration), return status code 400.
GET /event/total?by={by}:
•	Return the total value summed by the given field and status code 200.
•	For example: /event/total?by=duration returns the total duration of all events.
•	If by is an invalid attribute (other than cost and duration), return status code 400.
9.	Covid API
In this project, virtual data related to COVID-19 is provided for many countries. (Note that all the data is artificial.) Your task is to implement several REST endpoints to handle this data.
 
Here is an example of a COVID data JSON object:
{
    "id":1,
    "country":"MyCountry",
    "active":574,
    "death":45,
    "recovered": 7000
}
 
The application should adhere to the following API format and response codes:
 
GET /covid/{id}:
•	Return the COVID entry with the given ID and status code 200.
•	If the requested entry does not exist, status code 404 should be returned.
GET /covid/top5?by={by}:
•	Return the top 5 COVID entries sorted by given field and status code 200.
•	For example: /covid/top5?by=death gives total deaths.
•	If by is an invalid attribute, return status code 400.
GET /covid/total?by={by}:
•	Return the total value summed by the field and status code 200.
•	For example: /covid/total?by=active gives total active cases.
•	If by is an invalid attribute, return status code 400.
10.	SiteScanner API
In this project, scan data is given for several websites. Your task is to implement several REST endpoints to handle this data.
 
Here is an example of a scan data JSON object:
{
    "id": 1,
    "domainName": "testdomain.com",
    "numPages": 574,
    "numBrokenLinks": 45,
    "numMissingImages": 34,
    "deleted": false
}
The application should adhere to the following API format and response codes:
 
GET /scan/{id}:
•	Returns the scan with the given ID and status code 200.
•	If the requested scan doesn't exist, status code 404 is returned.
DELETE /scan/{id}:
•	Deletes the scan with the given ID and returns status code 200.
•	"Deleted" means the scan is logically deleted, not completely removed from the database.
•	If the scan doesn't exist in the database, status code 404 is returned.
GET /scan/search/{domainName}?orderBy={numPages):
•	Return the scans filtered by product and sorted by the given column with status code 200.
•	When the given orderBy column doesn't exist, status code 400 is returned.
11.	 Spring Boot: The Library
A librarian wants to offer an online search page for the library's book catalog. Each book has a unique identifier called an ISBN number assigned at publication, which will be the search identifier. A paginated API that returns the books available in the library already exists.
 
The REST service needs to expose 3 API endpoints for 3 different operations:
1.	GET request to /book/{isbn}:
•	Receives one parameter called ISBN using the route parameter
•	Calls the book list function in the controller
•	If the ISBN number does not occur in the first 5 pages, returns a status code 400
•	If the ISBN number exists in the first 5 pages, it returns a JSON object with the 'Book_Name' and 'Author', the book and the author's names
2.	GET request to /bookPage/{isbn}:
•	Receives one parameter called ISBN using the route parameter
•	Calls the book list function in the controller
•	If the ISBN number does not exist, returns a status code 400
•	If the ISBN number exists, it returns a JSON object with 'Book_PageCategory', a value based on the number of pages in the book and a status code of 200
•	Number of pages -> 'Book_PageCategory' value to return:
•	0-99 Pages -> Small
•	100-299 Pages -> Medium
•	300+ -> Large
3.	GET request to /bookRating/{rating}:
•	Receives one parameter called rating using the route parameter
•	If the user enters a rating that is not between 1 and 5 inclusive, returns a status code 400
•	Calls the book list function in the controller and returns a JSON object with 'Book_Count', the count of books whose rating is greater than or equal to the supplied rating and a status code of 200
 
Complete the given project so that it passes all the provided unit tests.
 
Resource: Open Library API: https://openlibrary.org/api/books?bibkeys=ISBN:{book_id}&jscmd=data&format=json
 
Example requests and responses
GET request to /book/{isbn}
Response JSON:
http://localhost:8080/book/1514683687 returns 

{
  "Book_Name":"Around the World in 80 Days",
  "Author":"Jules Verne"
}

            
The response code is 200.
 
For http://localhost:8080/book/2222, there is no such book in the first 5 pages of the book list. A response code 400 should be returned.
 
GET request to /bookPage/{isbn}
Response JSON:
http://localhost:8080/bookPage/1514683687 returns 

{
  "Book_PageCategory": "Medium"
}

            
The response code is 200.
For http://localhost:8080/bookPage/2222, there is no such book in the first 5 pages of the book list. A response code 400 should be returned.
 
GET request to /bookRating/{rating}
Response JSON:
http://localhost:8080/bookRating/1.5 returns 

{
  "Book_Count": 50
}
            
The response code is 200.
If there is no book with a rating greater than or equal to the requested value in the first 5 pages of the book list, a response code 400 should be returned.
If the requested rating is less than 1 or greater than 5, a response code 400 should be returned.
